{
  "_format": "hh3-sol-build-info-1",
  "id": "solc-0_8_29-13bd7b456e3da66b63ba7a4613b3768bcbe11417",
  "solcVersion": "0.8.29",
  "solcLongVersion": "0.8.29+commit.ab55807c",
  "userSourceNameMap": {
    "@openzeppelin/contracts/token/ERC20/ERC20.sol": "npm/@openzeppelin/contracts@5.4.0/token/ERC20/ERC20.sol",
    "@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol": "npm/@openzeppelin/contracts@5.4.0/token/ERC20/extensions/IERC20Metadata.sol",
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": "npm/@openzeppelin/contracts@5.4.0/token/ERC20/IERC20.sol",
    "@openzeppelin/contracts/utils/Context.sol": "npm/@openzeppelin/contracts@5.4.0/utils/Context.sol",
    "@scroll-tech/contracts/L1/IL1ScrollMessenger.sol": "npm/@scroll-tech/contracts@2.0.1/L1/IL1ScrollMessenger.sol",
    "@scroll-tech/contracts/L2/IL2ScrollMessenger.sol": "npm/@scroll-tech/contracts@2.0.1/L2/IL2ScrollMessenger.sol",
    "@zk-kit/lazy-imt.sol/Constants.sol": "npm/@zk-kit/lazy-imt.sol@2.0.0-beta.12/Constants.sol",
    "@zk-kit/lazy-imt.sol/InternalLazyIMT.sol": "npm/@zk-kit/lazy-imt.sol@2.0.0-beta.12/InternalLazyIMT.sol",
    "@zk-kit/lazy-imt.sol/LazyIMT.sol": "npm/@zk-kit/lazy-imt.sol@2.0.0-beta.12/LazyIMT.sol",
    "contracts/evm/adapters/L1AztecBridgeAdapter.sol": "project/contracts/evm/adapters/L1AztecBridgeAdapter.sol",
    "contracts/evm/adapters/L1ScrollBridgeAdapter.sol": "project/contracts/evm/adapters/L1ScrollBridgeAdapter.sol",
    "contracts/evm/adapters/L2ScrollBridgeAdapter.sol": "project/contracts/evm/adapters/L2ScrollBridgeAdapter.sol",
    "contracts/evm/aztec-interfaces/ConfigurationLib.sol": "project/contracts/evm/aztec-interfaces/ConfigurationLib.sol",
    "contracts/evm/aztec-interfaces/ConstantsGen.sol": "project/contracts/evm/aztec-interfaces/ConstantsGen.sol",
    "contracts/evm/aztec-interfaces/CoreDataStructures.sol": "project/contracts/evm/aztec-interfaces/CoreDataStructures.sol",
    "contracts/evm/aztec-interfaces/CoreErrors.sol": "project/contracts/evm/aztec-interfaces/CoreErrors.sol",
    "contracts/evm/aztec-interfaces/crypto/FrontierLib.sol": "project/contracts/evm/aztec-interfaces/crypto/FrontierLib.sol",
    "contracts/evm/aztec-interfaces/crypto/Hash.sol": "project/contracts/evm/aztec-interfaces/crypto/Hash.sol",
    "contracts/evm/aztec-interfaces/crypto/MerkleLib.sol": "project/contracts/evm/aztec-interfaces/crypto/MerkleLib.sol",
    "contracts/evm/aztec-interfaces/crypto/SampleLib.sol": "project/contracts/evm/aztec-interfaces/crypto/SampleLib.sol",
    "contracts/evm/aztec-interfaces/crypto/SignatureLib.sol": "project/contracts/evm/aztec-interfaces/crypto/SignatureLib.sol",
    "contracts/evm/aztec-interfaces/GovernanceDataStructures.sol": "project/contracts/evm/aztec-interfaces/GovernanceDataStructures.sol",
    "contracts/evm/aztec-interfaces/GovernanceErrors.sol": "project/contracts/evm/aztec-interfaces/GovernanceErrors.sol",
    "contracts/evm/aztec-interfaces/ICoinIssuer.sol": "project/contracts/evm/aztec-interfaces/ICoinIssuer.sol",
    "contracts/evm/aztec-interfaces/IFeeJuicePortal.sol": "project/contracts/evm/aztec-interfaces/IFeeJuicePortal.sol",
    "contracts/evm/aztec-interfaces/IGovernance.sol": "project/contracts/evm/aztec-interfaces/IGovernance.sol",
    "contracts/evm/aztec-interfaces/IGovernanceProposer.sol": "project/contracts/evm/aztec-interfaces/IGovernanceProposer.sol",
    "contracts/evm/aztec-interfaces/IInstance.sol": "project/contracts/evm/aztec-interfaces/IInstance.sol",
    "contracts/evm/aztec-interfaces/IMintableERC20.sol": "project/contracts/evm/aztec-interfaces/IMintableERC20.sol",
    "contracts/evm/aztec-interfaces/IPayload.sol": "project/contracts/evm/aztec-interfaces/IPayload.sol",
    "contracts/evm/aztec-interfaces/IRegistry.sol": "project/contracts/evm/aztec-interfaces/IRegistry.sol",
    "contracts/evm/aztec-interfaces/IRewardDistributor.sol": "project/contracts/evm/aztec-interfaces/IRewardDistributor.sol",
    "contracts/evm/aztec-interfaces/IRollup.sol": "project/contracts/evm/aztec-interfaces/IRollup.sol",
    "contracts/evm/aztec-interfaces/ISlasher.sol": "project/contracts/evm/aztec-interfaces/ISlasher.sol",
    "contracts/evm/aztec-interfaces/IStaking.sol": "project/contracts/evm/aztec-interfaces/IStaking.sol",
    "contracts/evm/aztec-interfaces/IValidatorSelection.sol": "project/contracts/evm/aztec-interfaces/IValidatorSelection.sol",
    "contracts/evm/aztec-interfaces/IVerifier.sol": "project/contracts/evm/aztec-interfaces/IVerifier.sol",
    "contracts/evm/aztec-interfaces/messagebridge/IInbox.sol": "project/contracts/evm/aztec-interfaces/messagebridge/IInbox.sol",
    "contracts/evm/aztec-interfaces/messagebridge/IOutbox.sol": "project/contracts/evm/aztec-interfaces/messagebridge/IOutbox.sol",
    "contracts/evm/aztec-interfaces/ProposalLib.sol": "project/contracts/evm/aztec-interfaces/ProposalLib.sol",
    "contracts/evm/aztec-interfaces/rollup/BlobLib.sol": "project/contracts/evm/aztec-interfaces/rollup/BlobLib.sol",
    "contracts/evm/aztec-interfaces/rollup/CheatLib.sol": "project/contracts/evm/aztec-interfaces/rollup/CheatLib.sol",
    "contracts/evm/aztec-interfaces/rollup/FeeLib.sol": "project/contracts/evm/aztec-interfaces/rollup/FeeLib.sol",
    "contracts/evm/aztec-interfaces/rollup/HeaderLib.sol": "project/contracts/evm/aztec-interfaces/rollup/HeaderLib.sol",
    "contracts/evm/aztec-interfaces/rollup/ProposeLib.sol": "project/contracts/evm/aztec-interfaces/rollup/ProposeLib.sol",
    "contracts/evm/aztec-interfaces/rollup/RewardLib.sol": "project/contracts/evm/aztec-interfaces/rollup/RewardLib.sol",
    "contracts/evm/aztec-interfaces/rollup/STFLib.sol": "project/contracts/evm/aztec-interfaces/rollup/STFLib.sol",
    "contracts/evm/aztec-interfaces/SlotDerivation.sol": "project/contracts/evm/aztec-interfaces/SlotDerivation.sol",
    "contracts/evm/aztec-interfaces/staking/StakingLib.sol": "project/contracts/evm/aztec-interfaces/staking/StakingLib.sol",
    "contracts/evm/aztec-interfaces/TimeLib.sol": "project/contracts/evm/aztec-interfaces/TimeLib.sol",
    "contracts/evm/aztec-interfaces/TimeMath.sol": "project/contracts/evm/aztec-interfaces/TimeMath.sol",
    "contracts/evm/aztec-interfaces/TransientSlot.sol": "project/contracts/evm/aztec-interfaces/TransientSlot.sol",
    "contracts/evm/aztec-interfaces/UserLib.sol": "project/contracts/evm/aztec-interfaces/UserLib.sol",
    "contracts/evm/aztec-interfaces/validator-selection/ValidatorSelectionLib.sol": "project/contracts/evm/aztec-interfaces/validator-selection/ValidatorSelectionLib.sol",
    "contracts/evm/aztec-interfaces/Vm.sol": "project/contracts/evm/aztec-interfaces/Vm.sol",
    "contracts/evm/GigaBridge.sol": "project/contracts/evm/GigaBridge.sol",
    "contracts/evm/interfaces/IGigaBridge.sol": "project/contracts/evm/interfaces/IGigaBridge.sol",
    "contracts/evm/interfaces/IL1BridgeAdapter.sol": "project/contracts/evm/interfaces/IL1BridgeAdapter.sol",
    "contracts/evm/interfaces/IL2BridgeAdapter.sol": "project/contracts/evm/interfaces/IL2BridgeAdapter.sol",
    "contracts/evm/interfaces/IRootMessengers.sol": "project/contracts/evm/interfaces/IRootMessengers.sol",
    "contracts/evm/interfaces/IWarpToadCore.sol": "project/contracts/evm/interfaces/IWarpToadCore.sol",
    "contracts/evm/test/ERC206Dec.sol": "project/contracts/evm/test/ERC206Dec.sol",
    "contracts/evm/test/USDcoin.sol": "project/contracts/evm/test/USDcoin.sol",
    "contracts/evm/warptoad/L1WarpToad.sol": "project/contracts/evm/warptoad/L1WarpToad.sol",
    "contracts/evm/warptoad/L2WarpToad.sol": "project/contracts/evm/warptoad/L2WarpToad.sol",
    "contracts/evm/warptoad/WarpToadCore.sol": "project/contracts/evm/warptoad/WarpToadCore.sol",
    "contracts/evm/WithdrawVerifier.sol": "project/contracts/evm/WithdrawVerifier.sol",
    "contracts/LazyIMT.sol": "project/contracts/LazyIMT.sol",
    "poseidon-solidity/PoseidonT3.sol": "npm/poseidon-solidity@0.0.5/PoseidonT3.sol"
  },
  "input": {
    "language": "Solidity",
    "settings": {
      "evmVersion": "cancun",
      "optimizer": {
        "enabled": true,
        "runs": 20
      },
      "outputSelection": {
        "*": {
          "": [
            "ast"
          ],
          "*": [
            "abi",
            "evm.bytecode",
            "evm.deployedBytecode",
            "evm.methodIdentifiers",
            "metadata"
          ]
        }
      },
      "remappings": [
        "npm/@zk-kit/lazy-imt.sol@2.0.0-beta.12/:poseidon-solidity/=npm/poseidon-solidity@0.0.5/",
        "project/:@openzeppelin/contracts/=npm/@openzeppelin/contracts@5.4.0/",
        "project/:@openzeppelin/contracts/=npm/@openzeppelin/contracts@5.4.0/",
        "project/:@openzeppelin/contracts/=npm/@openzeppelin/contracts@5.4.0/",
        "project/:@openzeppelin/contracts/=npm/@openzeppelin/contracts@5.4.0/",
        "project/:@openzeppelin/contracts/=npm/@openzeppelin/contracts@5.4.0/",
        "project/:@openzeppelin/contracts/=npm/@openzeppelin/contracts@5.4.0/",
        "project/:@openzeppelin/contracts/=npm/@openzeppelin/contracts@5.4.0/",
        "project/:@openzeppelin/contracts/=npm/@openzeppelin/contracts@5.4.0/",
        "project/:@openzeppelin/contracts/=npm/@openzeppelin/contracts@5.4.0/",
        "project/:@openzeppelin/contracts/=npm/@openzeppelin/contracts@5.4.0/",
        "project/:@openzeppelin/contracts/=npm/@openzeppelin/contracts@5.4.0/",
        "project/:@openzeppelin/contracts/=npm/@openzeppelin/contracts@5.4.0/",
        "project/:@openzeppelin/contracts/=npm/@openzeppelin/contracts@5.4.0/",
        "project/:@openzeppelin/contracts/=npm/@openzeppelin/contracts@5.4.0/",
        "project/:@openzeppelin/contracts/=npm/@openzeppelin/contracts@5.4.0/",
        "project/:@openzeppelin/contracts/=npm/@openzeppelin/contracts@5.4.0/",
        "project/:@openzeppelin/contracts/=npm/@openzeppelin/contracts@5.4.0/",
        "project/:@openzeppelin/contracts/=npm/@openzeppelin/contracts@5.4.0/",
        "project/:@openzeppelin/contracts/=npm/@openzeppelin/contracts@5.4.0/",
        "project/:@openzeppelin/contracts/=npm/@openzeppelin/contracts@5.4.0/",
        "project/:@openzeppelin/contracts/=npm/@openzeppelin/contracts@5.4.0/",
        "project/:@openzeppelin/contracts/=npm/@openzeppelin/contracts@5.4.0/",
        "project/:@openzeppelin/contracts/=npm/@openzeppelin/contracts@5.4.0/",
        "project/:@openzeppelin/contracts/=npm/@openzeppelin/contracts@5.4.0/",
        "project/:@scroll-tech/contracts/=npm/@scroll-tech/contracts@2.0.1/",
        "project/:@scroll-tech/contracts/=npm/@scroll-tech/contracts@2.0.1/",
        "project/:@zk-kit/lazy-imt.sol/=npm/@zk-kit/lazy-imt.sol@2.0.0-beta.12/",
        "project/:@zk-kit/lazy-imt.sol/=npm/@zk-kit/lazy-imt.sol@2.0.0-beta.12/",
        "project/:poseidon-solidity/=npm/poseidon-solidity@0.0.5/",
        "project/:poseidon-solidity/=npm/poseidon-solidity@0.0.5/"
      ]
    },
    "sources": {
      "npm/@openzeppelin/contracts@5.4.0/interfaces/draft-IERC6093.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.4.0) (interfaces/draft-IERC6093.sol)\npragma solidity >=0.8.4;\n\n/**\n * @dev Standard ERC-20 Errors\n * Interface of the https://eips.ethereum.org/EIPS/eip-6093[ERC-6093] custom errors for ERC-20 tokens.\n */\ninterface IERC20Errors {\n    /**\n     * @dev Indicates an error related to the current `balance` of a `sender`. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     * @param balance Current balance for the interacting account.\n     * @param needed Minimum amount required to perform a transfer.\n     */\n    error ERC20InsufficientBalance(address sender, uint256 balance, uint256 needed);\n\n    /**\n     * @dev Indicates a failure with the token `sender`. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     */\n    error ERC20InvalidSender(address sender);\n\n    /**\n     * @dev Indicates a failure with the token `receiver`. Used in transfers.\n     * @param receiver Address to which tokens are being transferred.\n     */\n    error ERC20InvalidReceiver(address receiver);\n\n    /**\n     * @dev Indicates a failure with the `spender`’s `allowance`. Used in transfers.\n     * @param spender Address that may be allowed to operate on tokens without being their owner.\n     * @param allowance Amount of tokens a `spender` is allowed to operate with.\n     * @param needed Minimum amount required to perform a transfer.\n     */\n    error ERC20InsufficientAllowance(address spender, uint256 allowance, uint256 needed);\n\n    /**\n     * @dev Indicates a failure with the `approver` of a token to be approved. Used in approvals.\n     * @param approver Address initiating an approval operation.\n     */\n    error ERC20InvalidApprover(address approver);\n\n    /**\n     * @dev Indicates a failure with the `spender` to be approved. Used in approvals.\n     * @param spender Address that may be allowed to operate on tokens without being their owner.\n     */\n    error ERC20InvalidSpender(address spender);\n}\n\n/**\n * @dev Standard ERC-721 Errors\n * Interface of the https://eips.ethereum.org/EIPS/eip-6093[ERC-6093] custom errors for ERC-721 tokens.\n */\ninterface IERC721Errors {\n    /**\n     * @dev Indicates that an address can't be an owner. For example, `address(0)` is a forbidden owner in ERC-20.\n     * Used in balance queries.\n     * @param owner Address of the current owner of a token.\n     */\n    error ERC721InvalidOwner(address owner);\n\n    /**\n     * @dev Indicates a `tokenId` whose `owner` is the zero address.\n     * @param tokenId Identifier number of a token.\n     */\n    error ERC721NonexistentToken(uint256 tokenId);\n\n    /**\n     * @dev Indicates an error related to the ownership over a particular token. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     * @param tokenId Identifier number of a token.\n     * @param owner Address of the current owner of a token.\n     */\n    error ERC721IncorrectOwner(address sender, uint256 tokenId, address owner);\n\n    /**\n     * @dev Indicates a failure with the token `sender`. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     */\n    error ERC721InvalidSender(address sender);\n\n    /**\n     * @dev Indicates a failure with the token `receiver`. Used in transfers.\n     * @param receiver Address to which tokens are being transferred.\n     */\n    error ERC721InvalidReceiver(address receiver);\n\n    /**\n     * @dev Indicates a failure with the `operator`’s approval. Used in transfers.\n     * @param operator Address that may be allowed to operate on tokens without being their owner.\n     * @param tokenId Identifier number of a token.\n     */\n    error ERC721InsufficientApproval(address operator, uint256 tokenId);\n\n    /**\n     * @dev Indicates a failure with the `approver` of a token to be approved. Used in approvals.\n     * @param approver Address initiating an approval operation.\n     */\n    error ERC721InvalidApprover(address approver);\n\n    /**\n     * @dev Indicates a failure with the `operator` to be approved. Used in approvals.\n     * @param operator Address that may be allowed to operate on tokens without being their owner.\n     */\n    error ERC721InvalidOperator(address operator);\n}\n\n/**\n * @dev Standard ERC-1155 Errors\n * Interface of the https://eips.ethereum.org/EIPS/eip-6093[ERC-6093] custom errors for ERC-1155 tokens.\n */\ninterface IERC1155Errors {\n    /**\n     * @dev Indicates an error related to the current `balance` of a `sender`. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     * @param balance Current balance for the interacting account.\n     * @param needed Minimum amount required to perform a transfer.\n     * @param tokenId Identifier number of a token.\n     */\n    error ERC1155InsufficientBalance(address sender, uint256 balance, uint256 needed, uint256 tokenId);\n\n    /**\n     * @dev Indicates a failure with the token `sender`. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     */\n    error ERC1155InvalidSender(address sender);\n\n    /**\n     * @dev Indicates a failure with the token `receiver`. Used in transfers.\n     * @param receiver Address to which tokens are being transferred.\n     */\n    error ERC1155InvalidReceiver(address receiver);\n\n    /**\n     * @dev Indicates a failure with the `operator`’s approval. Used in transfers.\n     * @param operator Address that may be allowed to operate on tokens without being their owner.\n     * @param owner Address of the current owner of a token.\n     */\n    error ERC1155MissingApprovalForAll(address operator, address owner);\n\n    /**\n     * @dev Indicates a failure with the `approver` of a token to be approved. Used in approvals.\n     * @param approver Address initiating an approval operation.\n     */\n    error ERC1155InvalidApprover(address approver);\n\n    /**\n     * @dev Indicates a failure with the `operator` to be approved. Used in approvals.\n     * @param operator Address that may be allowed to operate on tokens without being their owner.\n     */\n    error ERC1155InvalidOperator(address operator);\n\n    /**\n     * @dev Indicates an array length mismatch between ids and values in a safeBatchTransferFrom operation.\n     * Used in batch transfers.\n     * @param idsLength Length of the array of token identifiers\n     * @param valuesLength Length of the array of token amounts\n     */\n    error ERC1155InvalidArrayLength(uint256 idsLength, uint256 valuesLength);\n}\n"
      },
      "npm/@openzeppelin/contracts@5.4.0/interfaces/IERC1363.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.4.0) (interfaces/IERC1363.sol)\n\npragma solidity >=0.6.2;\n\nimport {IERC20} from \"./IERC20.sol\";\nimport {IERC165} from \"./IERC165.sol\";\n\n/**\n * @title IERC1363\n * @dev Interface of the ERC-1363 standard as defined in the https://eips.ethereum.org/EIPS/eip-1363[ERC-1363].\n *\n * Defines an extension interface for ERC-20 tokens that supports executing code on a recipient contract\n * after `transfer` or `transferFrom`, or code on a spender contract after `approve`, in a single transaction.\n */\ninterface IERC1363 is IERC20, IERC165 {\n    /*\n     * Note: the ERC-165 identifier for this interface is 0xb0202a11.\n     * 0xb0202a11 ===\n     *   bytes4(keccak256('transferAndCall(address,uint256)')) ^\n     *   bytes4(keccak256('transferAndCall(address,uint256,bytes)')) ^\n     *   bytes4(keccak256('transferFromAndCall(address,address,uint256)')) ^\n     *   bytes4(keccak256('transferFromAndCall(address,address,uint256,bytes)')) ^\n     *   bytes4(keccak256('approveAndCall(address,uint256)')) ^\n     *   bytes4(keccak256('approveAndCall(address,uint256,bytes)'))\n     */\n\n    /**\n     * @dev Moves a `value` amount of tokens from the caller's account to `to`\n     * and then calls {IERC1363Receiver-onTransferReceived} on `to`.\n     * @param to The address which you want to transfer to.\n     * @param value The amount of tokens to be transferred.\n     * @return A boolean value indicating whether the operation succeeded unless throwing.\n     */\n    function transferAndCall(address to, uint256 value) external returns (bool);\n\n    /**\n     * @dev Moves a `value` amount of tokens from the caller's account to `to`\n     * and then calls {IERC1363Receiver-onTransferReceived} on `to`.\n     * @param to The address which you want to transfer to.\n     * @param value The amount of tokens to be transferred.\n     * @param data Additional data with no specified format, sent in call to `to`.\n     * @return A boolean value indicating whether the operation succeeded unless throwing.\n     */\n    function transferAndCall(address to, uint256 value, bytes calldata data) external returns (bool);\n\n    /**\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the allowance mechanism\n     * and then calls {IERC1363Receiver-onTransferReceived} on `to`.\n     * @param from The address which you want to send tokens from.\n     * @param to The address which you want to transfer to.\n     * @param value The amount of tokens to be transferred.\n     * @return A boolean value indicating whether the operation succeeded unless throwing.\n     */\n    function transferFromAndCall(address from, address to, uint256 value) external returns (bool);\n\n    /**\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the allowance mechanism\n     * and then calls {IERC1363Receiver-onTransferReceived} on `to`.\n     * @param from The address which you want to send tokens from.\n     * @param to The address which you want to transfer to.\n     * @param value The amount of tokens to be transferred.\n     * @param data Additional data with no specified format, sent in call to `to`.\n     * @return A boolean value indicating whether the operation succeeded unless throwing.\n     */\n    function transferFromAndCall(address from, address to, uint256 value, bytes calldata data) external returns (bool);\n\n    /**\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\n     * caller's tokens and then calls {IERC1363Spender-onApprovalReceived} on `spender`.\n     * @param spender The address which will spend the funds.\n     * @param value The amount of tokens to be spent.\n     * @return A boolean value indicating whether the operation succeeded unless throwing.\n     */\n    function approveAndCall(address spender, uint256 value) external returns (bool);\n\n    /**\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\n     * caller's tokens and then calls {IERC1363Spender-onApprovalReceived} on `spender`.\n     * @param spender The address which will spend the funds.\n     * @param value The amount of tokens to be spent.\n     * @param data Additional data with no specified format, sent in call to `spender`.\n     * @return A boolean value indicating whether the operation succeeded unless throwing.\n     */\n    function approveAndCall(address spender, uint256 value, bytes calldata data) external returns (bool);\n}\n"
      },
      "npm/@openzeppelin/contracts@5.4.0/interfaces/IERC165.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.4.0) (interfaces/IERC165.sol)\n\npragma solidity >=0.4.16;\n\nimport {IERC165} from \"../utils/introspection/IERC165.sol\";\n"
      },
      "npm/@openzeppelin/contracts@5.4.0/interfaces/IERC20.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.4.0) (interfaces/IERC20.sol)\n\npragma solidity >=0.4.16;\n\nimport {IERC20} from \"../token/ERC20/IERC20.sol\";\n"
      },
      "npm/@openzeppelin/contracts@5.4.0/token/ERC20/ERC20.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.4.0) (token/ERC20/ERC20.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC20} from \"./IERC20.sol\";\nimport {IERC20Metadata} from \"./extensions/IERC20Metadata.sol\";\nimport {Context} from \"../../utils/Context.sol\";\nimport {IERC20Errors} from \"../../interfaces/draft-IERC6093.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.openzeppelin.com/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * The default value of {decimals} is 18. To change this, you should override\n * this function so it returns a different value.\n *\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\n * instead returning `false` on failure. This behavior is nonetheless\n * conventional and does not conflict with the expectations of ERC-20\n * applications.\n */\nabstract contract ERC20 is Context, IERC20, IERC20Metadata, IERC20Errors {\n    mapping(address account => uint256) private _balances;\n\n    mapping(address account => mapping(address spender => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}.\n     *\n     * Both values are immutable: they can only be set once during construction.\n     */\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the default value returned by this function, unless\n     * it's overridden.\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual returns (uint8) {\n        return 18;\n    }\n\n    /// @inheritdoc IERC20\n    function totalSupply() public view virtual returns (uint256) {\n        return _totalSupply;\n    }\n\n    /// @inheritdoc IERC20\n    function balanceOf(address account) public view virtual returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - the caller must have a balance of at least `value`.\n     */\n    function transfer(address to, uint256 value) public virtual returns (bool) {\n        address owner = _msgSender();\n        _transfer(owner, to, value);\n        return true;\n    }\n\n    /// @inheritdoc IERC20\n    function allowance(address owner, address spender) public view virtual returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * NOTE: If `value` is the maximum `uint256`, the allowance is not updated on\n     * `transferFrom`. This is semantically equivalent to an infinite approval.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 value) public virtual returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, value);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Skips emitting an {Approval} event indicating an allowance update. This is not\n     * required by the ERC. See {xref-ERC20-_approve-address-address-uint256-bool-}[_approve].\n     *\n     * NOTE: Does not update the allowance if the current allowance\n     * is the maximum `uint256`.\n     *\n     * Requirements:\n     *\n     * - `from` and `to` cannot be the zero address.\n     * - `from` must have a balance of at least `value`.\n     * - the caller must have allowance for ``from``'s tokens of at least\n     * `value`.\n     */\n    function transferFrom(address from, address to, uint256 value) public virtual returns (bool) {\n        address spender = _msgSender();\n        _spendAllowance(from, spender, value);\n        _transfer(from, to, value);\n        return true;\n    }\n\n    /**\n     * @dev Moves a `value` amount of tokens from `from` to `to`.\n     *\n     * This internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * NOTE: This function is not virtual, {_update} should be overridden instead.\n     */\n    function _transfer(address from, address to, uint256 value) internal {\n        if (from == address(0)) {\n            revert ERC20InvalidSender(address(0));\n        }\n        if (to == address(0)) {\n            revert ERC20InvalidReceiver(address(0));\n        }\n        _update(from, to, value);\n    }\n\n    /**\n     * @dev Transfers a `value` amount of tokens from `from` to `to`, or alternatively mints (or burns) if `from`\n     * (or `to`) is the zero address. All customizations to transfers, mints, and burns should be done by overriding\n     * this function.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _update(address from, address to, uint256 value) internal virtual {\n        if (from == address(0)) {\n            // Overflow check required: The rest of the code assumes that totalSupply never overflows\n            _totalSupply += value;\n        } else {\n            uint256 fromBalance = _balances[from];\n            if (fromBalance < value) {\n                revert ERC20InsufficientBalance(from, fromBalance, value);\n            }\n            unchecked {\n                // Overflow not possible: value <= fromBalance <= totalSupply.\n                _balances[from] = fromBalance - value;\n            }\n        }\n\n        if (to == address(0)) {\n            unchecked {\n                // Overflow not possible: value <= totalSupply or value <= fromBalance <= totalSupply.\n                _totalSupply -= value;\n            }\n        } else {\n            unchecked {\n                // Overflow not possible: balance + value is at most totalSupply, which we know fits into a uint256.\n                _balances[to] += value;\n            }\n        }\n\n        emit Transfer(from, to, value);\n    }\n\n    /**\n     * @dev Creates a `value` amount of tokens and assigns them to `account`, by transferring it from address(0).\n     * Relies on the `_update` mechanism\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * NOTE: This function is not virtual, {_update} should be overridden instead.\n     */\n    function _mint(address account, uint256 value) internal {\n        if (account == address(0)) {\n            revert ERC20InvalidReceiver(address(0));\n        }\n        _update(address(0), account, value);\n    }\n\n    /**\n     * @dev Destroys a `value` amount of tokens from `account`, lowering the total supply.\n     * Relies on the `_update` mechanism.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * NOTE: This function is not virtual, {_update} should be overridden instead\n     */\n    function _burn(address account, uint256 value) internal {\n        if (account == address(0)) {\n            revert ERC20InvalidSender(address(0));\n        }\n        _update(account, address(0), value);\n    }\n\n    /**\n     * @dev Sets `value` as the allowance of `spender` over the `owner`'s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     *\n     * Overrides to this logic should be done to the variant with an additional `bool emitEvent` argument.\n     */\n    function _approve(address owner, address spender, uint256 value) internal {\n        _approve(owner, spender, value, true);\n    }\n\n    /**\n     * @dev Variant of {_approve} with an optional flag to enable or disable the {Approval} event.\n     *\n     * By default (when calling {_approve}) the flag is set to true. On the other hand, approval changes made by\n     * `_spendAllowance` during the `transferFrom` operation set the flag to false. This saves gas by not emitting any\n     * `Approval` event during `transferFrom` operations.\n     *\n     * Anyone who wishes to continue emitting `Approval` events on the`transferFrom` operation can force the flag to\n     * true using the following override:\n     *\n     * ```solidity\n     * function _approve(address owner, address spender, uint256 value, bool) internal virtual override {\n     *     super._approve(owner, spender, value, true);\n     * }\n     * ```\n     *\n     * Requirements are the same as {_approve}.\n     */\n    function _approve(address owner, address spender, uint256 value, bool emitEvent) internal virtual {\n        if (owner == address(0)) {\n            revert ERC20InvalidApprover(address(0));\n        }\n        if (spender == address(0)) {\n            revert ERC20InvalidSpender(address(0));\n        }\n        _allowances[owner][spender] = value;\n        if (emitEvent) {\n            emit Approval(owner, spender, value);\n        }\n    }\n\n    /**\n     * @dev Updates `owner`'s allowance for `spender` based on spent `value`.\n     *\n     * Does not update the allowance value in case of infinite allowance.\n     * Revert if not enough allowance is available.\n     *\n     * Does not emit an {Approval} event.\n     */\n    function _spendAllowance(address owner, address spender, uint256 value) internal virtual {\n        uint256 currentAllowance = allowance(owner, spender);\n        if (currentAllowance < type(uint256).max) {\n            if (currentAllowance < value) {\n                revert ERC20InsufficientAllowance(spender, currentAllowance, value);\n            }\n            unchecked {\n                _approve(owner, spender, currentAllowance - value, false);\n            }\n        }\n    }\n}\n"
      },
      "npm/@openzeppelin/contracts@5.4.0/token/ERC20/extensions/IERC20Metadata.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.4.0) (token/ERC20/extensions/IERC20Metadata.sol)\n\npragma solidity >=0.6.2;\n\nimport {IERC20} from \"../IERC20.sol\";\n\n/**\n * @dev Interface for the optional metadata functions from the ERC-20 standard.\n */\ninterface IERC20Metadata is IERC20 {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n"
      },
      "npm/@openzeppelin/contracts@5.4.0/token/ERC20/IERC20.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.4.0) (token/ERC20/IERC20.sol)\n\npragma solidity >=0.4.16;\n\n/**\n * @dev Interface of the ERC-20 standard as defined in the ERC.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the value of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the value of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves a `value` amount of tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 value) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\n     * caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 value) external returns (bool);\n\n    /**\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the\n     * allowance mechanism. `value` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\n}\n"
      },
      "npm/@openzeppelin/contracts@5.4.0/token/ERC20/utils/SafeERC20.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.3.0) (token/ERC20/utils/SafeERC20.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC20} from \"../IERC20.sol\";\nimport {IERC1363} from \"../../../interfaces/IERC1363.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC-20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    /**\n     * @dev An operation with an ERC-20 token failed.\n     */\n    error SafeERC20FailedOperation(address token);\n\n    /**\n     * @dev Indicates a failed `decreaseAllowance` request.\n     */\n    error SafeERC20FailedDecreaseAllowance(address spender, uint256 currentAllowance, uint256 requestedDecrease);\n\n    /**\n     * @dev Transfer `value` amount of `token` from the calling contract to `to`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeCall(token.transfer, (to, value)));\n    }\n\n    /**\n     * @dev Transfer `value` amount of `token` from `from` to `to`, spending the approval given by `from` to the\n     * calling contract. If `token` returns no value, non-reverting calls are assumed to be successful.\n     */\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeCall(token.transferFrom, (from, to, value)));\n    }\n\n    /**\n     * @dev Variant of {safeTransfer} that returns a bool instead of reverting if the operation is not successful.\n     */\n    function trySafeTransfer(IERC20 token, address to, uint256 value) internal returns (bool) {\n        return _callOptionalReturnBool(token, abi.encodeCall(token.transfer, (to, value)));\n    }\n\n    /**\n     * @dev Variant of {safeTransferFrom} that returns a bool instead of reverting if the operation is not successful.\n     */\n    function trySafeTransferFrom(IERC20 token, address from, address to, uint256 value) internal returns (bool) {\n        return _callOptionalReturnBool(token, abi.encodeCall(token.transferFrom, (from, to, value)));\n    }\n\n    /**\n     * @dev Increase the calling contract's allowance toward `spender` by `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     *\n     * IMPORTANT: If the token implements ERC-7674 (ERC-20 with temporary allowance), and if the \"client\"\n     * smart contract uses ERC-7674 to set temporary allowances, then the \"client\" smart contract should avoid using\n     * this function. Performing a {safeIncreaseAllowance} or {safeDecreaseAllowance} operation on a token contract\n     * that has a non-zero temporary allowance (for that particular owner-spender) will result in unexpected behavior.\n     */\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 oldAllowance = token.allowance(address(this), spender);\n        forceApprove(token, spender, oldAllowance + value);\n    }\n\n    /**\n     * @dev Decrease the calling contract's allowance toward `spender` by `requestedDecrease`. If `token` returns no\n     * value, non-reverting calls are assumed to be successful.\n     *\n     * IMPORTANT: If the token implements ERC-7674 (ERC-20 with temporary allowance), and if the \"client\"\n     * smart contract uses ERC-7674 to set temporary allowances, then the \"client\" smart contract should avoid using\n     * this function. Performing a {safeIncreaseAllowance} or {safeDecreaseAllowance} operation on a token contract\n     * that has a non-zero temporary allowance (for that particular owner-spender) will result in unexpected behavior.\n     */\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 requestedDecrease) internal {\n        unchecked {\n            uint256 currentAllowance = token.allowance(address(this), spender);\n            if (currentAllowance < requestedDecrease) {\n                revert SafeERC20FailedDecreaseAllowance(spender, currentAllowance, requestedDecrease);\n            }\n            forceApprove(token, spender, currentAllowance - requestedDecrease);\n        }\n    }\n\n    /**\n     * @dev Set the calling contract's allowance toward `spender` to `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful. Meant to be used with tokens that require the approval\n     * to be set to zero before setting it to a non-zero value, such as USDT.\n     *\n     * NOTE: If the token implements ERC-7674, this function will not modify any temporary allowance. This function\n     * only sets the \"standard\" allowance. Any temporary allowance will remain active, in addition to the value being\n     * set here.\n     */\n    function forceApprove(IERC20 token, address spender, uint256 value) internal {\n        bytes memory approvalCall = abi.encodeCall(token.approve, (spender, value));\n\n        if (!_callOptionalReturnBool(token, approvalCall)) {\n            _callOptionalReturn(token, abi.encodeCall(token.approve, (spender, 0)));\n            _callOptionalReturn(token, approvalCall);\n        }\n    }\n\n    /**\n     * @dev Performs an {ERC1363} transferAndCall, with a fallback to the simple {ERC20} transfer if the target has no\n     * code. This can be used to implement an {ERC721}-like safe transfer that rely on {ERC1363} checks when\n     * targeting contracts.\n     *\n     * Reverts if the returned value is other than `true`.\n     */\n    function transferAndCallRelaxed(IERC1363 token, address to, uint256 value, bytes memory data) internal {\n        if (to.code.length == 0) {\n            safeTransfer(token, to, value);\n        } else if (!token.transferAndCall(to, value, data)) {\n            revert SafeERC20FailedOperation(address(token));\n        }\n    }\n\n    /**\n     * @dev Performs an {ERC1363} transferFromAndCall, with a fallback to the simple {ERC20} transferFrom if the target\n     * has no code. This can be used to implement an {ERC721}-like safe transfer that rely on {ERC1363} checks when\n     * targeting contracts.\n     *\n     * Reverts if the returned value is other than `true`.\n     */\n    function transferFromAndCallRelaxed(\n        IERC1363 token,\n        address from,\n        address to,\n        uint256 value,\n        bytes memory data\n    ) internal {\n        if (to.code.length == 0) {\n            safeTransferFrom(token, from, to, value);\n        } else if (!token.transferFromAndCall(from, to, value, data)) {\n            revert SafeERC20FailedOperation(address(token));\n        }\n    }\n\n    /**\n     * @dev Performs an {ERC1363} approveAndCall, with a fallback to the simple {ERC20} approve if the target has no\n     * code. This can be used to implement an {ERC721}-like safe transfer that rely on {ERC1363} checks when\n     * targeting contracts.\n     *\n     * NOTE: When the recipient address (`to`) has no code (i.e. is an EOA), this function behaves as {forceApprove}.\n     * Opposedly, when the recipient address (`to`) has code, this function only attempts to call {ERC1363-approveAndCall}\n     * once without retrying, and relies on the returned value to be true.\n     *\n     * Reverts if the returned value is other than `true`.\n     */\n    function approveAndCallRelaxed(IERC1363 token, address to, uint256 value, bytes memory data) internal {\n        if (to.code.length == 0) {\n            forceApprove(token, to, value);\n        } else if (!token.approveAndCall(to, value, data)) {\n            revert SafeERC20FailedOperation(address(token));\n        }\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     *\n     * This is a variant of {_callOptionalReturnBool} that reverts if call fails to meet the requirements.\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        uint256 returnSize;\n        uint256 returnValue;\n        assembly (\"memory-safe\") {\n            let success := call(gas(), token, 0, add(data, 0x20), mload(data), 0, 0x20)\n            // bubble errors\n            if iszero(success) {\n                let ptr := mload(0x40)\n                returndatacopy(ptr, 0, returndatasize())\n                revert(ptr, returndatasize())\n            }\n            returnSize := returndatasize()\n            returnValue := mload(0)\n        }\n\n        if (returnSize == 0 ? address(token).code.length == 0 : returnValue != 1) {\n            revert SafeERC20FailedOperation(address(token));\n        }\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     *\n     * This is a variant of {_callOptionalReturn} that silently catches all reverts and returns a bool instead.\n     */\n    function _callOptionalReturnBool(IERC20 token, bytes memory data) private returns (bool) {\n        bool success;\n        uint256 returnSize;\n        uint256 returnValue;\n        assembly (\"memory-safe\") {\n            success := call(gas(), token, 0, add(data, 0x20), mload(data), 0, 0x20)\n            returnSize := returndatasize()\n            returnValue := mload(0)\n        }\n        return success && (returnSize == 0 ? address(token).code.length > 0 : returnValue == 1);\n    }\n}\n"
      },
      "npm/@openzeppelin/contracts@5.4.0/utils/Arrays.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.4.0) (utils/Arrays.sol)\n// This file was procedurally generated from scripts/generate/templates/Arrays.js.\n\npragma solidity ^0.8.20;\n\nimport {Comparators} from \"./Comparators.sol\";\nimport {SlotDerivation} from \"./SlotDerivation.sol\";\nimport {StorageSlot} from \"./StorageSlot.sol\";\nimport {Math} from \"./math/Math.sol\";\n\n/**\n * @dev Collection of functions related to array types.\n */\nlibrary Arrays {\n    using SlotDerivation for bytes32;\n    using StorageSlot for bytes32;\n\n    /**\n     * @dev Sort an array of uint256 (in memory) following the provided comparator function.\n     *\n     * This function does the sorting \"in place\", meaning that it overrides the input. The object is returned for\n     * convenience, but that returned value can be discarded safely if the caller has a memory pointer to the array.\n     *\n     * NOTE: this function's cost is `O(n · log(n))` in average and `O(n²)` in the worst case, with n the length of the\n     * array. Using it in view functions that are executed through `eth_call` is safe, but one should be very careful\n     * when executing this as part of a transaction. If the array being sorted is too large, the sort operation may\n     * consume more gas than is available in a block, leading to potential DoS.\n     *\n     * IMPORTANT: Consider memory side-effects when using custom comparator functions that access memory in an unsafe way.\n     */\n    function sort(\n        uint256[] memory array,\n        function(uint256, uint256) pure returns (bool) comp\n    ) internal pure returns (uint256[] memory) {\n        _quickSort(_begin(array), _end(array), comp);\n        return array;\n    }\n\n    /**\n     * @dev Variant of {sort} that sorts an array of uint256 in increasing order.\n     */\n    function sort(uint256[] memory array) internal pure returns (uint256[] memory) {\n        sort(array, Comparators.lt);\n        return array;\n    }\n\n    /**\n     * @dev Sort an array of address (in memory) following the provided comparator function.\n     *\n     * This function does the sorting \"in place\", meaning that it overrides the input. The object is returned for\n     * convenience, but that returned value can be discarded safely if the caller has a memory pointer to the array.\n     *\n     * NOTE: this function's cost is `O(n · log(n))` in average and `O(n²)` in the worst case, with n the length of the\n     * array. Using it in view functions that are executed through `eth_call` is safe, but one should be very careful\n     * when executing this as part of a transaction. If the array being sorted is too large, the sort operation may\n     * consume more gas than is available in a block, leading to potential DoS.\n     *\n     * IMPORTANT: Consider memory side-effects when using custom comparator functions that access memory in an unsafe way.\n     */\n    function sort(\n        address[] memory array,\n        function(address, address) pure returns (bool) comp\n    ) internal pure returns (address[] memory) {\n        sort(_castToUint256Array(array), _castToUint256Comp(comp));\n        return array;\n    }\n\n    /**\n     * @dev Variant of {sort} that sorts an array of address in increasing order.\n     */\n    function sort(address[] memory array) internal pure returns (address[] memory) {\n        sort(_castToUint256Array(array), Comparators.lt);\n        return array;\n    }\n\n    /**\n     * @dev Sort an array of bytes32 (in memory) following the provided comparator function.\n     *\n     * This function does the sorting \"in place\", meaning that it overrides the input. The object is returned for\n     * convenience, but that returned value can be discarded safely if the caller has a memory pointer to the array.\n     *\n     * NOTE: this function's cost is `O(n · log(n))` in average and `O(n²)` in the worst case, with n the length of the\n     * array. Using it in view functions that are executed through `eth_call` is safe, but one should be very careful\n     * when executing this as part of a transaction. If the array being sorted is too large, the sort operation may\n     * consume more gas than is available in a block, leading to potential DoS.\n     *\n     * IMPORTANT: Consider memory side-effects when using custom comparator functions that access memory in an unsafe way.\n     */\n    function sort(\n        bytes32[] memory array,\n        function(bytes32, bytes32) pure returns (bool) comp\n    ) internal pure returns (bytes32[] memory) {\n        sort(_castToUint256Array(array), _castToUint256Comp(comp));\n        return array;\n    }\n\n    /**\n     * @dev Variant of {sort} that sorts an array of bytes32 in increasing order.\n     */\n    function sort(bytes32[] memory array) internal pure returns (bytes32[] memory) {\n        sort(_castToUint256Array(array), Comparators.lt);\n        return array;\n    }\n\n    /**\n     * @dev Performs a quick sort of a segment of memory. The segment sorted starts at `begin` (inclusive), and stops\n     * at end (exclusive). Sorting follows the `comp` comparator.\n     *\n     * Invariant: `begin <= end`. This is the case when initially called by {sort} and is preserved in subcalls.\n     *\n     * IMPORTANT: Memory locations between `begin` and `end` are not validated/zeroed. This function should\n     * be used only if the limits are within a memory array.\n     */\n    function _quickSort(uint256 begin, uint256 end, function(uint256, uint256) pure returns (bool) comp) private pure {\n        unchecked {\n            if (end - begin < 0x40) return;\n\n            // Use first element as pivot\n            uint256 pivot = _mload(begin);\n            // Position where the pivot should be at the end of the loop\n            uint256 pos = begin;\n\n            for (uint256 it = begin + 0x20; it < end; it += 0x20) {\n                if (comp(_mload(it), pivot)) {\n                    // If the value stored at the iterator's position comes before the pivot, we increment the\n                    // position of the pivot and move the value there.\n                    pos += 0x20;\n                    _swap(pos, it);\n                }\n            }\n\n            _swap(begin, pos); // Swap pivot into place\n            _quickSort(begin, pos, comp); // Sort the left side of the pivot\n            _quickSort(pos + 0x20, end, comp); // Sort the right side of the pivot\n        }\n    }\n\n    /**\n     * @dev Pointer to the memory location of the first element of `array`.\n     */\n    function _begin(uint256[] memory array) private pure returns (uint256 ptr) {\n        assembly (\"memory-safe\") {\n            ptr := add(array, 0x20)\n        }\n    }\n\n    /**\n     * @dev Pointer to the memory location of the first memory word (32bytes) after `array`. This is the memory word\n     * that comes just after the last element of the array.\n     */\n    function _end(uint256[] memory array) private pure returns (uint256 ptr) {\n        unchecked {\n            return _begin(array) + array.length * 0x20;\n        }\n    }\n\n    /**\n     * @dev Load memory word (as a uint256) at location `ptr`.\n     */\n    function _mload(uint256 ptr) private pure returns (uint256 value) {\n        assembly {\n            value := mload(ptr)\n        }\n    }\n\n    /**\n     * @dev Swaps the elements memory location `ptr1` and `ptr2`.\n     */\n    function _swap(uint256 ptr1, uint256 ptr2) private pure {\n        assembly {\n            let value1 := mload(ptr1)\n            let value2 := mload(ptr2)\n            mstore(ptr1, value2)\n            mstore(ptr2, value1)\n        }\n    }\n\n    /// @dev Helper: low level cast address memory array to uint256 memory array\n    function _castToUint256Array(address[] memory input) private pure returns (uint256[] memory output) {\n        assembly {\n            output := input\n        }\n    }\n\n    /// @dev Helper: low level cast bytes32 memory array to uint256 memory array\n    function _castToUint256Array(bytes32[] memory input) private pure returns (uint256[] memory output) {\n        assembly {\n            output := input\n        }\n    }\n\n    /// @dev Helper: low level cast address comp function to uint256 comp function\n    function _castToUint256Comp(\n        function(address, address) pure returns (bool) input\n    ) private pure returns (function(uint256, uint256) pure returns (bool) output) {\n        assembly {\n            output := input\n        }\n    }\n\n    /// @dev Helper: low level cast bytes32 comp function to uint256 comp function\n    function _castToUint256Comp(\n        function(bytes32, bytes32) pure returns (bool) input\n    ) private pure returns (function(uint256, uint256) pure returns (bool) output) {\n        assembly {\n            output := input\n        }\n    }\n\n    /**\n     * @dev Searches a sorted `array` and returns the first index that contains\n     * a value greater or equal to `element`. If no such index exists (i.e. all\n     * values in the array are strictly less than `element`), the array length is\n     * returned. Time complexity O(log n).\n     *\n     * NOTE: The `array` is expected to be sorted in ascending order, and to\n     * contain no repeated elements.\n     *\n     * IMPORTANT: Deprecated. This implementation behaves as {lowerBound} but lacks\n     * support for repeated elements in the array. The {lowerBound} function should\n     * be used instead.\n     */\n    function findUpperBound(uint256[] storage array, uint256 element) internal view returns (uint256) {\n        uint256 low = 0;\n        uint256 high = array.length;\n\n        if (high == 0) {\n            return 0;\n        }\n\n        while (low < high) {\n            uint256 mid = Math.average(low, high);\n\n            // Note that mid will always be strictly less than high (i.e. it will be a valid array index)\n            // because Math.average rounds towards zero (it does integer division with truncation).\n            if (unsafeAccess(array, mid).value > element) {\n                high = mid;\n            } else {\n                low = mid + 1;\n            }\n        }\n\n        // At this point `low` is the exclusive upper bound. We will return the inclusive upper bound.\n        if (low > 0 && unsafeAccess(array, low - 1).value == element) {\n            return low - 1;\n        } else {\n            return low;\n        }\n    }\n\n    /**\n     * @dev Searches an `array` sorted in ascending order and returns the first\n     * index that contains a value greater or equal than `element`. If no such index\n     * exists (i.e. all values in the array are strictly less than `element`), the array\n     * length is returned. Time complexity O(log n).\n     *\n     * See C++'s https://en.cppreference.com/w/cpp/algorithm/lower_bound[lower_bound].\n     */\n    function lowerBound(uint256[] storage array, uint256 element) internal view returns (uint256) {\n        uint256 low = 0;\n        uint256 high = array.length;\n\n        if (high == 0) {\n            return 0;\n        }\n\n        while (low < high) {\n            uint256 mid = Math.average(low, high);\n\n            // Note that mid will always be strictly less than high (i.e. it will be a valid array index)\n            // because Math.average rounds towards zero (it does integer division with truncation).\n            if (unsafeAccess(array, mid).value < element) {\n                // this cannot overflow because mid < high\n                unchecked {\n                    low = mid + 1;\n                }\n            } else {\n                high = mid;\n            }\n        }\n\n        return low;\n    }\n\n    /**\n     * @dev Searches an `array` sorted in ascending order and returns the first\n     * index that contains a value strictly greater than `element`. If no such index\n     * exists (i.e. all values in the array are strictly less than `element`), the array\n     * length is returned. Time complexity O(log n).\n     *\n     * See C++'s https://en.cppreference.com/w/cpp/algorithm/upper_bound[upper_bound].\n     */\n    function upperBound(uint256[] storage array, uint256 element) internal view returns (uint256) {\n        uint256 low = 0;\n        uint256 high = array.length;\n\n        if (high == 0) {\n            return 0;\n        }\n\n        while (low < high) {\n            uint256 mid = Math.average(low, high);\n\n            // Note that mid will always be strictly less than high (i.e. it will be a valid array index)\n            // because Math.average rounds towards zero (it does integer division with truncation).\n            if (unsafeAccess(array, mid).value > element) {\n                high = mid;\n            } else {\n                // this cannot overflow because mid < high\n                unchecked {\n                    low = mid + 1;\n                }\n            }\n        }\n\n        return low;\n    }\n\n    /**\n     * @dev Same as {lowerBound}, but with an array in memory.\n     */\n    function lowerBoundMemory(uint256[] memory array, uint256 element) internal pure returns (uint256) {\n        uint256 low = 0;\n        uint256 high = array.length;\n\n        if (high == 0) {\n            return 0;\n        }\n\n        while (low < high) {\n            uint256 mid = Math.average(low, high);\n\n            // Note that mid will always be strictly less than high (i.e. it will be a valid array index)\n            // because Math.average rounds towards zero (it does integer division with truncation).\n            if (unsafeMemoryAccess(array, mid) < element) {\n                // this cannot overflow because mid < high\n                unchecked {\n                    low = mid + 1;\n                }\n            } else {\n                high = mid;\n            }\n        }\n\n        return low;\n    }\n\n    /**\n     * @dev Same as {upperBound}, but with an array in memory.\n     */\n    function upperBoundMemory(uint256[] memory array, uint256 element) internal pure returns (uint256) {\n        uint256 low = 0;\n        uint256 high = array.length;\n\n        if (high == 0) {\n            return 0;\n        }\n\n        while (low < high) {\n            uint256 mid = Math.average(low, high);\n\n            // Note that mid will always be strictly less than high (i.e. it will be a valid array index)\n            // because Math.average rounds towards zero (it does integer division with truncation).\n            if (unsafeMemoryAccess(array, mid) > element) {\n                high = mid;\n            } else {\n                // this cannot overflow because mid < high\n                unchecked {\n                    low = mid + 1;\n                }\n            }\n        }\n\n        return low;\n    }\n\n    /**\n     * @dev Access an array in an \"unsafe\" way. Skips solidity \"index-out-of-range\" check.\n     *\n     * WARNING: Only use if you are certain `pos` is lower than the array length.\n     */\n    function unsafeAccess(address[] storage arr, uint256 pos) internal pure returns (StorageSlot.AddressSlot storage) {\n        bytes32 slot;\n        assembly (\"memory-safe\") {\n            slot := arr.slot\n        }\n        return slot.deriveArray().offset(pos).getAddressSlot();\n    }\n\n    /**\n     * @dev Access an array in an \"unsafe\" way. Skips solidity \"index-out-of-range\" check.\n     *\n     * WARNING: Only use if you are certain `pos` is lower than the array length.\n     */\n    function unsafeAccess(bytes32[] storage arr, uint256 pos) internal pure returns (StorageSlot.Bytes32Slot storage) {\n        bytes32 slot;\n        assembly (\"memory-safe\") {\n            slot := arr.slot\n        }\n        return slot.deriveArray().offset(pos).getBytes32Slot();\n    }\n\n    /**\n     * @dev Access an array in an \"unsafe\" way. Skips solidity \"index-out-of-range\" check.\n     *\n     * WARNING: Only use if you are certain `pos` is lower than the array length.\n     */\n    function unsafeAccess(uint256[] storage arr, uint256 pos) internal pure returns (StorageSlot.Uint256Slot storage) {\n        bytes32 slot;\n        assembly (\"memory-safe\") {\n            slot := arr.slot\n        }\n        return slot.deriveArray().offset(pos).getUint256Slot();\n    }\n\n    /**\n     * @dev Access an array in an \"unsafe\" way. Skips solidity \"index-out-of-range\" check.\n     *\n     * WARNING: Only use if you are certain `pos` is lower than the array length.\n     */\n    function unsafeAccess(bytes[] storage arr, uint256 pos) internal pure returns (StorageSlot.BytesSlot storage) {\n        bytes32 slot;\n        assembly (\"memory-safe\") {\n            slot := arr.slot\n        }\n        return slot.deriveArray().offset(pos).getBytesSlot();\n    }\n\n    /**\n     * @dev Access an array in an \"unsafe\" way. Skips solidity \"index-out-of-range\" check.\n     *\n     * WARNING: Only use if you are certain `pos` is lower than the array length.\n     */\n    function unsafeAccess(string[] storage arr, uint256 pos) internal pure returns (StorageSlot.StringSlot storage) {\n        bytes32 slot;\n        assembly (\"memory-safe\") {\n            slot := arr.slot\n        }\n        return slot.deriveArray().offset(pos).getStringSlot();\n    }\n\n    /**\n     * @dev Access an array in an \"unsafe\" way. Skips solidity \"index-out-of-range\" check.\n     *\n     * WARNING: Only use if you are certain `pos` is lower than the array length.\n     */\n    function unsafeMemoryAccess(address[] memory arr, uint256 pos) internal pure returns (address res) {\n        assembly {\n            res := mload(add(add(arr, 0x20), mul(pos, 0x20)))\n        }\n    }\n\n    /**\n     * @dev Access an array in an \"unsafe\" way. Skips solidity \"index-out-of-range\" check.\n     *\n     * WARNING: Only use if you are certain `pos` is lower than the array length.\n     */\n    function unsafeMemoryAccess(bytes32[] memory arr, uint256 pos) internal pure returns (bytes32 res) {\n        assembly {\n            res := mload(add(add(arr, 0x20), mul(pos, 0x20)))\n        }\n    }\n\n    /**\n     * @dev Access an array in an \"unsafe\" way. Skips solidity \"index-out-of-range\" check.\n     *\n     * WARNING: Only use if you are certain `pos` is lower than the array length.\n     */\n    function unsafeMemoryAccess(uint256[] memory arr, uint256 pos) internal pure returns (uint256 res) {\n        assembly {\n            res := mload(add(add(arr, 0x20), mul(pos, 0x20)))\n        }\n    }\n\n    /**\n     * @dev Access an array in an \"unsafe\" way. Skips solidity \"index-out-of-range\" check.\n     *\n     * WARNING: Only use if you are certain `pos` is lower than the array length.\n     */\n    function unsafeMemoryAccess(bytes[] memory arr, uint256 pos) internal pure returns (bytes memory res) {\n        assembly {\n            res := mload(add(add(arr, 0x20), mul(pos, 0x20)))\n        }\n    }\n\n    /**\n     * @dev Access an array in an \"unsafe\" way. Skips solidity \"index-out-of-range\" check.\n     *\n     * WARNING: Only use if you are certain `pos` is lower than the array length.\n     */\n    function unsafeMemoryAccess(string[] memory arr, uint256 pos) internal pure returns (string memory res) {\n        assembly {\n            res := mload(add(add(arr, 0x20), mul(pos, 0x20)))\n        }\n    }\n\n    /**\n     * @dev Helper to set the length of a dynamic array. Directly writing to `.length` is forbidden.\n     *\n     * WARNING: this does not clear elements if length is reduced, of initialize elements if length is increased.\n     */\n    function unsafeSetLength(address[] storage array, uint256 len) internal {\n        assembly (\"memory-safe\") {\n            sstore(array.slot, len)\n        }\n    }\n\n    /**\n     * @dev Helper to set the length of a dynamic array. Directly writing to `.length` is forbidden.\n     *\n     * WARNING: this does not clear elements if length is reduced, of initialize elements if length is increased.\n     */\n    function unsafeSetLength(bytes32[] storage array, uint256 len) internal {\n        assembly (\"memory-safe\") {\n            sstore(array.slot, len)\n        }\n    }\n\n    /**\n     * @dev Helper to set the length of a dynamic array. Directly writing to `.length` is forbidden.\n     *\n     * WARNING: this does not clear elements if length is reduced, of initialize elements if length is increased.\n     */\n    function unsafeSetLength(uint256[] storage array, uint256 len) internal {\n        assembly (\"memory-safe\") {\n            sstore(array.slot, len)\n        }\n    }\n\n    /**\n     * @dev Helper to set the length of a dynamic array. Directly writing to `.length` is forbidden.\n     *\n     * WARNING: this does not clear elements if length is reduced, of initialize elements if length is increased.\n     */\n    function unsafeSetLength(bytes[] storage array, uint256 len) internal {\n        assembly (\"memory-safe\") {\n            sstore(array.slot, len)\n        }\n    }\n\n    /**\n     * @dev Helper to set the length of a dynamic array. Directly writing to `.length` is forbidden.\n     *\n     * WARNING: this does not clear elements if length is reduced, of initialize elements if length is increased.\n     */\n    function unsafeSetLength(string[] storage array, uint256 len) internal {\n        assembly (\"memory-safe\") {\n            sstore(array.slot, len)\n        }\n    }\n}\n"
      },
      "npm/@openzeppelin/contracts@5.4.0/utils/Comparators.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (utils/Comparators.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Provides a set of functions to compare values.\n *\n * _Available since v5.1._\n */\nlibrary Comparators {\n    function lt(uint256 a, uint256 b) internal pure returns (bool) {\n        return a < b;\n    }\n\n    function gt(uint256 a, uint256 b) internal pure returns (bool) {\n        return a > b;\n    }\n}\n"
      },
      "npm/@openzeppelin/contracts@5.4.0/utils/Context.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.1) (utils/Context.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    function _contextSuffixLength() internal view virtual returns (uint256) {\n        return 0;\n    }\n}\n"
      },
      "npm/@openzeppelin/contracts@5.4.0/utils/cryptography/MessageHashUtils.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.3.0) (utils/cryptography/MessageHashUtils.sol)\n\npragma solidity ^0.8.20;\n\nimport {Strings} from \"../Strings.sol\";\n\n/**\n * @dev Signature message hash utilities for producing digests to be consumed by {ECDSA} recovery or signing.\n *\n * The library provides methods for generating a hash of a message that conforms to the\n * https://eips.ethereum.org/EIPS/eip-191[ERC-191] and https://eips.ethereum.org/EIPS/eip-712[EIP 712]\n * specifications.\n */\nlibrary MessageHashUtils {\n    /**\n     * @dev Returns the keccak256 digest of an ERC-191 signed data with version\n     * `0x45` (`personal_sign` messages).\n     *\n     * The digest is calculated by prefixing a bytes32 `messageHash` with\n     * `\"\\x19Ethereum Signed Message:\\n32\"` and hashing the result. It corresponds with the\n     * hash signed when using the https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_sign[`eth_sign`] JSON-RPC method.\n     *\n     * NOTE: The `messageHash` parameter is intended to be the result of hashing a raw message with\n     * keccak256, although any bytes32 value can be safely used because the final digest will\n     * be re-hashed.\n     *\n     * See {ECDSA-recover}.\n     */\n    function toEthSignedMessageHash(bytes32 messageHash) internal pure returns (bytes32 digest) {\n        assembly (\"memory-safe\") {\n            mstore(0x00, \"\\x19Ethereum Signed Message:\\n32\") // 32 is the bytes-length of messageHash\n            mstore(0x1c, messageHash) // 0x1c (28) is the length of the prefix\n            digest := keccak256(0x00, 0x3c) // 0x3c is the length of the prefix (0x1c) + messageHash (0x20)\n        }\n    }\n\n    /**\n     * @dev Returns the keccak256 digest of an ERC-191 signed data with version\n     * `0x45` (`personal_sign` messages).\n     *\n     * The digest is calculated by prefixing an arbitrary `message` with\n     * `\"\\x19Ethereum Signed Message:\\n\" + len(message)` and hashing the result. It corresponds with the\n     * hash signed when using the https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_sign[`eth_sign`] JSON-RPC method.\n     *\n     * See {ECDSA-recover}.\n     */\n    function toEthSignedMessageHash(bytes memory message) internal pure returns (bytes32) {\n        return\n            keccak256(bytes.concat(\"\\x19Ethereum Signed Message:\\n\", bytes(Strings.toString(message.length)), message));\n    }\n\n    /**\n     * @dev Returns the keccak256 digest of an ERC-191 signed data with version\n     * `0x00` (data with intended validator).\n     *\n     * The digest is calculated by prefixing an arbitrary `data` with `\"\\x19\\x00\"` and the intended\n     * `validator` address. Then hashing the result.\n     *\n     * See {ECDSA-recover}.\n     */\n    function toDataWithIntendedValidatorHash(address validator, bytes memory data) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(hex\"19_00\", validator, data));\n    }\n\n    /**\n     * @dev Variant of {toDataWithIntendedValidatorHash-address-bytes} optimized for cases where `data` is a bytes32.\n     */\n    function toDataWithIntendedValidatorHash(\n        address validator,\n        bytes32 messageHash\n    ) internal pure returns (bytes32 digest) {\n        assembly (\"memory-safe\") {\n            mstore(0x00, hex\"19_00\")\n            mstore(0x02, shl(96, validator))\n            mstore(0x16, messageHash)\n            digest := keccak256(0x00, 0x36)\n        }\n    }\n\n    /**\n     * @dev Returns the keccak256 digest of an EIP-712 typed data (ERC-191 version `0x01`).\n     *\n     * The digest is calculated from a `domainSeparator` and a `structHash`, by prefixing them with\n     * `\\x19\\x01` and hashing the result. It corresponds to the hash signed by the\n     * https://eips.ethereum.org/EIPS/eip-712[`eth_signTypedData`] JSON-RPC method as part of EIP-712.\n     *\n     * See {ECDSA-recover}.\n     */\n    function toTypedDataHash(bytes32 domainSeparator, bytes32 structHash) internal pure returns (bytes32 digest) {\n        assembly (\"memory-safe\") {\n            let ptr := mload(0x40)\n            mstore(ptr, hex\"19_01\")\n            mstore(add(ptr, 0x02), domainSeparator)\n            mstore(add(ptr, 0x22), structHash)\n            digest := keccak256(ptr, 0x42)\n        }\n    }\n}\n"
      },
      "npm/@openzeppelin/contracts@5.4.0/utils/introspection/IERC165.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.4.0) (utils/introspection/IERC165.sol)\n\npragma solidity >=0.4.16;\n\n/**\n * @dev Interface of the ERC-165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[ERC].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[ERC section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
      },
      "npm/@openzeppelin/contracts@5.4.0/utils/math/Math.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.3.0) (utils/math/Math.sol)\n\npragma solidity ^0.8.20;\n\nimport {Panic} from \"../Panic.sol\";\nimport {SafeCast} from \"./SafeCast.sol\";\n\n/**\n * @dev Standard math utilities missing in the Solidity language.\n */\nlibrary Math {\n    enum Rounding {\n        Floor, // Toward negative infinity\n        Ceil, // Toward positive infinity\n        Trunc, // Toward zero\n        Expand // Away from zero\n    }\n\n    /**\n     * @dev Return the 512-bit addition of two uint256.\n     *\n     * The result is stored in two 256 variables such that sum = high * 2²⁵⁶ + low.\n     */\n    function add512(uint256 a, uint256 b) internal pure returns (uint256 high, uint256 low) {\n        assembly (\"memory-safe\") {\n            low := add(a, b)\n            high := lt(low, a)\n        }\n    }\n\n    /**\n     * @dev Return the 512-bit multiplication of two uint256.\n     *\n     * The result is stored in two 256 variables such that product = high * 2²⁵⁶ + low.\n     */\n    function mul512(uint256 a, uint256 b) internal pure returns (uint256 high, uint256 low) {\n        // 512-bit multiply [high low] = x * y. Compute the product mod 2²⁵⁶ and mod 2²⁵⁶ - 1, then use\n        // the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\n        // variables such that product = high * 2²⁵⁶ + low.\n        assembly (\"memory-safe\") {\n            let mm := mulmod(a, b, not(0))\n            low := mul(a, b)\n            high := sub(sub(mm, low), lt(mm, low))\n        }\n    }\n\n    /**\n     * @dev Returns the addition of two unsigned integers, with a success flag (no overflow).\n     */\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool success, uint256 result) {\n        unchecked {\n            uint256 c = a + b;\n            success = c >= a;\n            result = c * SafeCast.toUint(success);\n        }\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, with a success flag (no overflow).\n     */\n    function trySub(uint256 a, uint256 b) internal pure returns (bool success, uint256 result) {\n        unchecked {\n            uint256 c = a - b;\n            success = c <= a;\n            result = c * SafeCast.toUint(success);\n        }\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, with a success flag (no overflow).\n     */\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool success, uint256 result) {\n        unchecked {\n            uint256 c = a * b;\n            assembly (\"memory-safe\") {\n                // Only true when the multiplication doesn't overflow\n                // (c / a == b) || (a == 0)\n                success := or(eq(div(c, a), b), iszero(a))\n            }\n            // equivalent to: success ? c : 0\n            result = c * SafeCast.toUint(success);\n        }\n    }\n\n    /**\n     * @dev Returns the division of two unsigned integers, with a success flag (no division by zero).\n     */\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool success, uint256 result) {\n        unchecked {\n            success = b > 0;\n            assembly (\"memory-safe\") {\n                // The `DIV` opcode returns zero when the denominator is 0.\n                result := div(a, b)\n            }\n        }\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers, with a success flag (no division by zero).\n     */\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool success, uint256 result) {\n        unchecked {\n            success = b > 0;\n            assembly (\"memory-safe\") {\n                // The `MOD` opcode returns zero when the denominator is 0.\n                result := mod(a, b)\n            }\n        }\n    }\n\n    /**\n     * @dev Unsigned saturating addition, bounds to `2²⁵⁶ - 1` instead of overflowing.\n     */\n    function saturatingAdd(uint256 a, uint256 b) internal pure returns (uint256) {\n        (bool success, uint256 result) = tryAdd(a, b);\n        return ternary(success, result, type(uint256).max);\n    }\n\n    /**\n     * @dev Unsigned saturating subtraction, bounds to zero instead of overflowing.\n     */\n    function saturatingSub(uint256 a, uint256 b) internal pure returns (uint256) {\n        (, uint256 result) = trySub(a, b);\n        return result;\n    }\n\n    /**\n     * @dev Unsigned saturating multiplication, bounds to `2²⁵⁶ - 1` instead of overflowing.\n     */\n    function saturatingMul(uint256 a, uint256 b) internal pure returns (uint256) {\n        (bool success, uint256 result) = tryMul(a, b);\n        return ternary(success, result, type(uint256).max);\n    }\n\n    /**\n     * @dev Branchless ternary evaluation for `a ? b : c`. Gas costs are constant.\n     *\n     * IMPORTANT: This function may reduce bytecode size and consume less gas when used standalone.\n     * However, the compiler may optimize Solidity ternary operations (i.e. `a ? b : c`) to only compute\n     * one branch when needed, making this function more expensive.\n     */\n    function ternary(bool condition, uint256 a, uint256 b) internal pure returns (uint256) {\n        unchecked {\n            // branchless ternary works because:\n            // b ^ (a ^ b) == a\n            // b ^ 0 == b\n            return b ^ ((a ^ b) * SafeCast.toUint(condition));\n        }\n    }\n\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return ternary(a > b, a, b);\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return ternary(a < b, a, b);\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow.\n        return (a & b) + (a ^ b) / 2;\n    }\n\n    /**\n     * @dev Returns the ceiling of the division of two numbers.\n     *\n     * This differs from standard division with `/` in that it rounds towards infinity instead\n     * of rounding towards zero.\n     */\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (b == 0) {\n            // Guarantee the same behavior as in a regular Solidity division.\n            Panic.panic(Panic.DIVISION_BY_ZERO);\n        }\n\n        // The following calculation ensures accurate ceiling division without overflow.\n        // Since a is non-zero, (a - 1) / b will not overflow.\n        // The largest possible result occurs when (a - 1) / b is type(uint256).max,\n        // but the largest value we can obtain is type(uint256).max - 1, which happens\n        // when a = type(uint256).max and b = 1.\n        unchecked {\n            return SafeCast.toUint(a > 0) * ((a - 1) / b + 1);\n        }\n    }\n\n    /**\n     * @dev Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or\n     * denominator == 0.\n     *\n     * Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv) with further edits by\n     * Uniswap Labs also under MIT license.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\n        unchecked {\n            (uint256 high, uint256 low) = mul512(x, y);\n\n            // Handle non-overflow cases, 256 by 256 division.\n            if (high == 0) {\n                // Solidity will revert if denominator == 0, unlike the div opcode on its own.\n                // The surrounding unchecked block does not change this fact.\n                // See https://docs.soliditylang.org/en/latest/control-structures.html#checked-or-unchecked-arithmetic.\n                return low / denominator;\n            }\n\n            // Make sure the result is less than 2²⁵⁶. Also prevents denominator == 0.\n            if (denominator <= high) {\n                Panic.panic(ternary(denominator == 0, Panic.DIVISION_BY_ZERO, Panic.UNDER_OVERFLOW));\n            }\n\n            ///////////////////////////////////////////////\n            // 512 by 256 division.\n            ///////////////////////////////////////////////\n\n            // Make division exact by subtracting the remainder from [high low].\n            uint256 remainder;\n            assembly (\"memory-safe\") {\n                // Compute remainder using mulmod.\n                remainder := mulmod(x, y, denominator)\n\n                // Subtract 256 bit number from 512 bit number.\n                high := sub(high, gt(remainder, low))\n                low := sub(low, remainder)\n            }\n\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator.\n            // Always >= 1. See https://cs.stackexchange.com/q/138556/92363.\n\n            uint256 twos = denominator & (0 - denominator);\n            assembly (\"memory-safe\") {\n                // Divide denominator by twos.\n                denominator := div(denominator, twos)\n\n                // Divide [high low] by twos.\n                low := div(low, twos)\n\n                // Flip twos such that it is 2²⁵⁶ / twos. If twos is zero, then it becomes one.\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n\n            // Shift in bits from high into low.\n            low |= high * twos;\n\n            // Invert denominator mod 2²⁵⁶. Now that denominator is an odd number, it has an inverse modulo 2²⁵⁶ such\n            // that denominator * inv ≡ 1 mod 2²⁵⁶. Compute the inverse by starting with a seed that is correct for\n            // four bits. That is, denominator * inv ≡ 1 mod 2⁴.\n            uint256 inverse = (3 * denominator) ^ 2;\n\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also\n            // works in modular arithmetic, doubling the correct bits in each step.\n            inverse *= 2 - denominator * inverse; // inverse mod 2⁸\n            inverse *= 2 - denominator * inverse; // inverse mod 2¹⁶\n            inverse *= 2 - denominator * inverse; // inverse mod 2³²\n            inverse *= 2 - denominator * inverse; // inverse mod 2⁶⁴\n            inverse *= 2 - denominator * inverse; // inverse mod 2¹²⁸\n            inverse *= 2 - denominator * inverse; // inverse mod 2²⁵⁶\n\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\n            // This will give us the correct result modulo 2²⁵⁶. Since the preconditions guarantee that the outcome is\n            // less than 2²⁵⁶, this is the final result. We don't need to compute the high bits of the result and high\n            // is no longer required.\n            result = low * inverse;\n            return result;\n        }\n    }\n\n    /**\n     * @dev Calculates x * y / denominator with full precision, following the selected rounding direction.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\n        return mulDiv(x, y, denominator) + SafeCast.toUint(unsignedRoundsUp(rounding) && mulmod(x, y, denominator) > 0);\n    }\n\n    /**\n     * @dev Calculates floor(x * y >> n) with full precision. Throws if result overflows a uint256.\n     */\n    function mulShr(uint256 x, uint256 y, uint8 n) internal pure returns (uint256 result) {\n        unchecked {\n            (uint256 high, uint256 low) = mul512(x, y);\n            if (high >= 1 << n) {\n                Panic.panic(Panic.UNDER_OVERFLOW);\n            }\n            return (high << (256 - n)) | (low >> n);\n        }\n    }\n\n    /**\n     * @dev Calculates x * y >> n with full precision, following the selected rounding direction.\n     */\n    function mulShr(uint256 x, uint256 y, uint8 n, Rounding rounding) internal pure returns (uint256) {\n        return mulShr(x, y, n) + SafeCast.toUint(unsignedRoundsUp(rounding) && mulmod(x, y, 1 << n) > 0);\n    }\n\n    /**\n     * @dev Calculate the modular multiplicative inverse of a number in Z/nZ.\n     *\n     * If n is a prime, then Z/nZ is a field. In that case all elements are inversible, except 0.\n     * If n is not a prime, then Z/nZ is not a field, and some elements might not be inversible.\n     *\n     * If the input value is not inversible, 0 is returned.\n     *\n     * NOTE: If you know for sure that n is (big) a prime, it may be cheaper to use Fermat's little theorem and get the\n     * inverse using `Math.modExp(a, n - 2, n)`. See {invModPrime}.\n     */\n    function invMod(uint256 a, uint256 n) internal pure returns (uint256) {\n        unchecked {\n            if (n == 0) return 0;\n\n            // The inverse modulo is calculated using the Extended Euclidean Algorithm (iterative version)\n            // Used to compute integers x and y such that: ax + ny = gcd(a, n).\n            // When the gcd is 1, then the inverse of a modulo n exists and it's x.\n            // ax + ny = 1\n            // ax = 1 + (-y)n\n            // ax ≡ 1 (mod n) # x is the inverse of a modulo n\n\n            // If the remainder is 0 the gcd is n right away.\n            uint256 remainder = a % n;\n            uint256 gcd = n;\n\n            // Therefore the initial coefficients are:\n            // ax + ny = gcd(a, n) = n\n            // 0a + 1n = n\n            int256 x = 0;\n            int256 y = 1;\n\n            while (remainder != 0) {\n                uint256 quotient = gcd / remainder;\n\n                (gcd, remainder) = (\n                    // The old remainder is the next gcd to try.\n                    remainder,\n                    // Compute the next remainder.\n                    // Can't overflow given that (a % gcd) * (gcd // (a % gcd)) <= gcd\n                    // where gcd is at most n (capped to type(uint256).max)\n                    gcd - remainder * quotient\n                );\n\n                (x, y) = (\n                    // Increment the coefficient of a.\n                    y,\n                    // Decrement the coefficient of n.\n                    // Can overflow, but the result is casted to uint256 so that the\n                    // next value of y is \"wrapped around\" to a value between 0 and n - 1.\n                    x - y * int256(quotient)\n                );\n            }\n\n            if (gcd != 1) return 0; // No inverse exists.\n            return ternary(x < 0, n - uint256(-x), uint256(x)); // Wrap the result if it's negative.\n        }\n    }\n\n    /**\n     * @dev Variant of {invMod}. More efficient, but only works if `p` is known to be a prime greater than `2`.\n     *\n     * From https://en.wikipedia.org/wiki/Fermat%27s_little_theorem[Fermat's little theorem], we know that if p is\n     * prime, then `a**(p-1) ≡ 1 mod p`. As a consequence, we have `a * a**(p-2) ≡ 1 mod p`, which means that\n     * `a**(p-2)` is the modular multiplicative inverse of a in Fp.\n     *\n     * NOTE: this function does NOT check that `p` is a prime greater than `2`.\n     */\n    function invModPrime(uint256 a, uint256 p) internal view returns (uint256) {\n        unchecked {\n            return Math.modExp(a, p - 2, p);\n        }\n    }\n\n    /**\n     * @dev Returns the modular exponentiation of the specified base, exponent and modulus (b ** e % m)\n     *\n     * Requirements:\n     * - modulus can't be zero\n     * - underlying staticcall to precompile must succeed\n     *\n     * IMPORTANT: The result is only valid if the underlying call succeeds. When using this function, make\n     * sure the chain you're using it on supports the precompiled contract for modular exponentiation\n     * at address 0x05 as specified in https://eips.ethereum.org/EIPS/eip-198[EIP-198]. Otherwise,\n     * the underlying function will succeed given the lack of a revert, but the result may be incorrectly\n     * interpreted as 0.\n     */\n    function modExp(uint256 b, uint256 e, uint256 m) internal view returns (uint256) {\n        (bool success, uint256 result) = tryModExp(b, e, m);\n        if (!success) {\n            Panic.panic(Panic.DIVISION_BY_ZERO);\n        }\n        return result;\n    }\n\n    /**\n     * @dev Returns the modular exponentiation of the specified base, exponent and modulus (b ** e % m).\n     * It includes a success flag indicating if the operation succeeded. Operation will be marked as failed if trying\n     * to operate modulo 0 or if the underlying precompile reverted.\n     *\n     * IMPORTANT: The result is only valid if the success flag is true. When using this function, make sure the chain\n     * you're using it on supports the precompiled contract for modular exponentiation at address 0x05 as specified in\n     * https://eips.ethereum.org/EIPS/eip-198[EIP-198]. Otherwise, the underlying function will succeed given the lack\n     * of a revert, but the result may be incorrectly interpreted as 0.\n     */\n    function tryModExp(uint256 b, uint256 e, uint256 m) internal view returns (bool success, uint256 result) {\n        if (m == 0) return (false, 0);\n        assembly (\"memory-safe\") {\n            let ptr := mload(0x40)\n            // | Offset    | Content    | Content (Hex)                                                      |\n            // |-----------|------------|--------------------------------------------------------------------|\n            // | 0x00:0x1f | size of b  | 0x0000000000000000000000000000000000000000000000000000000000000020 |\n            // | 0x20:0x3f | size of e  | 0x0000000000000000000000000000000000000000000000000000000000000020 |\n            // | 0x40:0x5f | size of m  | 0x0000000000000000000000000000000000000000000000000000000000000020 |\n            // | 0x60:0x7f | value of b | 0x<.............................................................b> |\n            // | 0x80:0x9f | value of e | 0x<.............................................................e> |\n            // | 0xa0:0xbf | value of m | 0x<.............................................................m> |\n            mstore(ptr, 0x20)\n            mstore(add(ptr, 0x20), 0x20)\n            mstore(add(ptr, 0x40), 0x20)\n            mstore(add(ptr, 0x60), b)\n            mstore(add(ptr, 0x80), e)\n            mstore(add(ptr, 0xa0), m)\n\n            // Given the result < m, it's guaranteed to fit in 32 bytes,\n            // so we can use the memory scratch space located at offset 0.\n            success := staticcall(gas(), 0x05, ptr, 0xc0, 0x00, 0x20)\n            result := mload(0x00)\n        }\n    }\n\n    /**\n     * @dev Variant of {modExp} that supports inputs of arbitrary length.\n     */\n    function modExp(bytes memory b, bytes memory e, bytes memory m) internal view returns (bytes memory) {\n        (bool success, bytes memory result) = tryModExp(b, e, m);\n        if (!success) {\n            Panic.panic(Panic.DIVISION_BY_ZERO);\n        }\n        return result;\n    }\n\n    /**\n     * @dev Variant of {tryModExp} that supports inputs of arbitrary length.\n     */\n    function tryModExp(\n        bytes memory b,\n        bytes memory e,\n        bytes memory m\n    ) internal view returns (bool success, bytes memory result) {\n        if (_zeroBytes(m)) return (false, new bytes(0));\n\n        uint256 mLen = m.length;\n\n        // Encode call args in result and move the free memory pointer\n        result = abi.encodePacked(b.length, e.length, mLen, b, e, m);\n\n        assembly (\"memory-safe\") {\n            let dataPtr := add(result, 0x20)\n            // Write result on top of args to avoid allocating extra memory.\n            success := staticcall(gas(), 0x05, dataPtr, mload(result), dataPtr, mLen)\n            // Overwrite the length.\n            // result.length > returndatasize() is guaranteed because returndatasize() == m.length\n            mstore(result, mLen)\n            // Set the memory pointer after the returned data.\n            mstore(0x40, add(dataPtr, mLen))\n        }\n    }\n\n    /**\n     * @dev Returns whether the provided byte array is zero.\n     */\n    function _zeroBytes(bytes memory byteArray) private pure returns (bool) {\n        for (uint256 i = 0; i < byteArray.length; ++i) {\n            if (byteArray[i] != 0) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    /**\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded\n     * towards zero.\n     *\n     * This method is based on Newton's method for computing square roots; the algorithm is restricted to only\n     * using integer operations.\n     */\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        unchecked {\n            // Take care of easy edge cases when a == 0 or a == 1\n            if (a <= 1) {\n                return a;\n            }\n\n            // In this function, we use Newton's method to get a root of `f(x) := x² - a`. It involves building a\n            // sequence x_n that converges toward sqrt(a). For each iteration x_n, we also define the error between\n            // the current value as `ε_n = | x_n - sqrt(a) |`.\n            //\n            // For our first estimation, we consider `e` the smallest power of 2 which is bigger than the square root\n            // of the target. (i.e. `2**(e-1) ≤ sqrt(a) < 2**e`). We know that `e ≤ 128` because `(2¹²⁸)² = 2²⁵⁶` is\n            // bigger than any uint256.\n            //\n            // By noticing that\n            // `2**(e-1) ≤ sqrt(a) < 2**e → (2**(e-1))² ≤ a < (2**e)² → 2**(2*e-2) ≤ a < 2**(2*e)`\n            // we can deduce that `e - 1` is `log2(a) / 2`. We can thus compute `x_n = 2**(e-1)` using a method similar\n            // to the msb function.\n            uint256 aa = a;\n            uint256 xn = 1;\n\n            if (aa >= (1 << 128)) {\n                aa >>= 128;\n                xn <<= 64;\n            }\n            if (aa >= (1 << 64)) {\n                aa >>= 64;\n                xn <<= 32;\n            }\n            if (aa >= (1 << 32)) {\n                aa >>= 32;\n                xn <<= 16;\n            }\n            if (aa >= (1 << 16)) {\n                aa >>= 16;\n                xn <<= 8;\n            }\n            if (aa >= (1 << 8)) {\n                aa >>= 8;\n                xn <<= 4;\n            }\n            if (aa >= (1 << 4)) {\n                aa >>= 4;\n                xn <<= 2;\n            }\n            if (aa >= (1 << 2)) {\n                xn <<= 1;\n            }\n\n            // We now have x_n such that `x_n = 2**(e-1) ≤ sqrt(a) < 2**e = 2 * x_n`. This implies ε_n ≤ 2**(e-1).\n            //\n            // We can refine our estimation by noticing that the middle of that interval minimizes the error.\n            // If we move x_n to equal 2**(e-1) + 2**(e-2), then we reduce the error to ε_n ≤ 2**(e-2).\n            // This is going to be our x_0 (and ε_0)\n            xn = (3 * xn) >> 1; // ε_0 := | x_0 - sqrt(a) | ≤ 2**(e-2)\n\n            // From here, Newton's method give us:\n            // x_{n+1} = (x_n + a / x_n) / 2\n            //\n            // One should note that:\n            // x_{n+1}² - a = ((x_n + a / x_n) / 2)² - a\n            //              = ((x_n² + a) / (2 * x_n))² - a\n            //              = (x_n⁴ + 2 * a * x_n² + a²) / (4 * x_n²) - a\n            //              = (x_n⁴ + 2 * a * x_n² + a² - 4 * a * x_n²) / (4 * x_n²)\n            //              = (x_n⁴ - 2 * a * x_n² + a²) / (4 * x_n²)\n            //              = (x_n² - a)² / (2 * x_n)²\n            //              = ((x_n² - a) / (2 * x_n))²\n            //              ≥ 0\n            // Which proves that for all n ≥ 1, sqrt(a) ≤ x_n\n            //\n            // This gives us the proof of quadratic convergence of the sequence:\n            // ε_{n+1} = | x_{n+1} - sqrt(a) |\n            //         = | (x_n + a / x_n) / 2 - sqrt(a) |\n            //         = | (x_n² + a - 2*x_n*sqrt(a)) / (2 * x_n) |\n            //         = | (x_n - sqrt(a))² / (2 * x_n) |\n            //         = | ε_n² / (2 * x_n) |\n            //         = ε_n² / | (2 * x_n) |\n            //\n            // For the first iteration, we have a special case where x_0 is known:\n            // ε_1 = ε_0² / | (2 * x_0) |\n            //     ≤ (2**(e-2))² / (2 * (2**(e-1) + 2**(e-2)))\n            //     ≤ 2**(2*e-4) / (3 * 2**(e-1))\n            //     ≤ 2**(e-3) / 3\n            //     ≤ 2**(e-3-log2(3))\n            //     ≤ 2**(e-4.5)\n            //\n            // For the following iterations, we use the fact that, 2**(e-1) ≤ sqrt(a) ≤ x_n:\n            // ε_{n+1} = ε_n² / | (2 * x_n) |\n            //         ≤ (2**(e-k))² / (2 * 2**(e-1))\n            //         ≤ 2**(2*e-2*k) / 2**e\n            //         ≤ 2**(e-2*k)\n            xn = (xn + a / xn) >> 1; // ε_1 := | x_1 - sqrt(a) | ≤ 2**(e-4.5)  -- special case, see above\n            xn = (xn + a / xn) >> 1; // ε_2 := | x_2 - sqrt(a) | ≤ 2**(e-9)    -- general case with k = 4.5\n            xn = (xn + a / xn) >> 1; // ε_3 := | x_3 - sqrt(a) | ≤ 2**(e-18)   -- general case with k = 9\n            xn = (xn + a / xn) >> 1; // ε_4 := | x_4 - sqrt(a) | ≤ 2**(e-36)   -- general case with k = 18\n            xn = (xn + a / xn) >> 1; // ε_5 := | x_5 - sqrt(a) | ≤ 2**(e-72)   -- general case with k = 36\n            xn = (xn + a / xn) >> 1; // ε_6 := | x_6 - sqrt(a) | ≤ 2**(e-144)  -- general case with k = 72\n\n            // Because e ≤ 128 (as discussed during the first estimation phase), we know have reached a precision\n            // ε_6 ≤ 2**(e-144) < 1. Given we're operating on integers, then we can ensure that xn is now either\n            // sqrt(a) or sqrt(a) + 1.\n            return xn - SafeCast.toUint(xn > a / xn);\n        }\n    }\n\n    /**\n     * @dev Calculates sqrt(a), following the selected rounding direction.\n     */\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + SafeCast.toUint(unsignedRoundsUp(rounding) && result * result < a);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 2 of a positive value rounded towards zero.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 x) internal pure returns (uint256 r) {\n        // If value has upper 128 bits set, log2 result is at least 128\n        r = SafeCast.toUint(x > 0xffffffffffffffffffffffffffffffff) << 7;\n        // If upper 64 bits of 128-bit half set, add 64 to result\n        r |= SafeCast.toUint((x >> r) > 0xffffffffffffffff) << 6;\n        // If upper 32 bits of 64-bit half set, add 32 to result\n        r |= SafeCast.toUint((x >> r) > 0xffffffff) << 5;\n        // If upper 16 bits of 32-bit half set, add 16 to result\n        r |= SafeCast.toUint((x >> r) > 0xffff) << 4;\n        // If upper 8 bits of 16-bit half set, add 8 to result\n        r |= SafeCast.toUint((x >> r) > 0xff) << 3;\n        // If upper 4 bits of 8-bit half set, add 4 to result\n        r |= SafeCast.toUint((x >> r) > 0xf) << 2;\n\n        // Shifts value right by the current result and use it as an index into this lookup table:\n        //\n        // | x (4 bits) |  index  | table[index] = MSB position |\n        // |------------|---------|-----------------------------|\n        // |    0000    |    0    |        table[0] = 0         |\n        // |    0001    |    1    |        table[1] = 0         |\n        // |    0010    |    2    |        table[2] = 1         |\n        // |    0011    |    3    |        table[3] = 1         |\n        // |    0100    |    4    |        table[4] = 2         |\n        // |    0101    |    5    |        table[5] = 2         |\n        // |    0110    |    6    |        table[6] = 2         |\n        // |    0111    |    7    |        table[7] = 2         |\n        // |    1000    |    8    |        table[8] = 3         |\n        // |    1001    |    9    |        table[9] = 3         |\n        // |    1010    |   10    |        table[10] = 3        |\n        // |    1011    |   11    |        table[11] = 3        |\n        // |    1100    |   12    |        table[12] = 3        |\n        // |    1101    |   13    |        table[13] = 3        |\n        // |    1110    |   14    |        table[14] = 3        |\n        // |    1111    |   15    |        table[15] = 3        |\n        //\n        // The lookup table is represented as a 32-byte value with the MSB positions for 0-15 in the last 16 bytes.\n        assembly (\"memory-safe\") {\n            r := or(r, byte(shr(r, x), 0x0000010102020202030303030303030300000000000000000000000000000000))\n        }\n    }\n\n    /**\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + SafeCast.toUint(unsignedRoundsUp(rounding) && 1 << result < value);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 10 of a positive value rounded towards zero.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10 ** 64) {\n                value /= 10 ** 64;\n                result += 64;\n            }\n            if (value >= 10 ** 32) {\n                value /= 10 ** 32;\n                result += 32;\n            }\n            if (value >= 10 ** 16) {\n                value /= 10 ** 16;\n                result += 16;\n            }\n            if (value >= 10 ** 8) {\n                value /= 10 ** 8;\n                result += 8;\n            }\n            if (value >= 10 ** 4) {\n                value /= 10 ** 4;\n                result += 4;\n            }\n            if (value >= 10 ** 2) {\n                value /= 10 ** 2;\n                result += 2;\n            }\n            if (value >= 10 ** 1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + SafeCast.toUint(unsignedRoundsUp(rounding) && 10 ** result < value);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 256 of a positive value rounded towards zero.\n     * Returns 0 if given 0.\n     *\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\n     */\n    function log256(uint256 x) internal pure returns (uint256 r) {\n        // If value has upper 128 bits set, log2 result is at least 128\n        r = SafeCast.toUint(x > 0xffffffffffffffffffffffffffffffff) << 7;\n        // If upper 64 bits of 128-bit half set, add 64 to result\n        r |= SafeCast.toUint((x >> r) > 0xffffffffffffffff) << 6;\n        // If upper 32 bits of 64-bit half set, add 32 to result\n        r |= SafeCast.toUint((x >> r) > 0xffffffff) << 5;\n        // If upper 16 bits of 32-bit half set, add 16 to result\n        r |= SafeCast.toUint((x >> r) > 0xffff) << 4;\n        // Add 1 if upper 8 bits of 16-bit half set, and divide accumulated result by 8\n        return (r >> 3) | SafeCast.toUint((x >> r) > 0xff);\n    }\n\n    /**\n     * @dev Return the log in base 256, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + SafeCast.toUint(unsignedRoundsUp(rounding) && 1 << (result << 3) < value);\n        }\n    }\n\n    /**\n     * @dev Returns whether a provided rounding mode is considered rounding up for unsigned integers.\n     */\n    function unsignedRoundsUp(Rounding rounding) internal pure returns (bool) {\n        return uint8(rounding) % 2 == 1;\n    }\n}\n"
      },
      "npm/@openzeppelin/contracts@5.4.0/utils/math/SafeCast.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (utils/math/SafeCast.sol)\n// This file was procedurally generated from scripts/generate/templates/SafeCast.js.\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Wrappers over Solidity's uintXX/intXX/bool casting operators with added overflow\n * checks.\n *\n * Downcasting from uint256/int256 in Solidity does not revert on overflow. This can\n * easily result in undesired exploitation or bugs, since developers usually\n * assume that overflows raise errors. `SafeCast` restores this intuition by\n * reverting the transaction when such an operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeCast {\n    /**\n     * @dev Value doesn't fit in an uint of `bits` size.\n     */\n    error SafeCastOverflowedUintDowncast(uint8 bits, uint256 value);\n\n    /**\n     * @dev An int value doesn't fit in an uint of `bits` size.\n     */\n    error SafeCastOverflowedIntToUint(int256 value);\n\n    /**\n     * @dev Value doesn't fit in an int of `bits` size.\n     */\n    error SafeCastOverflowedIntDowncast(uint8 bits, int256 value);\n\n    /**\n     * @dev An uint value doesn't fit in an int of `bits` size.\n     */\n    error SafeCastOverflowedUintToInt(uint256 value);\n\n    /**\n     * @dev Returns the downcasted uint248 from uint256, reverting on\n     * overflow (when the input is greater than largest uint248).\n     *\n     * Counterpart to Solidity's `uint248` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 248 bits\n     */\n    function toUint248(uint256 value) internal pure returns (uint248) {\n        if (value > type(uint248).max) {\n            revert SafeCastOverflowedUintDowncast(248, value);\n        }\n        return uint248(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint240 from uint256, reverting on\n     * overflow (when the input is greater than largest uint240).\n     *\n     * Counterpart to Solidity's `uint240` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 240 bits\n     */\n    function toUint240(uint256 value) internal pure returns (uint240) {\n        if (value > type(uint240).max) {\n            revert SafeCastOverflowedUintDowncast(240, value);\n        }\n        return uint240(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint232 from uint256, reverting on\n     * overflow (when the input is greater than largest uint232).\n     *\n     * Counterpart to Solidity's `uint232` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 232 bits\n     */\n    function toUint232(uint256 value) internal pure returns (uint232) {\n        if (value > type(uint232).max) {\n            revert SafeCastOverflowedUintDowncast(232, value);\n        }\n        return uint232(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint224 from uint256, reverting on\n     * overflow (when the input is greater than largest uint224).\n     *\n     * Counterpart to Solidity's `uint224` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 224 bits\n     */\n    function toUint224(uint256 value) internal pure returns (uint224) {\n        if (value > type(uint224).max) {\n            revert SafeCastOverflowedUintDowncast(224, value);\n        }\n        return uint224(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint216 from uint256, reverting on\n     * overflow (when the input is greater than largest uint216).\n     *\n     * Counterpart to Solidity's `uint216` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 216 bits\n     */\n    function toUint216(uint256 value) internal pure returns (uint216) {\n        if (value > type(uint216).max) {\n            revert SafeCastOverflowedUintDowncast(216, value);\n        }\n        return uint216(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint208 from uint256, reverting on\n     * overflow (when the input is greater than largest uint208).\n     *\n     * Counterpart to Solidity's `uint208` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 208 bits\n     */\n    function toUint208(uint256 value) internal pure returns (uint208) {\n        if (value > type(uint208).max) {\n            revert SafeCastOverflowedUintDowncast(208, value);\n        }\n        return uint208(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint200 from uint256, reverting on\n     * overflow (when the input is greater than largest uint200).\n     *\n     * Counterpart to Solidity's `uint200` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 200 bits\n     */\n    function toUint200(uint256 value) internal pure returns (uint200) {\n        if (value > type(uint200).max) {\n            revert SafeCastOverflowedUintDowncast(200, value);\n        }\n        return uint200(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint192 from uint256, reverting on\n     * overflow (when the input is greater than largest uint192).\n     *\n     * Counterpart to Solidity's `uint192` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 192 bits\n     */\n    function toUint192(uint256 value) internal pure returns (uint192) {\n        if (value > type(uint192).max) {\n            revert SafeCastOverflowedUintDowncast(192, value);\n        }\n        return uint192(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint184 from uint256, reverting on\n     * overflow (when the input is greater than largest uint184).\n     *\n     * Counterpart to Solidity's `uint184` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 184 bits\n     */\n    function toUint184(uint256 value) internal pure returns (uint184) {\n        if (value > type(uint184).max) {\n            revert SafeCastOverflowedUintDowncast(184, value);\n        }\n        return uint184(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint176 from uint256, reverting on\n     * overflow (when the input is greater than largest uint176).\n     *\n     * Counterpart to Solidity's `uint176` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 176 bits\n     */\n    function toUint176(uint256 value) internal pure returns (uint176) {\n        if (value > type(uint176).max) {\n            revert SafeCastOverflowedUintDowncast(176, value);\n        }\n        return uint176(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint168 from uint256, reverting on\n     * overflow (when the input is greater than largest uint168).\n     *\n     * Counterpart to Solidity's `uint168` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 168 bits\n     */\n    function toUint168(uint256 value) internal pure returns (uint168) {\n        if (value > type(uint168).max) {\n            revert SafeCastOverflowedUintDowncast(168, value);\n        }\n        return uint168(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint160 from uint256, reverting on\n     * overflow (when the input is greater than largest uint160).\n     *\n     * Counterpart to Solidity's `uint160` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 160 bits\n     */\n    function toUint160(uint256 value) internal pure returns (uint160) {\n        if (value > type(uint160).max) {\n            revert SafeCastOverflowedUintDowncast(160, value);\n        }\n        return uint160(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint152 from uint256, reverting on\n     * overflow (when the input is greater than largest uint152).\n     *\n     * Counterpart to Solidity's `uint152` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 152 bits\n     */\n    function toUint152(uint256 value) internal pure returns (uint152) {\n        if (value > type(uint152).max) {\n            revert SafeCastOverflowedUintDowncast(152, value);\n        }\n        return uint152(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint144 from uint256, reverting on\n     * overflow (when the input is greater than largest uint144).\n     *\n     * Counterpart to Solidity's `uint144` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 144 bits\n     */\n    function toUint144(uint256 value) internal pure returns (uint144) {\n        if (value > type(uint144).max) {\n            revert SafeCastOverflowedUintDowncast(144, value);\n        }\n        return uint144(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint136 from uint256, reverting on\n     * overflow (when the input is greater than largest uint136).\n     *\n     * Counterpart to Solidity's `uint136` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 136 bits\n     */\n    function toUint136(uint256 value) internal pure returns (uint136) {\n        if (value > type(uint136).max) {\n            revert SafeCastOverflowedUintDowncast(136, value);\n        }\n        return uint136(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint128 from uint256, reverting on\n     * overflow (when the input is greater than largest uint128).\n     *\n     * Counterpart to Solidity's `uint128` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 128 bits\n     */\n    function toUint128(uint256 value) internal pure returns (uint128) {\n        if (value > type(uint128).max) {\n            revert SafeCastOverflowedUintDowncast(128, value);\n        }\n        return uint128(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint120 from uint256, reverting on\n     * overflow (when the input is greater than largest uint120).\n     *\n     * Counterpart to Solidity's `uint120` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 120 bits\n     */\n    function toUint120(uint256 value) internal pure returns (uint120) {\n        if (value > type(uint120).max) {\n            revert SafeCastOverflowedUintDowncast(120, value);\n        }\n        return uint120(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint112 from uint256, reverting on\n     * overflow (when the input is greater than largest uint112).\n     *\n     * Counterpart to Solidity's `uint112` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 112 bits\n     */\n    function toUint112(uint256 value) internal pure returns (uint112) {\n        if (value > type(uint112).max) {\n            revert SafeCastOverflowedUintDowncast(112, value);\n        }\n        return uint112(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint104 from uint256, reverting on\n     * overflow (when the input is greater than largest uint104).\n     *\n     * Counterpart to Solidity's `uint104` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 104 bits\n     */\n    function toUint104(uint256 value) internal pure returns (uint104) {\n        if (value > type(uint104).max) {\n            revert SafeCastOverflowedUintDowncast(104, value);\n        }\n        return uint104(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint96 from uint256, reverting on\n     * overflow (when the input is greater than largest uint96).\n     *\n     * Counterpart to Solidity's `uint96` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 96 bits\n     */\n    function toUint96(uint256 value) internal pure returns (uint96) {\n        if (value > type(uint96).max) {\n            revert SafeCastOverflowedUintDowncast(96, value);\n        }\n        return uint96(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint88 from uint256, reverting on\n     * overflow (when the input is greater than largest uint88).\n     *\n     * Counterpart to Solidity's `uint88` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 88 bits\n     */\n    function toUint88(uint256 value) internal pure returns (uint88) {\n        if (value > type(uint88).max) {\n            revert SafeCastOverflowedUintDowncast(88, value);\n        }\n        return uint88(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint80 from uint256, reverting on\n     * overflow (when the input is greater than largest uint80).\n     *\n     * Counterpart to Solidity's `uint80` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 80 bits\n     */\n    function toUint80(uint256 value) internal pure returns (uint80) {\n        if (value > type(uint80).max) {\n            revert SafeCastOverflowedUintDowncast(80, value);\n        }\n        return uint80(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint72 from uint256, reverting on\n     * overflow (when the input is greater than largest uint72).\n     *\n     * Counterpart to Solidity's `uint72` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 72 bits\n     */\n    function toUint72(uint256 value) internal pure returns (uint72) {\n        if (value > type(uint72).max) {\n            revert SafeCastOverflowedUintDowncast(72, value);\n        }\n        return uint72(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint64 from uint256, reverting on\n     * overflow (when the input is greater than largest uint64).\n     *\n     * Counterpart to Solidity's `uint64` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 64 bits\n     */\n    function toUint64(uint256 value) internal pure returns (uint64) {\n        if (value > type(uint64).max) {\n            revert SafeCastOverflowedUintDowncast(64, value);\n        }\n        return uint64(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint56 from uint256, reverting on\n     * overflow (when the input is greater than largest uint56).\n     *\n     * Counterpart to Solidity's `uint56` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 56 bits\n     */\n    function toUint56(uint256 value) internal pure returns (uint56) {\n        if (value > type(uint56).max) {\n            revert SafeCastOverflowedUintDowncast(56, value);\n        }\n        return uint56(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint48 from uint256, reverting on\n     * overflow (when the input is greater than largest uint48).\n     *\n     * Counterpart to Solidity's `uint48` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 48 bits\n     */\n    function toUint48(uint256 value) internal pure returns (uint48) {\n        if (value > type(uint48).max) {\n            revert SafeCastOverflowedUintDowncast(48, value);\n        }\n        return uint48(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint40 from uint256, reverting on\n     * overflow (when the input is greater than largest uint40).\n     *\n     * Counterpart to Solidity's `uint40` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 40 bits\n     */\n    function toUint40(uint256 value) internal pure returns (uint40) {\n        if (value > type(uint40).max) {\n            revert SafeCastOverflowedUintDowncast(40, value);\n        }\n        return uint40(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint32 from uint256, reverting on\n     * overflow (when the input is greater than largest uint32).\n     *\n     * Counterpart to Solidity's `uint32` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 32 bits\n     */\n    function toUint32(uint256 value) internal pure returns (uint32) {\n        if (value > type(uint32).max) {\n            revert SafeCastOverflowedUintDowncast(32, value);\n        }\n        return uint32(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint24 from uint256, reverting on\n     * overflow (when the input is greater than largest uint24).\n     *\n     * Counterpart to Solidity's `uint24` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 24 bits\n     */\n    function toUint24(uint256 value) internal pure returns (uint24) {\n        if (value > type(uint24).max) {\n            revert SafeCastOverflowedUintDowncast(24, value);\n        }\n        return uint24(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint16 from uint256, reverting on\n     * overflow (when the input is greater than largest uint16).\n     *\n     * Counterpart to Solidity's `uint16` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 16 bits\n     */\n    function toUint16(uint256 value) internal pure returns (uint16) {\n        if (value > type(uint16).max) {\n            revert SafeCastOverflowedUintDowncast(16, value);\n        }\n        return uint16(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint8 from uint256, reverting on\n     * overflow (when the input is greater than largest uint8).\n     *\n     * Counterpart to Solidity's `uint8` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 8 bits\n     */\n    function toUint8(uint256 value) internal pure returns (uint8) {\n        if (value > type(uint8).max) {\n            revert SafeCastOverflowedUintDowncast(8, value);\n        }\n        return uint8(value);\n    }\n\n    /**\n     * @dev Converts a signed int256 into an unsigned uint256.\n     *\n     * Requirements:\n     *\n     * - input must be greater than or equal to 0.\n     */\n    function toUint256(int256 value) internal pure returns (uint256) {\n        if (value < 0) {\n            revert SafeCastOverflowedIntToUint(value);\n        }\n        return uint256(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int248 from int256, reverting on\n     * overflow (when the input is less than smallest int248 or\n     * greater than largest int248).\n     *\n     * Counterpart to Solidity's `int248` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 248 bits\n     */\n    function toInt248(int256 value) internal pure returns (int248 downcasted) {\n        downcasted = int248(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(248, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int240 from int256, reverting on\n     * overflow (when the input is less than smallest int240 or\n     * greater than largest int240).\n     *\n     * Counterpart to Solidity's `int240` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 240 bits\n     */\n    function toInt240(int256 value) internal pure returns (int240 downcasted) {\n        downcasted = int240(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(240, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int232 from int256, reverting on\n     * overflow (when the input is less than smallest int232 or\n     * greater than largest int232).\n     *\n     * Counterpart to Solidity's `int232` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 232 bits\n     */\n    function toInt232(int256 value) internal pure returns (int232 downcasted) {\n        downcasted = int232(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(232, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int224 from int256, reverting on\n     * overflow (when the input is less than smallest int224 or\n     * greater than largest int224).\n     *\n     * Counterpart to Solidity's `int224` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 224 bits\n     */\n    function toInt224(int256 value) internal pure returns (int224 downcasted) {\n        downcasted = int224(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(224, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int216 from int256, reverting on\n     * overflow (when the input is less than smallest int216 or\n     * greater than largest int216).\n     *\n     * Counterpart to Solidity's `int216` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 216 bits\n     */\n    function toInt216(int256 value) internal pure returns (int216 downcasted) {\n        downcasted = int216(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(216, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int208 from int256, reverting on\n     * overflow (when the input is less than smallest int208 or\n     * greater than largest int208).\n     *\n     * Counterpart to Solidity's `int208` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 208 bits\n     */\n    function toInt208(int256 value) internal pure returns (int208 downcasted) {\n        downcasted = int208(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(208, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int200 from int256, reverting on\n     * overflow (when the input is less than smallest int200 or\n     * greater than largest int200).\n     *\n     * Counterpart to Solidity's `int200` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 200 bits\n     */\n    function toInt200(int256 value) internal pure returns (int200 downcasted) {\n        downcasted = int200(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(200, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int192 from int256, reverting on\n     * overflow (when the input is less than smallest int192 or\n     * greater than largest int192).\n     *\n     * Counterpart to Solidity's `int192` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 192 bits\n     */\n    function toInt192(int256 value) internal pure returns (int192 downcasted) {\n        downcasted = int192(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(192, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int184 from int256, reverting on\n     * overflow (when the input is less than smallest int184 or\n     * greater than largest int184).\n     *\n     * Counterpart to Solidity's `int184` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 184 bits\n     */\n    function toInt184(int256 value) internal pure returns (int184 downcasted) {\n        downcasted = int184(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(184, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int176 from int256, reverting on\n     * overflow (when the input is less than smallest int176 or\n     * greater than largest int176).\n     *\n     * Counterpart to Solidity's `int176` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 176 bits\n     */\n    function toInt176(int256 value) internal pure returns (int176 downcasted) {\n        downcasted = int176(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(176, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int168 from int256, reverting on\n     * overflow (when the input is less than smallest int168 or\n     * greater than largest int168).\n     *\n     * Counterpart to Solidity's `int168` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 168 bits\n     */\n    function toInt168(int256 value) internal pure returns (int168 downcasted) {\n        downcasted = int168(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(168, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int160 from int256, reverting on\n     * overflow (when the input is less than smallest int160 or\n     * greater than largest int160).\n     *\n     * Counterpart to Solidity's `int160` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 160 bits\n     */\n    function toInt160(int256 value) internal pure returns (int160 downcasted) {\n        downcasted = int160(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(160, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int152 from int256, reverting on\n     * overflow (when the input is less than smallest int152 or\n     * greater than largest int152).\n     *\n     * Counterpart to Solidity's `int152` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 152 bits\n     */\n    function toInt152(int256 value) internal pure returns (int152 downcasted) {\n        downcasted = int152(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(152, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int144 from int256, reverting on\n     * overflow (when the input is less than smallest int144 or\n     * greater than largest int144).\n     *\n     * Counterpart to Solidity's `int144` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 144 bits\n     */\n    function toInt144(int256 value) internal pure returns (int144 downcasted) {\n        downcasted = int144(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(144, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int136 from int256, reverting on\n     * overflow (when the input is less than smallest int136 or\n     * greater than largest int136).\n     *\n     * Counterpart to Solidity's `int136` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 136 bits\n     */\n    function toInt136(int256 value) internal pure returns (int136 downcasted) {\n        downcasted = int136(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(136, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int128 from int256, reverting on\n     * overflow (when the input is less than smallest int128 or\n     * greater than largest int128).\n     *\n     * Counterpart to Solidity's `int128` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 128 bits\n     */\n    function toInt128(int256 value) internal pure returns (int128 downcasted) {\n        downcasted = int128(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(128, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int120 from int256, reverting on\n     * overflow (when the input is less than smallest int120 or\n     * greater than largest int120).\n     *\n     * Counterpart to Solidity's `int120` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 120 bits\n     */\n    function toInt120(int256 value) internal pure returns (int120 downcasted) {\n        downcasted = int120(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(120, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int112 from int256, reverting on\n     * overflow (when the input is less than smallest int112 or\n     * greater than largest int112).\n     *\n     * Counterpart to Solidity's `int112` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 112 bits\n     */\n    function toInt112(int256 value) internal pure returns (int112 downcasted) {\n        downcasted = int112(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(112, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int104 from int256, reverting on\n     * overflow (when the input is less than smallest int104 or\n     * greater than largest int104).\n     *\n     * Counterpart to Solidity's `int104` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 104 bits\n     */\n    function toInt104(int256 value) internal pure returns (int104 downcasted) {\n        downcasted = int104(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(104, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int96 from int256, reverting on\n     * overflow (when the input is less than smallest int96 or\n     * greater than largest int96).\n     *\n     * Counterpart to Solidity's `int96` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 96 bits\n     */\n    function toInt96(int256 value) internal pure returns (int96 downcasted) {\n        downcasted = int96(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(96, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int88 from int256, reverting on\n     * overflow (when the input is less than smallest int88 or\n     * greater than largest int88).\n     *\n     * Counterpart to Solidity's `int88` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 88 bits\n     */\n    function toInt88(int256 value) internal pure returns (int88 downcasted) {\n        downcasted = int88(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(88, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int80 from int256, reverting on\n     * overflow (when the input is less than smallest int80 or\n     * greater than largest int80).\n     *\n     * Counterpart to Solidity's `int80` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 80 bits\n     */\n    function toInt80(int256 value) internal pure returns (int80 downcasted) {\n        downcasted = int80(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(80, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int72 from int256, reverting on\n     * overflow (when the input is less than smallest int72 or\n     * greater than largest int72).\n     *\n     * Counterpart to Solidity's `int72` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 72 bits\n     */\n    function toInt72(int256 value) internal pure returns (int72 downcasted) {\n        downcasted = int72(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(72, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int64 from int256, reverting on\n     * overflow (when the input is less than smallest int64 or\n     * greater than largest int64).\n     *\n     * Counterpart to Solidity's `int64` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 64 bits\n     */\n    function toInt64(int256 value) internal pure returns (int64 downcasted) {\n        downcasted = int64(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(64, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int56 from int256, reverting on\n     * overflow (when the input is less than smallest int56 or\n     * greater than largest int56).\n     *\n     * Counterpart to Solidity's `int56` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 56 bits\n     */\n    function toInt56(int256 value) internal pure returns (int56 downcasted) {\n        downcasted = int56(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(56, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int48 from int256, reverting on\n     * overflow (when the input is less than smallest int48 or\n     * greater than largest int48).\n     *\n     * Counterpart to Solidity's `int48` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 48 bits\n     */\n    function toInt48(int256 value) internal pure returns (int48 downcasted) {\n        downcasted = int48(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(48, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int40 from int256, reverting on\n     * overflow (when the input is less than smallest int40 or\n     * greater than largest int40).\n     *\n     * Counterpart to Solidity's `int40` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 40 bits\n     */\n    function toInt40(int256 value) internal pure returns (int40 downcasted) {\n        downcasted = int40(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(40, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int32 from int256, reverting on\n     * overflow (when the input is less than smallest int32 or\n     * greater than largest int32).\n     *\n     * Counterpart to Solidity's `int32` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 32 bits\n     */\n    function toInt32(int256 value) internal pure returns (int32 downcasted) {\n        downcasted = int32(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(32, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int24 from int256, reverting on\n     * overflow (when the input is less than smallest int24 or\n     * greater than largest int24).\n     *\n     * Counterpart to Solidity's `int24` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 24 bits\n     */\n    function toInt24(int256 value) internal pure returns (int24 downcasted) {\n        downcasted = int24(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(24, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int16 from int256, reverting on\n     * overflow (when the input is less than smallest int16 or\n     * greater than largest int16).\n     *\n     * Counterpart to Solidity's `int16` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 16 bits\n     */\n    function toInt16(int256 value) internal pure returns (int16 downcasted) {\n        downcasted = int16(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(16, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int8 from int256, reverting on\n     * overflow (when the input is less than smallest int8 or\n     * greater than largest int8).\n     *\n     * Counterpart to Solidity's `int8` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 8 bits\n     */\n    function toInt8(int256 value) internal pure returns (int8 downcasted) {\n        downcasted = int8(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(8, value);\n        }\n    }\n\n    /**\n     * @dev Converts an unsigned uint256 into a signed int256.\n     *\n     * Requirements:\n     *\n     * - input must be less than or equal to maxInt256.\n     */\n    function toInt256(uint256 value) internal pure returns (int256) {\n        // Note: Unsafe cast below is okay because `type(int256).max` is guaranteed to be positive\n        if (value > uint256(type(int256).max)) {\n            revert SafeCastOverflowedUintToInt(value);\n        }\n        return int256(value);\n    }\n\n    /**\n     * @dev Cast a boolean (false or true) to a uint256 (0 or 1) with no jump.\n     */\n    function toUint(bool b) internal pure returns (uint256 u) {\n        assembly (\"memory-safe\") {\n            u := iszero(iszero(b))\n        }\n    }\n}\n"
      },
      "npm/@openzeppelin/contracts@5.4.0/utils/math/SignedMath.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (utils/math/SignedMath.sol)\n\npragma solidity ^0.8.20;\n\nimport {SafeCast} from \"./SafeCast.sol\";\n\n/**\n * @dev Standard signed math utilities missing in the Solidity language.\n */\nlibrary SignedMath {\n    /**\n     * @dev Branchless ternary evaluation for `a ? b : c`. Gas costs are constant.\n     *\n     * IMPORTANT: This function may reduce bytecode size and consume less gas when used standalone.\n     * However, the compiler may optimize Solidity ternary operations (i.e. `a ? b : c`) to only compute\n     * one branch when needed, making this function more expensive.\n     */\n    function ternary(bool condition, int256 a, int256 b) internal pure returns (int256) {\n        unchecked {\n            // branchless ternary works because:\n            // b ^ (a ^ b) == a\n            // b ^ 0 == b\n            return b ^ ((a ^ b) * int256(SafeCast.toUint(condition)));\n        }\n    }\n\n    /**\n     * @dev Returns the largest of two signed numbers.\n     */\n    function max(int256 a, int256 b) internal pure returns (int256) {\n        return ternary(a > b, a, b);\n    }\n\n    /**\n     * @dev Returns the smallest of two signed numbers.\n     */\n    function min(int256 a, int256 b) internal pure returns (int256) {\n        return ternary(a < b, a, b);\n    }\n\n    /**\n     * @dev Returns the average of two signed numbers without overflow.\n     * The result is rounded towards zero.\n     */\n    function average(int256 a, int256 b) internal pure returns (int256) {\n        // Formula from the book \"Hacker's Delight\"\n        int256 x = (a & b) + ((a ^ b) >> 1);\n        return x + (int256(uint256(x) >> 255) & (a ^ b));\n    }\n\n    /**\n     * @dev Returns the absolute unsigned value of a signed value.\n     */\n    function abs(int256 n) internal pure returns (uint256) {\n        unchecked {\n            // Formula from the \"Bit Twiddling Hacks\" by Sean Eron Anderson.\n            // Since `n` is a signed integer, the generated bytecode will use the SAR opcode to perform the right shift,\n            // taking advantage of the most significant (or \"sign\" bit) in two's complement representation.\n            // This opcode adds new most significant bits set to the value of the previous most significant bit. As a result,\n            // the mask will either be `bytes32(0)` (if n is positive) or `~bytes32(0)` (if n is negative).\n            int256 mask = n >> 255;\n\n            // A `bytes32(0)` mask leaves the input unchanged, while a `~bytes32(0)` mask complements it.\n            return uint256((n + mask) ^ mask);\n        }\n    }\n}\n"
      },
      "npm/@openzeppelin/contracts@5.4.0/utils/Panic.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (utils/Panic.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Helper library for emitting standardized panic codes.\n *\n * ```solidity\n * contract Example {\n *      using Panic for uint256;\n *\n *      // Use any of the declared internal constants\n *      function foo() { Panic.GENERIC.panic(); }\n *\n *      // Alternatively\n *      function foo() { Panic.panic(Panic.GENERIC); }\n * }\n * ```\n *\n * Follows the list from https://github.com/ethereum/solidity/blob/v0.8.24/libsolutil/ErrorCodes.h[libsolutil].\n *\n * _Available since v5.1._\n */\n// slither-disable-next-line unused-state\nlibrary Panic {\n    /// @dev generic / unspecified error\n    uint256 internal constant GENERIC = 0x00;\n    /// @dev used by the assert() builtin\n    uint256 internal constant ASSERT = 0x01;\n    /// @dev arithmetic underflow or overflow\n    uint256 internal constant UNDER_OVERFLOW = 0x11;\n    /// @dev division or modulo by zero\n    uint256 internal constant DIVISION_BY_ZERO = 0x12;\n    /// @dev enum conversion error\n    uint256 internal constant ENUM_CONVERSION_ERROR = 0x21;\n    /// @dev invalid encoding in storage\n    uint256 internal constant STORAGE_ENCODING_ERROR = 0x22;\n    /// @dev empty array pop\n    uint256 internal constant EMPTY_ARRAY_POP = 0x31;\n    /// @dev array out of bounds access\n    uint256 internal constant ARRAY_OUT_OF_BOUNDS = 0x32;\n    /// @dev resource error (too large allocation or too large array)\n    uint256 internal constant RESOURCE_ERROR = 0x41;\n    /// @dev calling invalid internal function\n    uint256 internal constant INVALID_INTERNAL_FUNCTION = 0x51;\n\n    /// @dev Reverts with a panic code. Recommended to use with\n    /// the internal constants with predefined codes.\n    function panic(uint256 code) internal pure {\n        assembly (\"memory-safe\") {\n            mstore(0x00, 0x4e487b71)\n            mstore(0x20, code)\n            revert(0x1c, 0x24)\n        }\n    }\n}\n"
      },
      "npm/@openzeppelin/contracts@5.4.0/utils/SlotDerivation.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.3.0) (utils/SlotDerivation.sol)\n// This file was procedurally generated from scripts/generate/templates/SlotDerivation.js.\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Library for computing storage (and transient storage) locations from namespaces and deriving slots\n * corresponding to standard patterns. The derivation method for array and mapping matches the storage layout used by\n * the solidity language / compiler.\n *\n * See https://docs.soliditylang.org/en/v0.8.20/internals/layout_in_storage.html#mappings-and-dynamic-arrays[Solidity docs for mappings and dynamic arrays.].\n *\n * Example usage:\n * ```solidity\n * contract Example {\n *     // Add the library methods\n *     using StorageSlot for bytes32;\n *     using SlotDerivation for bytes32;\n *\n *     // Declare a namespace\n *     string private constant _NAMESPACE = \"<namespace>\"; // eg. OpenZeppelin.Slot\n *\n *     function setValueInNamespace(uint256 key, address newValue) internal {\n *         _NAMESPACE.erc7201Slot().deriveMapping(key).getAddressSlot().value = newValue;\n *     }\n *\n *     function getValueInNamespace(uint256 key) internal view returns (address) {\n *         return _NAMESPACE.erc7201Slot().deriveMapping(key).getAddressSlot().value;\n *     }\n * }\n * ```\n *\n * TIP: Consider using this library along with {StorageSlot}.\n *\n * NOTE: This library provides a way to manipulate storage locations in a non-standard way. Tooling for checking\n * upgrade safety will ignore the slots accessed through this library.\n *\n * _Available since v5.1._\n */\nlibrary SlotDerivation {\n    /**\n     * @dev Derive an ERC-7201 slot from a string (namespace).\n     */\n    function erc7201Slot(string memory namespace) internal pure returns (bytes32 slot) {\n        assembly (\"memory-safe\") {\n            mstore(0x00, sub(keccak256(add(namespace, 0x20), mload(namespace)), 1))\n            slot := and(keccak256(0x00, 0x20), not(0xff))\n        }\n    }\n\n    /**\n     * @dev Add an offset to a slot to get the n-th element of a structure or an array.\n     */\n    function offset(bytes32 slot, uint256 pos) internal pure returns (bytes32 result) {\n        unchecked {\n            return bytes32(uint256(slot) + pos);\n        }\n    }\n\n    /**\n     * @dev Derive the location of the first element in an array from the slot where the length is stored.\n     */\n    function deriveArray(bytes32 slot) internal pure returns (bytes32 result) {\n        assembly (\"memory-safe\") {\n            mstore(0x00, slot)\n            result := keccak256(0x00, 0x20)\n        }\n    }\n\n    /**\n     * @dev Derive the location of a mapping element from the key.\n     */\n    function deriveMapping(bytes32 slot, address key) internal pure returns (bytes32 result) {\n        assembly (\"memory-safe\") {\n            mstore(0x00, and(key, shr(96, not(0))))\n            mstore(0x20, slot)\n            result := keccak256(0x00, 0x40)\n        }\n    }\n\n    /**\n     * @dev Derive the location of a mapping element from the key.\n     */\n    function deriveMapping(bytes32 slot, bool key) internal pure returns (bytes32 result) {\n        assembly (\"memory-safe\") {\n            mstore(0x00, iszero(iszero(key)))\n            mstore(0x20, slot)\n            result := keccak256(0x00, 0x40)\n        }\n    }\n\n    /**\n     * @dev Derive the location of a mapping element from the key.\n     */\n    function deriveMapping(bytes32 slot, bytes32 key) internal pure returns (bytes32 result) {\n        assembly (\"memory-safe\") {\n            mstore(0x00, key)\n            mstore(0x20, slot)\n            result := keccak256(0x00, 0x40)\n        }\n    }\n\n    /**\n     * @dev Derive the location of a mapping element from the key.\n     */\n    function deriveMapping(bytes32 slot, uint256 key) internal pure returns (bytes32 result) {\n        assembly (\"memory-safe\") {\n            mstore(0x00, key)\n            mstore(0x20, slot)\n            result := keccak256(0x00, 0x40)\n        }\n    }\n\n    /**\n     * @dev Derive the location of a mapping element from the key.\n     */\n    function deriveMapping(bytes32 slot, int256 key) internal pure returns (bytes32 result) {\n        assembly (\"memory-safe\") {\n            mstore(0x00, key)\n            mstore(0x20, slot)\n            result := keccak256(0x00, 0x40)\n        }\n    }\n\n    /**\n     * @dev Derive the location of a mapping element from the key.\n     */\n    function deriveMapping(bytes32 slot, string memory key) internal pure returns (bytes32 result) {\n        assembly (\"memory-safe\") {\n            let length := mload(key)\n            let begin := add(key, 0x20)\n            let end := add(begin, length)\n            let cache := mload(end)\n            mstore(end, slot)\n            result := keccak256(begin, add(length, 0x20))\n            mstore(end, cache)\n        }\n    }\n\n    /**\n     * @dev Derive the location of a mapping element from the key.\n     */\n    function deriveMapping(bytes32 slot, bytes memory key) internal pure returns (bytes32 result) {\n        assembly (\"memory-safe\") {\n            let length := mload(key)\n            let begin := add(key, 0x20)\n            let end := add(begin, length)\n            let cache := mload(end)\n            mstore(end, slot)\n            result := keccak256(begin, add(length, 0x20))\n            mstore(end, cache)\n        }\n    }\n}\n"
      },
      "npm/@openzeppelin/contracts@5.4.0/utils/StorageSlot.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (utils/StorageSlot.sol)\n// This file was procedurally generated from scripts/generate/templates/StorageSlot.js.\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Library for reading and writing primitive types to specific storage slots.\n *\n * Storage slots are often used to avoid storage conflict when dealing with upgradeable contracts.\n * This library helps with reading and writing to such slots without the need for inline assembly.\n *\n * The functions in this library return Slot structs that contain a `value` member that can be used to read or write.\n *\n * Example usage to set ERC-1967 implementation slot:\n * ```solidity\n * contract ERC1967 {\n *     // Define the slot. Alternatively, use the SlotDerivation library to derive the slot.\n *     bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n *\n *     function _getImplementation() internal view returns (address) {\n *         return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;\n *     }\n *\n *     function _setImplementation(address newImplementation) internal {\n *         require(newImplementation.code.length > 0);\n *         StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\n *     }\n * }\n * ```\n *\n * TIP: Consider using this library along with {SlotDerivation}.\n */\nlibrary StorageSlot {\n    struct AddressSlot {\n        address value;\n    }\n\n    struct BooleanSlot {\n        bool value;\n    }\n\n    struct Bytes32Slot {\n        bytes32 value;\n    }\n\n    struct Uint256Slot {\n        uint256 value;\n    }\n\n    struct Int256Slot {\n        int256 value;\n    }\n\n    struct StringSlot {\n        string value;\n    }\n\n    struct BytesSlot {\n        bytes value;\n    }\n\n    /**\n     * @dev Returns an `AddressSlot` with member `value` located at `slot`.\n     */\n    function getAddressSlot(bytes32 slot) internal pure returns (AddressSlot storage r) {\n        assembly (\"memory-safe\") {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns a `BooleanSlot` with member `value` located at `slot`.\n     */\n    function getBooleanSlot(bytes32 slot) internal pure returns (BooleanSlot storage r) {\n        assembly (\"memory-safe\") {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns a `Bytes32Slot` with member `value` located at `slot`.\n     */\n    function getBytes32Slot(bytes32 slot) internal pure returns (Bytes32Slot storage r) {\n        assembly (\"memory-safe\") {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns a `Uint256Slot` with member `value` located at `slot`.\n     */\n    function getUint256Slot(bytes32 slot) internal pure returns (Uint256Slot storage r) {\n        assembly (\"memory-safe\") {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns a `Int256Slot` with member `value` located at `slot`.\n     */\n    function getInt256Slot(bytes32 slot) internal pure returns (Int256Slot storage r) {\n        assembly (\"memory-safe\") {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns a `StringSlot` with member `value` located at `slot`.\n     */\n    function getStringSlot(bytes32 slot) internal pure returns (StringSlot storage r) {\n        assembly (\"memory-safe\") {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `StringSlot` representation of the string storage pointer `store`.\n     */\n    function getStringSlot(string storage store) internal pure returns (StringSlot storage r) {\n        assembly (\"memory-safe\") {\n            r.slot := store.slot\n        }\n    }\n\n    /**\n     * @dev Returns a `BytesSlot` with member `value` located at `slot`.\n     */\n    function getBytesSlot(bytes32 slot) internal pure returns (BytesSlot storage r) {\n        assembly (\"memory-safe\") {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `BytesSlot` representation of the bytes storage pointer `store`.\n     */\n    function getBytesSlot(bytes storage store) internal pure returns (BytesSlot storage r) {\n        assembly (\"memory-safe\") {\n            r.slot := store.slot\n        }\n    }\n}\n"
      },
      "npm/@openzeppelin/contracts@5.4.0/utils/Strings.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.4.0) (utils/Strings.sol)\n\npragma solidity ^0.8.20;\n\nimport {Math} from \"./math/Math.sol\";\nimport {SafeCast} from \"./math/SafeCast.sol\";\nimport {SignedMath} from \"./math/SignedMath.sol\";\n\n/**\n * @dev String operations.\n */\nlibrary Strings {\n    using SafeCast for *;\n\n    bytes16 private constant HEX_DIGITS = \"0123456789abcdef\";\n    uint8 private constant ADDRESS_LENGTH = 20;\n    uint256 private constant SPECIAL_CHARS_LOOKUP =\n        (1 << 0x08) | // backspace\n            (1 << 0x09) | // tab\n            (1 << 0x0a) | // newline\n            (1 << 0x0c) | // form feed\n            (1 << 0x0d) | // carriage return\n            (1 << 0x22) | // double quote\n            (1 << 0x5c); // backslash\n\n    /**\n     * @dev The `value` string doesn't fit in the specified `length`.\n     */\n    error StringsInsufficientHexLength(uint256 value, uint256 length);\n\n    /**\n     * @dev The string being parsed contains characters that are not in scope of the given base.\n     */\n    error StringsInvalidChar();\n\n    /**\n     * @dev The string being parsed is not a properly formatted address.\n     */\n    error StringsInvalidAddressFormat();\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            uint256 length = Math.log10(value) + 1;\n            string memory buffer = new string(length);\n            uint256 ptr;\n            assembly (\"memory-safe\") {\n                ptr := add(add(buffer, 0x20), length)\n            }\n            while (true) {\n                ptr--;\n                assembly (\"memory-safe\") {\n                    mstore8(ptr, byte(mod(value, 10), HEX_DIGITS))\n                }\n                value /= 10;\n                if (value == 0) break;\n            }\n            return buffer;\n        }\n    }\n\n    /**\n     * @dev Converts a `int256` to its ASCII `string` decimal representation.\n     */\n    function toStringSigned(int256 value) internal pure returns (string memory) {\n        return string.concat(value < 0 ? \"-\" : \"\", toString(SignedMath.abs(value)));\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            return toHexString(value, Math.log256(value) + 1);\n        }\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        uint256 localValue = value;\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = HEX_DIGITS[localValue & 0xf];\n            localValue >>= 4;\n        }\n        if (localValue != 0) {\n            revert StringsInsufficientHexLength(value, length);\n        }\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal\n     * representation.\n     */\n    function toHexString(address addr) internal pure returns (string memory) {\n        return toHexString(uint256(uint160(addr)), ADDRESS_LENGTH);\n    }\n\n    /**\n     * @dev Converts an `address` with fixed length of 20 bytes to its checksummed ASCII `string` hexadecimal\n     * representation, according to EIP-55.\n     */\n    function toChecksumHexString(address addr) internal pure returns (string memory) {\n        bytes memory buffer = bytes(toHexString(addr));\n\n        // hash the hex part of buffer (skip length + 2 bytes, length 40)\n        uint256 hashValue;\n        assembly (\"memory-safe\") {\n            hashValue := shr(96, keccak256(add(buffer, 0x22), 40))\n        }\n\n        for (uint256 i = 41; i > 1; --i) {\n            // possible values for buffer[i] are 48 (0) to 57 (9) and 97 (a) to 102 (f)\n            if (hashValue & 0xf > 7 && uint8(buffer[i]) > 96) {\n                // case shift by xoring with 0x20\n                buffer[i] ^= 0x20;\n            }\n            hashValue >>= 4;\n        }\n        return string(buffer);\n    }\n\n    /**\n     * @dev Returns true if the two strings are equal.\n     */\n    function equal(string memory a, string memory b) internal pure returns (bool) {\n        return bytes(a).length == bytes(b).length && keccak256(bytes(a)) == keccak256(bytes(b));\n    }\n\n    /**\n     * @dev Parse a decimal string and returns the value as a `uint256`.\n     *\n     * Requirements:\n     * - The string must be formatted as `[0-9]*`\n     * - The result must fit into an `uint256` type\n     */\n    function parseUint(string memory input) internal pure returns (uint256) {\n        return parseUint(input, 0, bytes(input).length);\n    }\n\n    /**\n     * @dev Variant of {parseUint-string} that parses a substring of `input` located between position `begin` (included) and\n     * `end` (excluded).\n     *\n     * Requirements:\n     * - The substring must be formatted as `[0-9]*`\n     * - The result must fit into an `uint256` type\n     */\n    function parseUint(string memory input, uint256 begin, uint256 end) internal pure returns (uint256) {\n        (bool success, uint256 value) = tryParseUint(input, begin, end);\n        if (!success) revert StringsInvalidChar();\n        return value;\n    }\n\n    /**\n     * @dev Variant of {parseUint-string} that returns false if the parsing fails because of an invalid character.\n     *\n     * NOTE: This function will revert if the result does not fit in a `uint256`.\n     */\n    function tryParseUint(string memory input) internal pure returns (bool success, uint256 value) {\n        return _tryParseUintUncheckedBounds(input, 0, bytes(input).length);\n    }\n\n    /**\n     * @dev Variant of {parseUint-string-uint256-uint256} that returns false if the parsing fails because of an invalid\n     * character.\n     *\n     * NOTE: This function will revert if the result does not fit in a `uint256`.\n     */\n    function tryParseUint(\n        string memory input,\n        uint256 begin,\n        uint256 end\n    ) internal pure returns (bool success, uint256 value) {\n        if (end > bytes(input).length || begin > end) return (false, 0);\n        return _tryParseUintUncheckedBounds(input, begin, end);\n    }\n\n    /**\n     * @dev Implementation of {tryParseUint-string-uint256-uint256} that does not check bounds. Caller should make sure that\n     * `begin <= end <= input.length`. Other inputs would result in undefined behavior.\n     */\n    function _tryParseUintUncheckedBounds(\n        string memory input,\n        uint256 begin,\n        uint256 end\n    ) private pure returns (bool success, uint256 value) {\n        bytes memory buffer = bytes(input);\n\n        uint256 result = 0;\n        for (uint256 i = begin; i < end; ++i) {\n            uint8 chr = _tryParseChr(bytes1(_unsafeReadBytesOffset(buffer, i)));\n            if (chr > 9) return (false, 0);\n            result *= 10;\n            result += chr;\n        }\n        return (true, result);\n    }\n\n    /**\n     * @dev Parse a decimal string and returns the value as a `int256`.\n     *\n     * Requirements:\n     * - The string must be formatted as `[-+]?[0-9]*`\n     * - The result must fit in an `int256` type.\n     */\n    function parseInt(string memory input) internal pure returns (int256) {\n        return parseInt(input, 0, bytes(input).length);\n    }\n\n    /**\n     * @dev Variant of {parseInt-string} that parses a substring of `input` located between position `begin` (included) and\n     * `end` (excluded).\n     *\n     * Requirements:\n     * - The substring must be formatted as `[-+]?[0-9]*`\n     * - The result must fit in an `int256` type.\n     */\n    function parseInt(string memory input, uint256 begin, uint256 end) internal pure returns (int256) {\n        (bool success, int256 value) = tryParseInt(input, begin, end);\n        if (!success) revert StringsInvalidChar();\n        return value;\n    }\n\n    /**\n     * @dev Variant of {parseInt-string} that returns false if the parsing fails because of an invalid character or if\n     * the result does not fit in a `int256`.\n     *\n     * NOTE: This function will revert if the absolute value of the result does not fit in a `uint256`.\n     */\n    function tryParseInt(string memory input) internal pure returns (bool success, int256 value) {\n        return _tryParseIntUncheckedBounds(input, 0, bytes(input).length);\n    }\n\n    uint256 private constant ABS_MIN_INT256 = 2 ** 255;\n\n    /**\n     * @dev Variant of {parseInt-string-uint256-uint256} that returns false if the parsing fails because of an invalid\n     * character or if the result does not fit in a `int256`.\n     *\n     * NOTE: This function will revert if the absolute value of the result does not fit in a `uint256`.\n     */\n    function tryParseInt(\n        string memory input,\n        uint256 begin,\n        uint256 end\n    ) internal pure returns (bool success, int256 value) {\n        if (end > bytes(input).length || begin > end) return (false, 0);\n        return _tryParseIntUncheckedBounds(input, begin, end);\n    }\n\n    /**\n     * @dev Implementation of {tryParseInt-string-uint256-uint256} that does not check bounds. Caller should make sure that\n     * `begin <= end <= input.length`. Other inputs would result in undefined behavior.\n     */\n    function _tryParseIntUncheckedBounds(\n        string memory input,\n        uint256 begin,\n        uint256 end\n    ) private pure returns (bool success, int256 value) {\n        bytes memory buffer = bytes(input);\n\n        // Check presence of a negative sign.\n        bytes1 sign = begin == end ? bytes1(0) : bytes1(_unsafeReadBytesOffset(buffer, begin)); // don't do out-of-bound (possibly unsafe) read if sub-string is empty\n        bool positiveSign = sign == bytes1(\"+\");\n        bool negativeSign = sign == bytes1(\"-\");\n        uint256 offset = (positiveSign || negativeSign).toUint();\n\n        (bool absSuccess, uint256 absValue) = tryParseUint(input, begin + offset, end);\n\n        if (absSuccess && absValue < ABS_MIN_INT256) {\n            return (true, negativeSign ? -int256(absValue) : int256(absValue));\n        } else if (absSuccess && negativeSign && absValue == ABS_MIN_INT256) {\n            return (true, type(int256).min);\n        } else return (false, 0);\n    }\n\n    /**\n     * @dev Parse a hexadecimal string (with or without \"0x\" prefix), and returns the value as a `uint256`.\n     *\n     * Requirements:\n     * - The string must be formatted as `(0x)?[0-9a-fA-F]*`\n     * - The result must fit in an `uint256` type.\n     */\n    function parseHexUint(string memory input) internal pure returns (uint256) {\n        return parseHexUint(input, 0, bytes(input).length);\n    }\n\n    /**\n     * @dev Variant of {parseHexUint-string} that parses a substring of `input` located between position `begin` (included) and\n     * `end` (excluded).\n     *\n     * Requirements:\n     * - The substring must be formatted as `(0x)?[0-9a-fA-F]*`\n     * - The result must fit in an `uint256` type.\n     */\n    function parseHexUint(string memory input, uint256 begin, uint256 end) internal pure returns (uint256) {\n        (bool success, uint256 value) = tryParseHexUint(input, begin, end);\n        if (!success) revert StringsInvalidChar();\n        return value;\n    }\n\n    /**\n     * @dev Variant of {parseHexUint-string} that returns false if the parsing fails because of an invalid character.\n     *\n     * NOTE: This function will revert if the result does not fit in a `uint256`.\n     */\n    function tryParseHexUint(string memory input) internal pure returns (bool success, uint256 value) {\n        return _tryParseHexUintUncheckedBounds(input, 0, bytes(input).length);\n    }\n\n    /**\n     * @dev Variant of {parseHexUint-string-uint256-uint256} that returns false if the parsing fails because of an\n     * invalid character.\n     *\n     * NOTE: This function will revert if the result does not fit in a `uint256`.\n     */\n    function tryParseHexUint(\n        string memory input,\n        uint256 begin,\n        uint256 end\n    ) internal pure returns (bool success, uint256 value) {\n        if (end > bytes(input).length || begin > end) return (false, 0);\n        return _tryParseHexUintUncheckedBounds(input, begin, end);\n    }\n\n    /**\n     * @dev Implementation of {tryParseHexUint-string-uint256-uint256} that does not check bounds. Caller should make sure that\n     * `begin <= end <= input.length`. Other inputs would result in undefined behavior.\n     */\n    function _tryParseHexUintUncheckedBounds(\n        string memory input,\n        uint256 begin,\n        uint256 end\n    ) private pure returns (bool success, uint256 value) {\n        bytes memory buffer = bytes(input);\n\n        // skip 0x prefix if present\n        bool hasPrefix = (end > begin + 1) && bytes2(_unsafeReadBytesOffset(buffer, begin)) == bytes2(\"0x\"); // don't do out-of-bound (possibly unsafe) read if sub-string is empty\n        uint256 offset = hasPrefix.toUint() * 2;\n\n        uint256 result = 0;\n        for (uint256 i = begin + offset; i < end; ++i) {\n            uint8 chr = _tryParseChr(bytes1(_unsafeReadBytesOffset(buffer, i)));\n            if (chr > 15) return (false, 0);\n            result *= 16;\n            unchecked {\n                // Multiplying by 16 is equivalent to a shift of 4 bits (with additional overflow check).\n                // This guarantees that adding a value < 16 will not cause an overflow, hence the unchecked.\n                result += chr;\n            }\n        }\n        return (true, result);\n    }\n\n    /**\n     * @dev Parse a hexadecimal string (with or without \"0x\" prefix), and returns the value as an `address`.\n     *\n     * Requirements:\n     * - The string must be formatted as `(0x)?[0-9a-fA-F]{40}`\n     */\n    function parseAddress(string memory input) internal pure returns (address) {\n        return parseAddress(input, 0, bytes(input).length);\n    }\n\n    /**\n     * @dev Variant of {parseAddress-string} that parses a substring of `input` located between position `begin` (included) and\n     * `end` (excluded).\n     *\n     * Requirements:\n     * - The substring must be formatted as `(0x)?[0-9a-fA-F]{40}`\n     */\n    function parseAddress(string memory input, uint256 begin, uint256 end) internal pure returns (address) {\n        (bool success, address value) = tryParseAddress(input, begin, end);\n        if (!success) revert StringsInvalidAddressFormat();\n        return value;\n    }\n\n    /**\n     * @dev Variant of {parseAddress-string} that returns false if the parsing fails because the input is not a properly\n     * formatted address. See {parseAddress-string} requirements.\n     */\n    function tryParseAddress(string memory input) internal pure returns (bool success, address value) {\n        return tryParseAddress(input, 0, bytes(input).length);\n    }\n\n    /**\n     * @dev Variant of {parseAddress-string-uint256-uint256} that returns false if the parsing fails because input is not a properly\n     * formatted address. See {parseAddress-string-uint256-uint256} requirements.\n     */\n    function tryParseAddress(\n        string memory input,\n        uint256 begin,\n        uint256 end\n    ) internal pure returns (bool success, address value) {\n        if (end > bytes(input).length || begin > end) return (false, address(0));\n\n        bool hasPrefix = (end > begin + 1) && bytes2(_unsafeReadBytesOffset(bytes(input), begin)) == bytes2(\"0x\"); // don't do out-of-bound (possibly unsafe) read if sub-string is empty\n        uint256 expectedLength = 40 + hasPrefix.toUint() * 2;\n\n        // check that input is the correct length\n        if (end - begin == expectedLength) {\n            // length guarantees that this does not overflow, and value is at most type(uint160).max\n            (bool s, uint256 v) = _tryParseHexUintUncheckedBounds(input, begin, end);\n            return (s, address(uint160(v)));\n        } else {\n            return (false, address(0));\n        }\n    }\n\n    function _tryParseChr(bytes1 chr) private pure returns (uint8) {\n        uint8 value = uint8(chr);\n\n        // Try to parse `chr`:\n        // - Case 1: [0-9]\n        // - Case 2: [a-f]\n        // - Case 3: [A-F]\n        // - otherwise not supported\n        unchecked {\n            if (value > 47 && value < 58) value -= 48;\n            else if (value > 96 && value < 103) value -= 87;\n            else if (value > 64 && value < 71) value -= 55;\n            else return type(uint8).max;\n        }\n\n        return value;\n    }\n\n    /**\n     * @dev Escape special characters in JSON strings. This can be useful to prevent JSON injection in NFT metadata.\n     *\n     * WARNING: This function should only be used in double quoted JSON strings. Single quotes are not escaped.\n     *\n     * NOTE: This function escapes all unicode characters, and not just the ones in ranges defined in section 2.5 of\n     * RFC-4627 (U+0000 to U+001F, U+0022 and U+005C). ECMAScript's `JSON.parse` does recover escaped unicode\n     * characters that are not in this range, but other tooling may provide different results.\n     */\n    function escapeJSON(string memory input) internal pure returns (string memory) {\n        bytes memory buffer = bytes(input);\n        bytes memory output = new bytes(2 * buffer.length); // worst case scenario\n        uint256 outputLength = 0;\n\n        for (uint256 i; i < buffer.length; ++i) {\n            bytes1 char = bytes1(_unsafeReadBytesOffset(buffer, i));\n            if (((SPECIAL_CHARS_LOOKUP & (1 << uint8(char))) != 0)) {\n                output[outputLength++] = \"\\\\\";\n                if (char == 0x08) output[outputLength++] = \"b\";\n                else if (char == 0x09) output[outputLength++] = \"t\";\n                else if (char == 0x0a) output[outputLength++] = \"n\";\n                else if (char == 0x0c) output[outputLength++] = \"f\";\n                else if (char == 0x0d) output[outputLength++] = \"r\";\n                else if (char == 0x5c) output[outputLength++] = \"\\\\\";\n                else if (char == 0x22) {\n                    // solhint-disable-next-line quotes\n                    output[outputLength++] = '\"';\n                }\n            } else {\n                output[outputLength++] = char;\n            }\n        }\n        // write the actual length and deallocate unused memory\n        assembly (\"memory-safe\") {\n            mstore(output, outputLength)\n            mstore(0x40, add(output, shl(5, shr(5, add(outputLength, 63)))))\n        }\n\n        return string(output);\n    }\n\n    /**\n     * @dev Reads a bytes32 from a bytes array without bounds checking.\n     *\n     * NOTE: making this function internal would mean it could be used with memory unsafe offset, and marking the\n     * assembly block as such would prevent some optimizations.\n     */\n    function _unsafeReadBytesOffset(bytes memory buffer, uint256 offset) private pure returns (bytes32 value) {\n        // This is not memory safe in the general case, but all calls to this private function are within bounds.\n        assembly (\"memory-safe\") {\n            value := mload(add(add(buffer, 0x20), offset))\n        }\n    }\n}\n"
      },
      "npm/@openzeppelin/contracts@5.4.0/utils/structs/EnumerableSet.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.4.0) (utils/structs/EnumerableSet.sol)\n// This file was procedurally generated from scripts/generate/templates/EnumerableSet.js.\n\npragma solidity ^0.8.20;\n\nimport {Arrays} from \"../Arrays.sol\";\nimport {Math} from \"../math/Math.sol\";\n\n/**\n * @dev Library for managing\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\n * types.\n *\n * Sets have the following properties:\n *\n * - Elements are added, removed, and checked for existence in constant time\n * (O(1)).\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\n * - Set can be cleared (all elements removed) in O(n).\n *\n * ```solidity\n * contract Example {\n *     // Add the library methods\n *     using EnumerableSet for EnumerableSet.AddressSet;\n *\n *     // Declare a set state variable\n *     EnumerableSet.AddressSet private mySet;\n * }\n * ```\n *\n * The following types are supported:\n *\n * - `bytes32` (`Bytes32Set`) since v3.3.0\n * - `address` (`AddressSet`) since v3.3.0\n * - `uint256` (`UintSet`) since v3.3.0\n * - `string` (`StringSet`) since v5.4.0\n * - `bytes` (`BytesSet`) since v5.4.0\n *\n * [WARNING]\n * ====\n * Trying to delete such a structure from storage will likely result in data corruption, rendering the structure\n * unusable.\n * See https://github.com/ethereum/solidity/pull/11843[ethereum/solidity#11843] for more info.\n *\n * In order to clean an EnumerableSet, you can either remove all elements one by one or create a fresh instance using an\n * array of EnumerableSet.\n * ====\n */\nlibrary EnumerableSet {\n    // To implement this library for multiple types with as little code\n    // repetition as possible, we write it in terms of a generic Set type with\n    // bytes32 values.\n    // The Set implementation uses private functions, and user-facing\n    // implementations (such as AddressSet) are just wrappers around the\n    // underlying Set.\n    // This means that we can only create new EnumerableSets for types that fit\n    // in bytes32.\n\n    struct Set {\n        // Storage of set values\n        bytes32[] _values;\n        // Position is the index of the value in the `values` array plus 1.\n        // Position 0 is used to mean a value is not in the set.\n        mapping(bytes32 value => uint256) _positions;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function _add(Set storage set, bytes32 value) private returns (bool) {\n        if (!_contains(set, value)) {\n            set._values.push(value);\n            // The value is stored at length-1, but we add 1 to all indexes\n            // and use 0 as a sentinel value\n            set._positions[value] = set._values.length;\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\n        // We cache the value's position to prevent multiple reads from the same storage slot\n        uint256 position = set._positions[value];\n\n        if (position != 0) {\n            // Equivalent to contains(set, value)\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\n            // This modifies the order of the array, as noted in {at}.\n\n            uint256 valueIndex = position - 1;\n            uint256 lastIndex = set._values.length - 1;\n\n            if (valueIndex != lastIndex) {\n                bytes32 lastValue = set._values[lastIndex];\n\n                // Move the lastValue to the index where the value to delete is\n                set._values[valueIndex] = lastValue;\n                // Update the tracked position of the lastValue (that was just moved)\n                set._positions[lastValue] = position;\n            }\n\n            // Delete the slot where the moved value was stored\n            set._values.pop();\n\n            // Delete the tracked position for the deleted slot\n            delete set._positions[value];\n\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Removes all the values from a set. O(n).\n     *\n     * WARNING: This function has an unbounded cost that scales with set size. Developers should keep in mind that\n     * using it may render the function uncallable if the set grows to the point where clearing it consumes too much\n     * gas to fit in a block.\n     */\n    function _clear(Set storage set) private {\n        uint256 len = _length(set);\n        for (uint256 i = 0; i < len; ++i) {\n            delete set._positions[set._values[i]];\n        }\n        Arrays.unsafeSetLength(set._values, 0);\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\n        return set._positions[value] != 0;\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function _length(Set storage set) private view returns (uint256) {\n        return set._values.length;\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\n        return set._values[index];\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function _values(Set storage set) private view returns (bytes32[] memory) {\n        return set._values;\n    }\n\n    /**\n     * @dev Return a slice of the set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function _values(Set storage set, uint256 start, uint256 end) private view returns (bytes32[] memory) {\n        unchecked {\n            end = Math.min(end, _length(set));\n            start = Math.min(start, end);\n\n            uint256 len = end - start;\n            bytes32[] memory result = new bytes32[](len);\n            for (uint256 i = 0; i < len; ++i) {\n                result[i] = Arrays.unsafeAccess(set._values, start + i).value;\n            }\n            return result;\n        }\n    }\n\n    // Bytes32Set\n\n    struct Bytes32Set {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _add(set._inner, value);\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _remove(set._inner, value);\n    }\n\n    /**\n     * @dev Removes all the values from a set. O(n).\n     *\n     * WARNING: Developers should keep in mind that this function has an unbounded cost and using it may render the\n     * function uncallable if the set grows to the point where clearing it consumes too much gas to fit in a block.\n     */\n    function clear(Bytes32Set storage set) internal {\n        _clear(set._inner);\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\n        return _contains(set._inner, value);\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(Bytes32Set storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\n        return _at(set._inner, index);\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(Bytes32Set storage set) internal view returns (bytes32[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        bytes32[] memory result;\n\n        assembly (\"memory-safe\") {\n            result := store\n        }\n\n        return result;\n    }\n\n    /**\n     * @dev Return a slice of the set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(Bytes32Set storage set, uint256 start, uint256 end) internal view returns (bytes32[] memory) {\n        bytes32[] memory store = _values(set._inner, start, end);\n        bytes32[] memory result;\n\n        assembly (\"memory-safe\") {\n            result := store\n        }\n\n        return result;\n    }\n\n    // AddressSet\n\n    struct AddressSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(AddressSet storage set, address value) internal returns (bool) {\n        return _add(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(AddressSet storage set, address value) internal returns (bool) {\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Removes all the values from a set. O(n).\n     *\n     * WARNING: Developers should keep in mind that this function has an unbounded cost and using it may render the\n     * function uncallable if the set grows to the point where clearing it consumes too much gas to fit in a block.\n     */\n    function clear(AddressSet storage set) internal {\n        _clear(set._inner);\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(AddressSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\n        return address(uint160(uint256(_at(set._inner, index))));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(AddressSet storage set) internal view returns (address[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        address[] memory result;\n\n        assembly (\"memory-safe\") {\n            result := store\n        }\n\n        return result;\n    }\n\n    /**\n     * @dev Return a slice of the set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(AddressSet storage set, uint256 start, uint256 end) internal view returns (address[] memory) {\n        bytes32[] memory store = _values(set._inner, start, end);\n        address[] memory result;\n\n        assembly (\"memory-safe\") {\n            result := store\n        }\n\n        return result;\n    }\n\n    // UintSet\n\n    struct UintSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\n        return _add(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\n        return _remove(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Removes all the values from a set. O(n).\n     *\n     * WARNING: Developers should keep in mind that this function has an unbounded cost and using it may render the\n     * function uncallable if the set grows to the point where clearing it consumes too much gas to fit in a block.\n     */\n    function clear(UintSet storage set) internal {\n        _clear(set._inner);\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(UintSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\n        return uint256(_at(set._inner, index));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(UintSet storage set) internal view returns (uint256[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        uint256[] memory result;\n\n        assembly (\"memory-safe\") {\n            result := store\n        }\n\n        return result;\n    }\n\n    /**\n     * @dev Return a slice of the set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(UintSet storage set, uint256 start, uint256 end) internal view returns (uint256[] memory) {\n        bytes32[] memory store = _values(set._inner, start, end);\n        uint256[] memory result;\n\n        assembly (\"memory-safe\") {\n            result := store\n        }\n\n        return result;\n    }\n\n    struct StringSet {\n        // Storage of set values\n        string[] _values;\n        // Position is the index of the value in the `values` array plus 1.\n        // Position 0 is used to mean a value is not in the set.\n        mapping(string value => uint256) _positions;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(StringSet storage set, string memory value) internal returns (bool) {\n        if (!contains(set, value)) {\n            set._values.push(value);\n            // The value is stored at length-1, but we add 1 to all indexes\n            // and use 0 as a sentinel value\n            set._positions[value] = set._values.length;\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(StringSet storage set, string memory value) internal returns (bool) {\n        // We cache the value's position to prevent multiple reads from the same storage slot\n        uint256 position = set._positions[value];\n\n        if (position != 0) {\n            // Equivalent to contains(set, value)\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\n            // This modifies the order of the array, as noted in {at}.\n\n            uint256 valueIndex = position - 1;\n            uint256 lastIndex = set._values.length - 1;\n\n            if (valueIndex != lastIndex) {\n                string memory lastValue = set._values[lastIndex];\n\n                // Move the lastValue to the index where the value to delete is\n                set._values[valueIndex] = lastValue;\n                // Update the tracked position of the lastValue (that was just moved)\n                set._positions[lastValue] = position;\n            }\n\n            // Delete the slot where the moved value was stored\n            set._values.pop();\n\n            // Delete the tracked position for the deleted slot\n            delete set._positions[value];\n\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Removes all the values from a set. O(n).\n     *\n     * WARNING: Developers should keep in mind that this function has an unbounded cost and using it may render the\n     * function uncallable if the set grows to the point where clearing it consumes too much gas to fit in a block.\n     */\n    function clear(StringSet storage set) internal {\n        uint256 len = length(set);\n        for (uint256 i = 0; i < len; ++i) {\n            delete set._positions[set._values[i]];\n        }\n        Arrays.unsafeSetLength(set._values, 0);\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(StringSet storage set, string memory value) internal view returns (bool) {\n        return set._positions[value] != 0;\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function length(StringSet storage set) internal view returns (uint256) {\n        return set._values.length;\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(StringSet storage set, uint256 index) internal view returns (string memory) {\n        return set._values[index];\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(StringSet storage set) internal view returns (string[] memory) {\n        return set._values;\n    }\n\n    /**\n     * @dev Return a slice of the set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(StringSet storage set, uint256 start, uint256 end) internal view returns (string[] memory) {\n        unchecked {\n            end = Math.min(end, length(set));\n            start = Math.min(start, end);\n\n            uint256 len = end - start;\n            string[] memory result = new string[](len);\n            for (uint256 i = 0; i < len; ++i) {\n                result[i] = Arrays.unsafeAccess(set._values, start + i).value;\n            }\n            return result;\n        }\n    }\n\n    struct BytesSet {\n        // Storage of set values\n        bytes[] _values;\n        // Position is the index of the value in the `values` array plus 1.\n        // Position 0 is used to mean a value is not in the set.\n        mapping(bytes value => uint256) _positions;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(BytesSet storage set, bytes memory value) internal returns (bool) {\n        if (!contains(set, value)) {\n            set._values.push(value);\n            // The value is stored at length-1, but we add 1 to all indexes\n            // and use 0 as a sentinel value\n            set._positions[value] = set._values.length;\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(BytesSet storage set, bytes memory value) internal returns (bool) {\n        // We cache the value's position to prevent multiple reads from the same storage slot\n        uint256 position = set._positions[value];\n\n        if (position != 0) {\n            // Equivalent to contains(set, value)\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\n            // This modifies the order of the array, as noted in {at}.\n\n            uint256 valueIndex = position - 1;\n            uint256 lastIndex = set._values.length - 1;\n\n            if (valueIndex != lastIndex) {\n                bytes memory lastValue = set._values[lastIndex];\n\n                // Move the lastValue to the index where the value to delete is\n                set._values[valueIndex] = lastValue;\n                // Update the tracked position of the lastValue (that was just moved)\n                set._positions[lastValue] = position;\n            }\n\n            // Delete the slot where the moved value was stored\n            set._values.pop();\n\n            // Delete the tracked position for the deleted slot\n            delete set._positions[value];\n\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Removes all the values from a set. O(n).\n     *\n     * WARNING: Developers should keep in mind that this function has an unbounded cost and using it may render the\n     * function uncallable if the set grows to the point where clearing it consumes too much gas to fit in a block.\n     */\n    function clear(BytesSet storage set) internal {\n        uint256 len = length(set);\n        for (uint256 i = 0; i < len; ++i) {\n            delete set._positions[set._values[i]];\n        }\n        Arrays.unsafeSetLength(set._values, 0);\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(BytesSet storage set, bytes memory value) internal view returns (bool) {\n        return set._positions[value] != 0;\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function length(BytesSet storage set) internal view returns (uint256) {\n        return set._values.length;\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(BytesSet storage set, uint256 index) internal view returns (bytes memory) {\n        return set._values[index];\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(BytesSet storage set) internal view returns (bytes[] memory) {\n        return set._values;\n    }\n\n    /**\n     * @dev Return a slice of the set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(BytesSet storage set, uint256 start, uint256 end) internal view returns (bytes[] memory) {\n        unchecked {\n            end = Math.min(end, length(set));\n            start = Math.min(start, end);\n\n            uint256 len = end - start;\n            bytes[] memory result = new bytes[](len);\n            for (uint256 i = 0; i < len; ++i) {\n                result[i] = Arrays.unsafeAccess(set._values, start + i).value;\n            }\n            return result;\n        }\n    }\n}\n"
      },
      "npm/@scroll-tech/contracts@2.0.1/L1/IL1ScrollMessenger.sol": {
        "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.24;\n\nimport {IScrollMessenger} from \"../libraries/IScrollMessenger.sol\";\n\ninterface IL1ScrollMessenger is IScrollMessenger {\n    /**********\n     * Events *\n     **********/\n\n    /// @notice Emitted when the maximum number of times each message can be replayed is updated.\n    /// @param oldMaxReplayTimes The old maximum number of times each message can be replayed.\n    /// @param newMaxReplayTimes The new maximum number of times each message can be replayed.\n    event UpdateMaxReplayTimes(uint256 oldMaxReplayTimes, uint256 newMaxReplayTimes);\n\n    /***********\n     * Structs *\n     ***********/\n\n    struct L2MessageProof {\n        // The index of the batch where the message belongs to.\n        uint256 batchIndex;\n        // Concatenation of merkle proof for withdraw merkle trie.\n        bytes merkleProof;\n    }\n\n    /*****************************\n     * Public Mutating Functions *\n     *****************************/\n\n    /// @notice Relay a L2 => L1 message with message proof.\n    /// @param from The address of the sender of the message.\n    /// @param to The address of the recipient of the message.\n    /// @param value The msg.value passed to the message call.\n    /// @param nonce The nonce of the message to avoid replay attack.\n    /// @param message The content of the message.\n    /// @param proof The proof used to verify the correctness of the transaction.\n    function relayMessageWithProof(\n        address from,\n        address to,\n        uint256 value,\n        uint256 nonce,\n        bytes memory message,\n        L2MessageProof memory proof\n    ) external;\n\n    /// @notice Replay an existing message.\n    /// @param from The address of the sender of the message.\n    /// @param to The address of the recipient of the message.\n    /// @param value The msg.value passed to the message call.\n    /// @param messageNonce The nonce for the message to replay.\n    /// @param message The content of the message.\n    /// @param newGasLimit New gas limit to be used for this message.\n    /// @param refundAddress The address of account who will receive the refunded fee.\n    function replayMessage(\n        address from,\n        address to,\n        uint256 value,\n        uint256 messageNonce,\n        bytes memory message,\n        uint32 newGasLimit,\n        address refundAddress\n    ) external payable;\n\n    /// @notice Drop a skipped message.\n    /// @param from The address of the sender of the message.\n    /// @param to The address of the recipient of the message.\n    /// @param value The msg.value passed to the message call.\n    /// @param messageNonce The nonce for the message to drop.\n    /// @param message The content of the message.\n    function dropMessage(\n        address from,\n        address to,\n        uint256 value,\n        uint256 messageNonce,\n        bytes memory message\n    ) external;\n}\n"
      },
      "npm/@scroll-tech/contracts@2.0.1/L2/IL2ScrollMessenger.sol": {
        "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.24;\n\nimport {IScrollMessenger} from \"../libraries/IScrollMessenger.sol\";\n\ninterface IL2ScrollMessenger is IScrollMessenger {\n    /**********\n     * Events *\n     **********/\n\n    /// @notice Emitted when the maximum number of times each message can fail in L2 is updated.\n    /// @param oldMaxFailedExecutionTimes The old maximum number of times each message can fail in L2.\n    /// @param newMaxFailedExecutionTimes The new maximum number of times each message can fail in L2.\n    event UpdateMaxFailedExecutionTimes(uint256 oldMaxFailedExecutionTimes, uint256 newMaxFailedExecutionTimes);\n\n    /*****************************\n     * Public Mutating Functions *\n     *****************************/\n\n    /// @notice execute L1 => L2 message\n    /// @dev Make sure this is only called by privileged accounts.\n    /// @param from The address of the sender of the message.\n    /// @param to The address of the recipient of the message.\n    /// @param value The msg.value passed to the message call.\n    /// @param nonce The nonce of the message to avoid replay attack.\n    /// @param message The content of the message.\n    function relayMessage(\n        address from,\n        address to,\n        uint256 value,\n        uint256 nonce,\n        bytes calldata message\n    ) external;\n}\n"
      },
      "npm/@scroll-tech/contracts@2.0.1/libraries/IScrollMessenger.sol": {
        "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.24;\n\ninterface IScrollMessenger {\n    /**********\n     * Events *\n     **********/\n\n    /// @notice Emitted when a cross domain message is sent.\n    /// @param sender The address of the sender who initiates the message.\n    /// @param target The address of target contract to call.\n    /// @param value The amount of value passed to the target contract.\n    /// @param messageNonce The nonce of the message.\n    /// @param gasLimit The optional gas limit passed to L1 or L2.\n    /// @param message The calldata passed to the target contract.\n    event SentMessage(\n        address indexed sender,\n        address indexed target,\n        uint256 value,\n        uint256 messageNonce,\n        uint256 gasLimit,\n        bytes message\n    );\n\n    /// @notice Emitted when a cross domain message is relayed successfully.\n    /// @param messageHash The hash of the message.\n    event RelayedMessage(bytes32 indexed messageHash);\n\n    /// @notice Emitted when a cross domain message is failed to relay.\n    /// @param messageHash The hash of the message.\n    event FailedRelayedMessage(bytes32 indexed messageHash);\n\n    /**********\n     * Errors *\n     **********/\n\n    /// @dev Thrown when the given address is `address(0)`.\n    error ErrorZeroAddress();\n\n    /*************************\n     * Public View Functions *\n     *************************/\n\n    /// @notice Return the sender of a cross domain message.\n    function xDomainMessageSender() external view returns (address);\n\n    /*****************************\n     * Public Mutating Functions *\n     *****************************/\n\n    /// @notice Send cross chain message from L1 to L2 or L2 to L1.\n    /// @param target The address of account who receive the message.\n    /// @param value The amount of ether passed when call target contract.\n    /// @param message The content of the message.\n    /// @param gasLimit Gas limit required to complete the message relay on corresponding chain.\n    function sendMessage(\n        address target,\n        uint256 value,\n        bytes calldata message,\n        uint256 gasLimit\n    ) external payable;\n\n    /// @notice Send cross chain message from L1 to L2 or L2 to L1.\n    /// @param target The address of account who receive the message.\n    /// @param value The amount of ether passed when call target contract.\n    /// @param message The content of the message.\n    /// @param gasLimit Gas limit required to complete the message relay on corresponding chain.\n    /// @param refundAddress The address of account who will receive the refunded fee.\n    function sendMessage(\n        address target,\n        uint256 value,\n        bytes calldata message,\n        uint256 gasLimit,\n        address refundAddress\n    ) external payable;\n}\n"
      },
      "npm/@zk-kit/lazy-imt.sol@2.0.0-beta.12/Constants.sol": {
        "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.4;\n\nuint256 constant SNARK_SCALAR_FIELD = 21888242871839275222246405745257275088548364400416034343698204186575808495617;\nuint8 constant MAX_DEPTH = 32;\n"
      },
      "npm/@zk-kit/lazy-imt.sol@2.0.0-beta.12/InternalLazyIMT.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport {PoseidonT3} from \"poseidon-solidity/PoseidonT3.sol\";\nimport {SNARK_SCALAR_FIELD, MAX_DEPTH} from \"./Constants.sol\";\n\nstruct LazyIMTData {\n    uint40 maxIndex;\n    uint40 numberOfLeaves;\n    mapping(uint256 => uint256) elements;\n}\n\nlibrary InternalLazyIMT {\n    uint40 internal constant MAX_INDEX = (1 << 32) - 1;\n\n    uint256 internal constant Z_0 = 0;\n    uint256 internal constant Z_1 = 14744269619966411208579211824598458697587494354926760081771325075741142829156;\n    uint256 internal constant Z_2 = 7423237065226347324353380772367382631490014989348495481811164164159255474657;\n    uint256 internal constant Z_3 = 11286972368698509976183087595462810875513684078608517520839298933882497716792;\n    uint256 internal constant Z_4 = 3607627140608796879659380071776844901612302623152076817094415224584923813162;\n    uint256 internal constant Z_5 = 19712377064642672829441595136074946683621277828620209496774504837737984048981;\n    uint256 internal constant Z_6 = 20775607673010627194014556968476266066927294572720319469184847051418138353016;\n    uint256 internal constant Z_7 = 3396914609616007258851405644437304192397291162432396347162513310381425243293;\n    uint256 internal constant Z_8 = 21551820661461729022865262380882070649935529853313286572328683688269863701601;\n    uint256 internal constant Z_9 = 6573136701248752079028194407151022595060682063033565181951145966236778420039;\n    uint256 internal constant Z_10 = 12413880268183407374852357075976609371175688755676981206018884971008854919922;\n    uint256 internal constant Z_11 = 14271763308400718165336499097156975241954733520325982997864342600795471836726;\n    uint256 internal constant Z_12 = 20066985985293572387227381049700832219069292839614107140851619262827735677018;\n    uint256 internal constant Z_13 = 9394776414966240069580838672673694685292165040808226440647796406499139370960;\n    uint256 internal constant Z_14 = 11331146992410411304059858900317123658895005918277453009197229807340014528524;\n    uint256 internal constant Z_15 = 15819538789928229930262697811477882737253464456578333862691129291651619515538;\n    uint256 internal constant Z_16 = 19217088683336594659449020493828377907203207941212636669271704950158751593251;\n    uint256 internal constant Z_17 = 21035245323335827719745544373081896983162834604456827698288649288827293579666;\n    uint256 internal constant Z_18 = 6939770416153240137322503476966641397417391950902474480970945462551409848591;\n    uint256 internal constant Z_19 = 10941962436777715901943463195175331263348098796018438960955633645115732864202;\n    uint256 internal constant Z_20 = 15019797232609675441998260052101280400536945603062888308240081994073687793470;\n    uint256 internal constant Z_21 = 11702828337982203149177882813338547876343922920234831094975924378932809409969;\n    uint256 internal constant Z_22 = 11217067736778784455593535811108456786943573747466706329920902520905755780395;\n    uint256 internal constant Z_23 = 16072238744996205792852194127671441602062027943016727953216607508365787157389;\n    uint256 internal constant Z_24 = 17681057402012993898104192736393849603097507831571622013521167331642182653248;\n    uint256 internal constant Z_25 = 21694045479371014653083846597424257852691458318143380497809004364947786214945;\n    uint256 internal constant Z_26 = 8163447297445169709687354538480474434591144168767135863541048304198280615192;\n    uint256 internal constant Z_27 = 14081762237856300239452543304351251708585712948734528663957353575674639038357;\n    uint256 internal constant Z_28 = 16619959921569409661790279042024627172199214148318086837362003702249041851090;\n    uint256 internal constant Z_29 = 7022159125197495734384997711896547675021391130223237843255817587255104160365;\n    uint256 internal constant Z_30 = 4114686047564160449611603615418567457008101555090703535405891656262658644463;\n    uint256 internal constant Z_31 = 12549363297364877722388257367377629555213421373705596078299904496781819142130;\n    uint256 internal constant Z_32 = 21443572485391568159800782191812935835534334817699172242223315142338162256601;\n\n    function _defaultZero(uint8 index) internal pure returns (uint256) {\n        if (index == 0) return Z_0;\n        if (index == 1) return Z_1;\n        if (index == 2) return Z_2;\n        if (index == 3) return Z_3;\n        if (index == 4) return Z_4;\n        if (index == 5) return Z_5;\n        if (index == 6) return Z_6;\n        if (index == 7) return Z_7;\n        if (index == 8) return Z_8;\n        if (index == 9) return Z_9;\n        if (index == 10) return Z_10;\n        if (index == 11) return Z_11;\n        if (index == 12) return Z_12;\n        if (index == 13) return Z_13;\n        if (index == 14) return Z_14;\n        if (index == 15) return Z_15;\n        if (index == 16) return Z_16;\n        if (index == 17) return Z_17;\n        if (index == 18) return Z_18;\n        if (index == 19) return Z_19;\n        if (index == 20) return Z_20;\n        if (index == 21) return Z_21;\n        if (index == 22) return Z_22;\n        if (index == 23) return Z_23;\n        if (index == 24) return Z_24;\n        if (index == 25) return Z_25;\n        if (index == 26) return Z_26;\n        if (index == 27) return Z_27;\n        if (index == 28) return Z_28;\n        if (index == 29) return Z_29;\n        if (index == 30) return Z_30;\n        if (index == 31) return Z_31;\n        if (index == 32) return Z_32;\n        revert(\"LazyIMT: defaultZero bad index\");\n    }\n\n    function _init(LazyIMTData storage self, uint8 depth) internal {\n        require(depth <= MAX_DEPTH, \"LazyIMT: Tree too large\");\n        self.maxIndex = uint40((1 << depth) - 1);\n        self.numberOfLeaves = 0;\n    }\n\n    function _reset(LazyIMTData storage self) internal {\n        self.numberOfLeaves = 0;\n    }\n\n    function _indexForElement(uint8 level, uint40 index) internal pure returns (uint40) {\n        // store the elements sparsely\n        return MAX_INDEX * level + index;\n    }\n\n    function _insert(LazyIMTData storage self, uint256 leaf) internal {\n        uint40 index = self.numberOfLeaves;\n        require(leaf < SNARK_SCALAR_FIELD, \"LazyIMT: leaf must be < SNARK_SCALAR_FIELD\");\n        require(index < self.maxIndex, \"LazyIMT: tree is full\");\n\n        self.numberOfLeaves = index + 1;\n\n        uint256 hash = leaf;\n\n        for (uint8 i = 0; ; ) {\n            self.elements[_indexForElement(i, index)] = hash;\n            // it's a left element so we don't hash until there's a right element\n            if (index & 1 == 0) break;\n            uint40 elementIndex = _indexForElement(i, index - 1);\n            hash = PoseidonT3.hash([self.elements[elementIndex], hash]);\n            unchecked {\n                index >>= 1;\n                i++;\n            }\n        }\n    }\n\n    function _update(LazyIMTData storage self, uint256 leaf, uint40 index) internal {\n        require(leaf < SNARK_SCALAR_FIELD, \"LazyIMT: leaf must be < SNARK_SCALAR_FIELD\");\n        uint40 numberOfLeaves = self.numberOfLeaves;\n        require(index < numberOfLeaves, \"LazyIMT: leaf must exist\");\n\n        uint256 hash = leaf;\n\n        for (uint8 i = 0; true; ) {\n            self.elements[_indexForElement(i, index)] = hash;\n            uint256 levelCount = numberOfLeaves >> (i + 1);\n            if (levelCount <= index >> 1) break;\n            if (index & 1 == 0) {\n                uint40 elementIndex = _indexForElement(i, index + 1);\n                hash = PoseidonT3.hash([hash, self.elements[elementIndex]]);\n            } else {\n                uint40 elementIndex = _indexForElement(i, index - 1);\n                hash = PoseidonT3.hash([self.elements[elementIndex], hash]);\n            }\n            unchecked {\n                index >>= 1;\n                i++;\n            }\n        }\n    }\n\n    function _root(LazyIMTData storage self) internal view returns (uint256) {\n        // this will always short circuit if self.numberOfLeaves == 0\n        uint40 numberOfLeaves = self.numberOfLeaves;\n        // dynamically determine a depth\n        uint8 depth = 1;\n        while (uint40(2) ** uint40(depth) < numberOfLeaves) {\n            depth++;\n        }\n        return _root(self, numberOfLeaves, depth);\n    }\n\n    function _root(LazyIMTData storage self, uint8 depth) internal view returns (uint256) {\n        require(depth > 0, \"LazyIMT: depth must be > 0\");\n        require(depth <= MAX_DEPTH, \"LazyIMT: depth must be <= MAX_DEPTH\");\n        uint40 numberOfLeaves = self.numberOfLeaves;\n        require(uint40(2) ** uint40(depth) >= numberOfLeaves, \"LazyIMT: ambiguous depth\");\n        return _root(self, numberOfLeaves, depth);\n    }\n\n    // Here it's assumed that the depth value is valid. If it is either 0 or > 2^8-1\n    // this function will panic.\n    function _root(LazyIMTData storage self, uint40 numberOfLeaves, uint8 depth) internal view returns (uint256) {\n        require(depth <= MAX_DEPTH, \"LazyIMT: depth must be <= MAX_DEPTH\");\n        // this should always short circuit if self.numberOfLeaves == 0\n        if (numberOfLeaves == 0) return _defaultZero(depth);\n        uint256[] memory levels = new uint256[](depth + 1);\n        _levels(self, numberOfLeaves, depth, levels);\n        return levels[depth];\n    }\n\n    function _levels(\n        LazyIMTData storage self,\n        uint40 numberOfLeaves,\n        uint8 depth,\n        uint256[] memory levels\n    ) internal view {\n        require(depth <= MAX_DEPTH, \"LazyIMT: depth must be <= MAX_DEPTH\");\n        require(numberOfLeaves > 0, \"LazyIMT: number of leaves must be > 0\");\n        // this should always short circuit if self.numberOfLeaves == 0\n        uint40 index = numberOfLeaves - 1;\n\n        if (index & 1 == 0) {\n            levels[0] = self.elements[_indexForElement(0, index)];\n        } else {\n            levels[0] = _defaultZero(0);\n        }\n\n        for (uint8 i = 0; i < depth; ) {\n            if (index & 1 == 0) {\n                levels[i + 1] = PoseidonT3.hash([levels[i], _defaultZero(i)]);\n            } else {\n                uint256 levelCount = (numberOfLeaves) >> (i + 1);\n                if (levelCount > index >> 1) {\n                    uint256 parent = self.elements[_indexForElement(i + 1, index >> 1)];\n                    levels[i + 1] = parent;\n                } else {\n                    uint256 sibling = self.elements[_indexForElement(i, index - 1)];\n                    levels[i + 1] = PoseidonT3.hash([sibling, levels[i]]);\n                }\n            }\n            unchecked {\n                index >>= 1;\n                i++;\n            }\n        }\n    }\n\n    function _merkleProofElements(\n        LazyIMTData storage self,\n        uint40 index,\n        uint8 depth\n    ) internal view returns (uint256[] memory) {\n        uint40 numberOfLeaves = self.numberOfLeaves;\n        require(index < numberOfLeaves, \"LazyIMT: leaf must exist\");\n\n        uint8 targetDepth = 1;\n        while (uint40(2) ** uint40(targetDepth) < numberOfLeaves) {\n            targetDepth++;\n        }\n        require(depth >= targetDepth, \"LazyIMT: proof depth\");\n        // pass depth -1 because we don't need the root value\n        uint256[] memory _elements = new uint256[](depth);\n        _levels(self, numberOfLeaves, targetDepth - 1, _elements);\n\n        // unroll the bottom entry of the tree because it will never need to\n        // be pulled from _levels\n        if (index & 1 == 0) {\n            if (index + 1 >= numberOfLeaves) {\n                _elements[0] = _defaultZero(0);\n            } else {\n                _elements[0] = self.elements[_indexForElement(0, index + 1)];\n            }\n        } else {\n            _elements[0] = self.elements[_indexForElement(0, index - 1)];\n        }\n        index >>= 1;\n\n        for (uint8 i = 1; i < depth; ) {\n            uint256 currentLevelCount = numberOfLeaves >> i;\n            if (index & 1 == 0) {\n                // if the element is an uncomputed edge node we'll use the value set\n                // from _levels above\n                // otherwise set as usual below\n                if (index + 1 < currentLevelCount) {\n                    _elements[i] = self.elements[_indexForElement(i, index + 1)];\n                } else if (((numberOfLeaves - 1) >> i) <= index) {\n                    _elements[i] = _defaultZero(i);\n                }\n            } else {\n                _elements[i] = self.elements[_indexForElement(i, index - 1)];\n            }\n            unchecked {\n                index >>= 1;\n                i++;\n            }\n        }\n        return _elements;\n    }\n}\n"
      },
      "npm/@zk-kit/lazy-imt.sol@2.0.0-beta.12/LazyIMT.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport {InternalLazyIMT, LazyIMTData} from \"./InternalLazyIMT.sol\";\n\nlibrary LazyIMT {\n    using InternalLazyIMT for *;\n\n    function init(LazyIMTData storage self, uint8 depth) public {\n        InternalLazyIMT._init(self, depth);\n    }\n\n    function defaultZero(uint8 index) public pure returns (uint256) {\n        return InternalLazyIMT._defaultZero(index);\n    }\n\n    function reset(LazyIMTData storage self) public {\n        InternalLazyIMT._reset(self);\n    }\n\n    function indexForElement(uint8 level, uint40 index) public pure returns (uint40) {\n        return InternalLazyIMT._indexForElement(level, index);\n    }\n\n    function insert(LazyIMTData storage self, uint256 leaf) public {\n        InternalLazyIMT._insert(self, leaf);\n    }\n\n    function update(LazyIMTData storage self, uint256 leaf, uint40 index) public {\n        InternalLazyIMT._update(self, leaf, index);\n    }\n\n    function root(LazyIMTData storage self) public view returns (uint256) {\n        return InternalLazyIMT._root(self);\n    }\n\n    function root(LazyIMTData storage self, uint8 depth) public view returns (uint256) {\n        return InternalLazyIMT._root(self, depth);\n    }\n\n    function merkleProofElements(\n        LazyIMTData storage self,\n        uint40 index,\n        uint8 depth\n    ) public view returns (uint256[] memory) {\n        return InternalLazyIMT._merkleProofElements(self, index, depth);\n    }\n\n    function _root(LazyIMTData storage self, uint40 numberOfLeaves, uint8 depth) internal view returns (uint256) {\n        return InternalLazyIMT._root(self, numberOfLeaves, depth);\n    }\n}\n"
      },
      "npm/poseidon-solidity@0.0.5/PoseidonT3.sol": {
        "content": "/// SPDX-License-Identifier: MIT\npragma solidity >=0.7.0;\n\nlibrary PoseidonT3 {\n  uint constant M00 = 0x109b7f411ba0e4c9b2b70caf5c36a7b194be7c11ad24378bfedb68592ba8118b;\n  uint constant M01 = 0x2969f27eed31a480b9c36c764379dbca2cc8fdd1415c3dded62940bcde0bd771;\n  uint constant M02 = 0x143021ec686a3f330d5f9e654638065ce6cd79e28c5b3753326244ee65a1b1a7;\n  uint constant M10 = 0x16ed41e13bb9c0c66ae119424fddbcbc9314dc9fdbdeea55d6c64543dc4903e0;\n  uint constant M11 = 0x2e2419f9ec02ec394c9871c832963dc1b89d743c8c7b964029b2311687b1fe23;\n  uint constant M12 = 0x176cc029695ad02582a70eff08a6fd99d057e12e58e7d7b6b16cdfabc8ee2911;\n\n  // See here for a simplified implementation: https://github.com/vimwitch/poseidon-solidity/blob/e57becdabb65d99fdc586fe1e1e09e7108202d53/contracts/Poseidon.sol#L40\n  // Inspired by: https://github.com/iden3/circomlibjs/blob/v0.0.8/src/poseidon_slow.js\n  function hash(uint[2] memory) public pure returns (uint) {\n    assembly {\n      let F := 21888242871839275222246405745257275088548364400416034343698204186575808495617\n      let M20 := 0x2b90bba00fca0589f617e7dcbfe82e0df706ab640ceb247b791a93b74e36736d\n      let M21 := 0x101071f0032379b697315876690f053d148d4e109f5fb065c8aacc55a0f89bfa\n      let M22 := 0x19a3fc0a56702bf417ba7fee3802593fa644470307043f7773279cd71d25d5e0\n\n      // load the inputs from memory\n      let state1 := add(mod(mload(0x80), F), 0x00f1445235f2148c5986587169fc1bcd887b08d4d00868df5696fff40956e864)\n      let state2 := add(mod(mload(0xa0), F), 0x08dff3487e8ac99e1f29a058d0fa80b930c728730b7ab36ce879f3890ecf73f5)\n      let scratch0 := mulmod(state1, state1, F)\n      state1 := mulmod(mulmod(scratch0, scratch0, F), state1, F)\n      scratch0 := mulmod(state2, state2, F)\n      state2 := mulmod(mulmod(scratch0, scratch0, F), state2, F)\n      scratch0 := add(\n        0x2f27be690fdaee46c3ce28f7532b13c856c35342c84bda6e20966310fadc01d0,\n        add(add(15452833169820924772166449970675545095234312153403844297388521437673434406763, mulmod(state1, M10, F)), mulmod(state2, M20, F))\n      )\n      let scratch1 := add(\n        0x2b2ae1acf68b7b8d2416bebf3d4f6234b763fe04b8043ee48b8327bebca16cf2,\n        add(add(18674271267752038776579386132900109523609358935013267566297499497165104279117, mulmod(state1, M11, F)), mulmod(state2, M21, F))\n      )\n      let scratch2 := add(\n        0x0319d062072bef7ecca5eac06f97d4d55952c175ab6b03eae64b44c7dbf11cfa,\n        add(add(14817777843080276494683266178512808687156649753153012854386334860566696099579, mulmod(state1, M12, F)), mulmod(state2, M22, F))\n      )\n      let state0 := mulmod(scratch0, scratch0, F)\n      scratch0 := mulmod(mulmod(state0, state0, F), scratch0, F)\n      state0 := mulmod(scratch1, scratch1, F)\n      scratch1 := mulmod(mulmod(state0, state0, F), scratch1, F)\n      state0 := mulmod(scratch2, scratch2, F)\n      scratch2 := mulmod(mulmod(state0, state0, F), scratch2, F)\n      state0 := add(0x28813dcaebaeaa828a376df87af4a63bc8b7bf27ad49c6298ef7b387bf28526d, add(add(mulmod(scratch0, M00, F), mulmod(scratch1, M10, F)), mulmod(scratch2, M20, F)))\n      state1 := add(0x2727673b2ccbc903f181bf38e1c1d40d2033865200c352bc150928adddf9cb78, add(add(mulmod(scratch0, M01, F), mulmod(scratch1, M11, F)), mulmod(scratch2, M21, F)))\n      state2 := add(0x234ec45ca27727c2e74abd2b2a1494cd6efbd43e340587d6b8fb9e31e65cc632, add(add(mulmod(scratch0, M02, F), mulmod(scratch1, M12, F)), mulmod(scratch2, M22, F)))\n      scratch0 := mulmod(state0, state0, F)\n      state0 := mulmod(mulmod(scratch0, scratch0, F), state0, F)\n      scratch0 := mulmod(state1, state1, F)\n      state1 := mulmod(mulmod(scratch0, scratch0, F), state1, F)\n      scratch0 := mulmod(state2, state2, F)\n      state2 := mulmod(mulmod(scratch0, scratch0, F), state2, F)\n      scratch0 := add(0x15b52534031ae18f7f862cb2cf7cf760ab10a8150a337b1ccd99ff6e8797d428, add(add(mulmod(state0, M00, F), mulmod(state1, M10, F)), mulmod(state2, M20, F)))\n      scratch1 := add(0x0dc8fad6d9e4b35f5ed9a3d186b79ce38e0e8a8d1b58b132d701d4eecf68d1f6, add(add(mulmod(state0, M01, F), mulmod(state1, M11, F)), mulmod(state2, M21, F)))\n      scratch2 := add(0x1bcd95ffc211fbca600f705fad3fb567ea4eb378f62e1fec97805518a47e4d9c, add(add(mulmod(state0, M02, F), mulmod(state1, M12, F)), mulmod(state2, M22, F)))\n      state0 := mulmod(scratch0, scratch0, F)\n      scratch0 := mulmod(mulmod(state0, state0, F), scratch0, F)\n      state0 := mulmod(scratch1, scratch1, F)\n      scratch1 := mulmod(mulmod(state0, state0, F), scratch1, F)\n      state0 := mulmod(scratch2, scratch2, F)\n      scratch2 := mulmod(mulmod(state0, state0, F), scratch2, F)\n      state0 := add(0x10520b0ab721cadfe9eff81b016fc34dc76da36c2578937817cb978d069de559, add(add(mulmod(scratch0, M00, F), mulmod(scratch1, M10, F)), mulmod(scratch2, M20, F)))\n      state1 := add(0x1f6d48149b8e7f7d9b257d8ed5fbbaf42932498075fed0ace88a9eb81f5627f6, add(add(mulmod(scratch0, M01, F), mulmod(scratch1, M11, F)), mulmod(scratch2, M21, F)))\n      state2 := add(0x1d9655f652309014d29e00ef35a2089bfff8dc1c816f0dc9ca34bdb5460c8705, add(add(mulmod(scratch0, M02, F), mulmod(scratch1, M12, F)), mulmod(scratch2, M22, F)))\n      scratch0 := mulmod(state0, state0, F)\n      state0 := mulmod(mulmod(scratch0, scratch0, F), state0, F)\n      scratch0 := add(0x04df5a56ff95bcafb051f7b1cd43a99ba731ff67e47032058fe3d4185697cc7d, add(add(mulmod(state0, M00, F), mulmod(state1, M10, F)), mulmod(state2, M20, F)))\n      scratch1 := add(0x0672d995f8fff640151b3d290cedaf148690a10a8c8424a7f6ec282b6e4be828, add(add(mulmod(state0, M01, F), mulmod(state1, M11, F)), mulmod(state2, M21, F)))\n      scratch2 := add(0x099952b414884454b21200d7ffafdd5f0c9a9dcc06f2708e9fc1d8209b5c75b9, add(add(mulmod(state0, M02, F), mulmod(state1, M12, F)), mulmod(state2, M22, F)))\n      state0 := mulmod(scratch0, scratch0, F)\n      scratch0 := mulmod(mulmod(state0, state0, F), scratch0, F)\n      state0 := add(0x052cba2255dfd00c7c483143ba8d469448e43586a9b4cd9183fd0e843a6b9fa6, add(add(mulmod(scratch0, M00, F), mulmod(scratch1, M10, F)), mulmod(scratch2, M20, F)))\n      state1 := add(0x0b8badee690adb8eb0bd74712b7999af82de55707251ad7716077cb93c464ddc, add(add(mulmod(scratch0, M01, F), mulmod(scratch1, M11, F)), mulmod(scratch2, M21, F)))\n      state2 := add(0x119b1590f13307af5a1ee651020c07c749c15d60683a8050b963d0a8e4b2bdd1, add(add(mulmod(scratch0, M02, F), mulmod(scratch1, M12, F)), mulmod(scratch2, M22, F)))\n      scratch0 := mulmod(state0, state0, F)\n      state0 := mulmod(mulmod(scratch0, scratch0, F), state0, F)\n      scratch0 := add(0x03150b7cd6d5d17b2529d36be0f67b832c4acfc884ef4ee5ce15be0bfb4a8d09, add(add(mulmod(state0, M00, F), mulmod(state1, M10, F)), mulmod(state2, M20, F)))\n      scratch1 := add(0x2cc6182c5e14546e3cf1951f173912355374efb83d80898abe69cb317c9ea565, add(add(mulmod(state0, M01, F), mulmod(state1, M11, F)), mulmod(state2, M21, F)))\n      scratch2 := add(0x005032551e6378c450cfe129a404b3764218cadedac14e2b92d2cd73111bf0f9, add(add(mulmod(state0, M02, F), mulmod(state1, M12, F)), mulmod(state2, M22, F)))\n      state0 := mulmod(scratch0, scratch0, F)\n      scratch0 := mulmod(mulmod(state0, state0, F), scratch0, F)\n      state0 := add(0x233237e3289baa34bb147e972ebcb9516469c399fcc069fb88f9da2cc28276b5, add(add(mulmod(scratch0, M00, F), mulmod(scratch1, M10, F)), mulmod(scratch2, M20, F)))\n      state1 := add(0x05c8f4f4ebd4a6e3c980d31674bfbe6323037f21b34ae5a4e80c2d4c24d60280, add(add(mulmod(scratch0, M01, F), mulmod(scratch1, M11, F)), mulmod(scratch2, M21, F)))\n      state2 := add(0x0a7b1db13042d396ba05d818a319f25252bcf35ef3aeed91ee1f09b2590fc65b, add(add(mulmod(scratch0, M02, F), mulmod(scratch1, M12, F)), mulmod(scratch2, M22, F)))\n      scratch0 := mulmod(state0, state0, F)\n      state0 := mulmod(mulmod(scratch0, scratch0, F), state0, F)\n      scratch0 := add(0x2a73b71f9b210cf5b14296572c9d32dbf156e2b086ff47dc5df542365a404ec0, add(add(mulmod(state0, M00, F), mulmod(state1, M10, F)), mulmod(state2, M20, F)))\n      scratch1 := add(0x1ac9b0417abcc9a1935107e9ffc91dc3ec18f2c4dbe7f22976a760bb5c50c460, add(add(mulmod(state0, M01, F), mulmod(state1, M11, F)), mulmod(state2, M21, F)))\n      scratch2 := add(0x12c0339ae08374823fabb076707ef479269f3e4d6cb104349015ee046dc93fc0, add(add(mulmod(state0, M02, F), mulmod(state1, M12, F)), mulmod(state2, M22, F)))\n      state0 := mulmod(scratch0, scratch0, F)\n      scratch0 := mulmod(mulmod(state0, state0, F), scratch0, F)\n      state0 := add(0x0b7475b102a165ad7f5b18db4e1e704f52900aa3253baac68246682e56e9a28e, add(add(mulmod(scratch0, M00, F), mulmod(scratch1, M10, F)), mulmod(scratch2, M20, F)))\n      state1 := add(0x037c2849e191ca3edb1c5e49f6e8b8917c843e379366f2ea32ab3aa88d7f8448, add(add(mulmod(scratch0, M01, F), mulmod(scratch1, M11, F)), mulmod(scratch2, M21, F)))\n      state2 := add(0x05a6811f8556f014e92674661e217e9bd5206c5c93a07dc145fdb176a716346f, add(add(mulmod(scratch0, M02, F), mulmod(scratch1, M12, F)), mulmod(scratch2, M22, F)))\n      scratch0 := mulmod(state0, state0, F)\n      state0 := mulmod(mulmod(scratch0, scratch0, F), state0, F)\n      scratch0 := add(0x29a795e7d98028946e947b75d54e9f044076e87a7b2883b47b675ef5f38bd66e, add(add(mulmod(state0, M00, F), mulmod(state1, M10, F)), mulmod(state2, M20, F)))\n      scratch1 := add(0x20439a0c84b322eb45a3857afc18f5826e8c7382c8a1585c507be199981fd22f, add(add(mulmod(state0, M01, F), mulmod(state1, M11, F)), mulmod(state2, M21, F)))\n      scratch2 := add(0x2e0ba8d94d9ecf4a94ec2050c7371ff1bb50f27799a84b6d4a2a6f2a0982c887, add(add(mulmod(state0, M02, F), mulmod(state1, M12, F)), mulmod(state2, M22, F)))\n      state0 := mulmod(scratch0, scratch0, F)\n      scratch0 := mulmod(mulmod(state0, state0, F), scratch0, F)\n      state0 := add(0x143fd115ce08fb27ca38eb7cce822b4517822cd2109048d2e6d0ddcca17d71c8, add(add(mulmod(scratch0, M00, F), mulmod(scratch1, M10, F)), mulmod(scratch2, M20, F)))\n      state1 := add(0x0c64cbecb1c734b857968dbbdcf813cdf8611659323dbcbfc84323623be9caf1, add(add(mulmod(scratch0, M01, F), mulmod(scratch1, M11, F)), mulmod(scratch2, M21, F)))\n      state2 := add(0x028a305847c683f646fca925c163ff5ae74f348d62c2b670f1426cef9403da53, add(add(mulmod(scratch0, M02, F), mulmod(scratch1, M12, F)), mulmod(scratch2, M22, F)))\n      scratch0 := mulmod(state0, state0, F)\n      state0 := mulmod(mulmod(scratch0, scratch0, F), state0, F)\n      scratch0 := add(0x2e4ef510ff0b6fda5fa940ab4c4380f26a6bcb64d89427b824d6755b5db9e30c, add(add(mulmod(state0, M00, F), mulmod(state1, M10, F)), mulmod(state2, M20, F)))\n      scratch1 := add(0x0081c95bc43384e663d79270c956ce3b8925b4f6d033b078b96384f50579400e, add(add(mulmod(state0, M01, F), mulmod(state1, M11, F)), mulmod(state2, M21, F)))\n      scratch2 := add(0x2ed5f0c91cbd9749187e2fade687e05ee2491b349c039a0bba8a9f4023a0bb38, add(add(mulmod(state0, M02, F), mulmod(state1, M12, F)), mulmod(state2, M22, F)))\n      state0 := mulmod(scratch0, scratch0, F)\n      scratch0 := mulmod(mulmod(state0, state0, F), scratch0, F)\n      state0 := add(0x30509991f88da3504bbf374ed5aae2f03448a22c76234c8c990f01f33a735206, add(add(mulmod(scratch0, M00, F), mulmod(scratch1, M10, F)), mulmod(scratch2, M20, F)))\n      state1 := add(0x1c3f20fd55409a53221b7c4d49a356b9f0a1119fb2067b41a7529094424ec6ad, add(add(mulmod(scratch0, M01, F), mulmod(scratch1, M11, F)), mulmod(scratch2, M21, F)))\n      state2 := add(0x10b4e7f3ab5df003049514459b6e18eec46bb2213e8e131e170887b47ddcb96c, add(add(mulmod(scratch0, M02, F), mulmod(scratch1, M12, F)), mulmod(scratch2, M22, F)))\n      scratch0 := mulmod(state0, state0, F)\n      state0 := mulmod(mulmod(scratch0, scratch0, F), state0, F)\n      scratch0 := add(0x2a1982979c3ff7f43ddd543d891c2abddd80f804c077d775039aa3502e43adef, add(add(mulmod(state0, M00, F), mulmod(state1, M10, F)), mulmod(state2, M20, F)))\n      scratch1 := add(0x1c74ee64f15e1db6feddbead56d6d55dba431ebc396c9af95cad0f1315bd5c91, add(add(mulmod(state0, M01, F), mulmod(state1, M11, F)), mulmod(state2, M21, F)))\n      scratch2 := add(0x07533ec850ba7f98eab9303cace01b4b9e4f2e8b82708cfa9c2fe45a0ae146a0, add(add(mulmod(state0, M02, F), mulmod(state1, M12, F)), mulmod(state2, M22, F)))\n      state0 := mulmod(scratch0, scratch0, F)\n      scratch0 := mulmod(mulmod(state0, state0, F), scratch0, F)\n      state0 := add(0x21576b438e500449a151e4eeaf17b154285c68f42d42c1808a11abf3764c0750, add(add(mulmod(scratch0, M00, F), mulmod(scratch1, M10, F)), mulmod(scratch2, M20, F)))\n      state1 := add(0x2f17c0559b8fe79608ad5ca193d62f10bce8384c815f0906743d6930836d4a9e, add(add(mulmod(scratch0, M01, F), mulmod(scratch1, M11, F)), mulmod(scratch2, M21, F)))\n      state2 := add(0x2d477e3862d07708a79e8aae946170bc9775a4201318474ae665b0b1b7e2730e, add(add(mulmod(scratch0, M02, F), mulmod(scratch1, M12, F)), mulmod(scratch2, M22, F)))\n      scratch0 := mulmod(state0, state0, F)\n      state0 := mulmod(mulmod(scratch0, scratch0, F), state0, F)\n      scratch0 := add(0x162f5243967064c390e095577984f291afba2266c38f5abcd89be0f5b2747eab, add(add(mulmod(state0, M00, F), mulmod(state1, M10, F)), mulmod(state2, M20, F)))\n      scratch1 := add(0x2b4cb233ede9ba48264ecd2c8ae50d1ad7a8596a87f29f8a7777a70092393311, add(add(mulmod(state0, M01, F), mulmod(state1, M11, F)), mulmod(state2, M21, F)))\n      scratch2 := add(0x2c8fbcb2dd8573dc1dbaf8f4622854776db2eece6d85c4cf4254e7c35e03b07a, add(add(mulmod(state0, M02, F), mulmod(state1, M12, F)), mulmod(state2, M22, F)))\n      state0 := mulmod(scratch0, scratch0, F)\n      scratch0 := mulmod(mulmod(state0, state0, F), scratch0, F)\n      state0 := add(0x1d6f347725e4816af2ff453f0cd56b199e1b61e9f601e9ade5e88db870949da9, add(add(mulmod(scratch0, M00, F), mulmod(scratch1, M10, F)), mulmod(scratch2, M20, F)))\n      state1 := add(0x204b0c397f4ebe71ebc2d8b3df5b913df9e6ac02b68d31324cd49af5c4565529, add(add(mulmod(scratch0, M01, F), mulmod(scratch1, M11, F)), mulmod(scratch2, M21, F)))\n      state2 := add(0x0c4cb9dc3c4fd8174f1149b3c63c3c2f9ecb827cd7dc25534ff8fb75bc79c502, add(add(mulmod(scratch0, M02, F), mulmod(scratch1, M12, F)), mulmod(scratch2, M22, F)))\n      scratch0 := mulmod(state0, state0, F)\n      state0 := mulmod(mulmod(scratch0, scratch0, F), state0, F)\n      scratch0 := add(0x174ad61a1448c899a25416474f4930301e5c49475279e0639a616ddc45bc7b54, add(add(mulmod(state0, M00, F), mulmod(state1, M10, F)), mulmod(state2, M20, F)))\n      scratch1 := add(0x1a96177bcf4d8d89f759df4ec2f3cde2eaaa28c177cc0fa13a9816d49a38d2ef, add(add(mulmod(state0, M01, F), mulmod(state1, M11, F)), mulmod(state2, M21, F)))\n      scratch2 := add(0x066d04b24331d71cd0ef8054bc60c4ff05202c126a233c1a8242ace360b8a30a, add(add(mulmod(state0, M02, F), mulmod(state1, M12, F)), mulmod(state2, M22, F)))\n      state0 := mulmod(scratch0, scratch0, F)\n      scratch0 := mulmod(mulmod(state0, state0, F), scratch0, F)\n      state0 := add(0x2a4c4fc6ec0b0cf52195782871c6dd3b381cc65f72e02ad527037a62aa1bd804, add(add(mulmod(scratch0, M00, F), mulmod(scratch1, M10, F)), mulmod(scratch2, M20, F)))\n      state1 := add(0x13ab2d136ccf37d447e9f2e14a7cedc95e727f8446f6d9d7e55afc01219fd649, add(add(mulmod(scratch0, M01, F), mulmod(scratch1, M11, F)), mulmod(scratch2, M21, F)))\n      state2 := add(0x1121552fca26061619d24d843dc82769c1b04fcec26f55194c2e3e869acc6a9a, add(add(mulmod(scratch0, M02, F), mulmod(scratch1, M12, F)), mulmod(scratch2, M22, F)))\n      scratch0 := mulmod(state0, state0, F)\n      state0 := mulmod(mulmod(scratch0, scratch0, F), state0, F)\n      scratch0 := add(0x00ef653322b13d6c889bc81715c37d77a6cd267d595c4a8909a5546c7c97cff1, add(add(mulmod(state0, M00, F), mulmod(state1, M10, F)), mulmod(state2, M20, F)))\n      scratch1 := add(0x0e25483e45a665208b261d8ba74051e6400c776d652595d9845aca35d8a397d3, add(add(mulmod(state0, M01, F), mulmod(state1, M11, F)), mulmod(state2, M21, F)))\n      scratch2 := add(0x29f536dcb9dd7682245264659e15d88e395ac3d4dde92d8c46448db979eeba89, add(add(mulmod(state0, M02, F), mulmod(state1, M12, F)), mulmod(state2, M22, F)))\n      state0 := mulmod(scratch0, scratch0, F)\n      scratch0 := mulmod(mulmod(state0, state0, F), scratch0, F)\n      state0 := add(0x2a56ef9f2c53febadfda33575dbdbd885a124e2780bbea170e456baace0fa5be, add(add(mulmod(scratch0, M00, F), mulmod(scratch1, M10, F)), mulmod(scratch2, M20, F)))\n      state1 := add(0x1c8361c78eb5cf5decfb7a2d17b5c409f2ae2999a46762e8ee416240a8cb9af1, add(add(mulmod(scratch0, M01, F), mulmod(scratch1, M11, F)), mulmod(scratch2, M21, F)))\n      state2 := add(0x151aff5f38b20a0fc0473089aaf0206b83e8e68a764507bfd3d0ab4be74319c5, add(add(mulmod(scratch0, M02, F), mulmod(scratch1, M12, F)), mulmod(scratch2, M22, F)))\n      scratch0 := mulmod(state0, state0, F)\n      state0 := mulmod(mulmod(scratch0, scratch0, F), state0, F)\n      scratch0 := add(0x04c6187e41ed881dc1b239c88f7f9d43a9f52fc8c8b6cdd1e76e47615b51f100, add(add(mulmod(state0, M00, F), mulmod(state1, M10, F)), mulmod(state2, M20, F)))\n      scratch1 := add(0x13b37bd80f4d27fb10d84331f6fb6d534b81c61ed15776449e801b7ddc9c2967, add(add(mulmod(state0, M01, F), mulmod(state1, M11, F)), mulmod(state2, M21, F)))\n      scratch2 := add(0x01a5c536273c2d9df578bfbd32c17b7a2ce3664c2a52032c9321ceb1c4e8a8e4, add(add(mulmod(state0, M02, F), mulmod(state1, M12, F)), mulmod(state2, M22, F)))\n      state0 := mulmod(scratch0, scratch0, F)\n      scratch0 := mulmod(mulmod(state0, state0, F), scratch0, F)\n      state0 := add(0x2ab3561834ca73835ad05f5d7acb950b4a9a2c666b9726da832239065b7c3b02, add(add(mulmod(scratch0, M00, F), mulmod(scratch1, M10, F)), mulmod(scratch2, M20, F)))\n      state1 := add(0x1d4d8ec291e720db200fe6d686c0d613acaf6af4e95d3bf69f7ed516a597b646, add(add(mulmod(scratch0, M01, F), mulmod(scratch1, M11, F)), mulmod(scratch2, M21, F)))\n      state2 := add(0x041294d2cc484d228f5784fe7919fd2bb925351240a04b711514c9c80b65af1d, add(add(mulmod(scratch0, M02, F), mulmod(scratch1, M12, F)), mulmod(scratch2, M22, F)))\n      scratch0 := mulmod(state0, state0, F)\n      state0 := mulmod(mulmod(scratch0, scratch0, F), state0, F)\n      scratch0 := add(0x154ac98e01708c611c4fa715991f004898f57939d126e392042971dd90e81fc6, add(add(mulmod(state0, M00, F), mulmod(state1, M10, F)), mulmod(state2, M20, F)))\n      scratch1 := add(0x0b339d8acca7d4f83eedd84093aef51050b3684c88f8b0b04524563bc6ea4da4, add(add(mulmod(state0, M01, F), mulmod(state1, M11, F)), mulmod(state2, M21, F)))\n      scratch2 := add(0x0955e49e6610c94254a4f84cfbab344598f0e71eaff4a7dd81ed95b50839c82e, add(add(mulmod(state0, M02, F), mulmod(state1, M12, F)), mulmod(state2, M22, F)))\n      state0 := mulmod(scratch0, scratch0, F)\n      scratch0 := mulmod(mulmod(state0, state0, F), scratch0, F)\n      state0 := add(0x06746a6156eba54426b9e22206f15abca9a6f41e6f535c6f3525401ea0654626, add(add(mulmod(scratch0, M00, F), mulmod(scratch1, M10, F)), mulmod(scratch2, M20, F)))\n      state1 := add(0x0f18f5a0ecd1423c496f3820c549c27838e5790e2bd0a196ac917c7ff32077fb, add(add(mulmod(scratch0, M01, F), mulmod(scratch1, M11, F)), mulmod(scratch2, M21, F)))\n      state2 := add(0x04f6eeca1751f7308ac59eff5beb261e4bb563583ede7bc92a738223d6f76e13, add(add(mulmod(scratch0, M02, F), mulmod(scratch1, M12, F)), mulmod(scratch2, M22, F)))\n      scratch0 := mulmod(state0, state0, F)\n      state0 := mulmod(mulmod(scratch0, scratch0, F), state0, F)\n      scratch0 := add(0x2b56973364c4c4f5c1a3ec4da3cdce038811eb116fb3e45bc1768d26fc0b3758, add(add(mulmod(state0, M00, F), mulmod(state1, M10, F)), mulmod(state2, M20, F)))\n      scratch1 := add(0x123769dd49d5b054dcd76b89804b1bcb8e1392b385716a5d83feb65d437f29ef, add(add(mulmod(state0, M01, F), mulmod(state1, M11, F)), mulmod(state2, M21, F)))\n      scratch2 := add(0x2147b424fc48c80a88ee52b91169aacea989f6446471150994257b2fb01c63e9, add(add(mulmod(state0, M02, F), mulmod(state1, M12, F)), mulmod(state2, M22, F)))\n      state0 := mulmod(scratch0, scratch0, F)\n      scratch0 := mulmod(mulmod(state0, state0, F), scratch0, F)\n      state0 := add(0x0fdc1f58548b85701a6c5505ea332a29647e6f34ad4243c2ea54ad897cebe54d, add(add(mulmod(scratch0, M00, F), mulmod(scratch1, M10, F)), mulmod(scratch2, M20, F)))\n      state1 := add(0x12373a8251fea004df68abcf0f7786d4bceff28c5dbbe0c3944f685cc0a0b1f2, add(add(mulmod(scratch0, M01, F), mulmod(scratch1, M11, F)), mulmod(scratch2, M21, F)))\n      state2 := add(0x21e4f4ea5f35f85bad7ea52ff742c9e8a642756b6af44203dd8a1f35c1a90035, add(add(mulmod(scratch0, M02, F), mulmod(scratch1, M12, F)), mulmod(scratch2, M22, F)))\n      scratch0 := mulmod(state0, state0, F)\n      state0 := mulmod(mulmod(scratch0, scratch0, F), state0, F)\n      scratch0 := add(0x16243916d69d2ca3dfb4722224d4c462b57366492f45e90d8a81934f1bc3b147, add(add(mulmod(state0, M00, F), mulmod(state1, M10, F)), mulmod(state2, M20, F)))\n      scratch1 := add(0x1efbe46dd7a578b4f66f9adbc88b4378abc21566e1a0453ca13a4159cac04ac2, add(add(mulmod(state0, M01, F), mulmod(state1, M11, F)), mulmod(state2, M21, F)))\n      scratch2 := add(0x07ea5e8537cf5dd08886020e23a7f387d468d5525be66f853b672cc96a88969a, add(add(mulmod(state0, M02, F), mulmod(state1, M12, F)), mulmod(state2, M22, F)))\n      state0 := mulmod(scratch0, scratch0, F)\n      scratch0 := mulmod(mulmod(state0, state0, F), scratch0, F)\n      state0 := add(0x05a8c4f9968b8aa3b7b478a30f9a5b63650f19a75e7ce11ca9fe16c0b76c00bc, add(add(mulmod(scratch0, M00, F), mulmod(scratch1, M10, F)), mulmod(scratch2, M20, F)))\n      state1 := add(0x20f057712cc21654fbfe59bd345e8dac3f7818c701b9c7882d9d57b72a32e83f, add(add(mulmod(scratch0, M01, F), mulmod(scratch1, M11, F)), mulmod(scratch2, M21, F)))\n      state2 := add(0x04a12ededa9dfd689672f8c67fee31636dcd8e88d01d49019bd90b33eb33db69, add(add(mulmod(scratch0, M02, F), mulmod(scratch1, M12, F)), mulmod(scratch2, M22, F)))\n      scratch0 := mulmod(state0, state0, F)\n      state0 := mulmod(mulmod(scratch0, scratch0, F), state0, F)\n      scratch0 := add(0x27e88d8c15f37dcee44f1e5425a51decbd136ce5091a6767e49ec9544ccd101a, add(add(mulmod(state0, M00, F), mulmod(state1, M10, F)), mulmod(state2, M20, F)))\n      scratch1 := add(0x2feed17b84285ed9b8a5c8c5e95a41f66e096619a7703223176c41ee433de4d1, add(add(mulmod(state0, M01, F), mulmod(state1, M11, F)), mulmod(state2, M21, F)))\n      scratch2 := add(0x1ed7cc76edf45c7c404241420f729cf394e5942911312a0d6972b8bd53aff2b8, add(add(mulmod(state0, M02, F), mulmod(state1, M12, F)), mulmod(state2, M22, F)))\n      state0 := mulmod(scratch0, scratch0, F)\n      scratch0 := mulmod(mulmod(state0, state0, F), scratch0, F)\n      state0 := add(0x15742e99b9bfa323157ff8c586f5660eac6783476144cdcadf2874be45466b1a, add(add(mulmod(scratch0, M00, F), mulmod(scratch1, M10, F)), mulmod(scratch2, M20, F)))\n      state1 := add(0x1aac285387f65e82c895fc6887ddf40577107454c6ec0317284f033f27d0c785, add(add(mulmod(scratch0, M01, F), mulmod(scratch1, M11, F)), mulmod(scratch2, M21, F)))\n      state2 := add(0x25851c3c845d4790f9ddadbdb6057357832e2e7a49775f71ec75a96554d67c77, add(add(mulmod(scratch0, M02, F), mulmod(scratch1, M12, F)), mulmod(scratch2, M22, F)))\n      scratch0 := mulmod(state0, state0, F)\n      state0 := mulmod(mulmod(scratch0, scratch0, F), state0, F)\n      scratch0 := add(0x15a5821565cc2ec2ce78457db197edf353b7ebba2c5523370ddccc3d9f146a67, add(add(mulmod(state0, M00, F), mulmod(state1, M10, F)), mulmod(state2, M20, F)))\n      scratch1 := add(0x2411d57a4813b9980efa7e31a1db5966dcf64f36044277502f15485f28c71727, add(add(mulmod(state0, M01, F), mulmod(state1, M11, F)), mulmod(state2, M21, F)))\n      scratch2 := add(0x002e6f8d6520cd4713e335b8c0b6d2e647e9a98e12f4cd2558828b5ef6cb4c9b, add(add(mulmod(state0, M02, F), mulmod(state1, M12, F)), mulmod(state2, M22, F)))\n      state0 := mulmod(scratch0, scratch0, F)\n      scratch0 := mulmod(mulmod(state0, state0, F), scratch0, F)\n      state0 := add(0x2ff7bc8f4380cde997da00b616b0fcd1af8f0e91e2fe1ed7398834609e0315d2, add(add(mulmod(scratch0, M00, F), mulmod(scratch1, M10, F)), mulmod(scratch2, M20, F)))\n      state1 := add(0x00b9831b948525595ee02724471bcd182e9521f6b7bb68f1e93be4febb0d3cbe, add(add(mulmod(scratch0, M01, F), mulmod(scratch1, M11, F)), mulmod(scratch2, M21, F)))\n      state2 := add(0x0a2f53768b8ebf6a86913b0e57c04e011ca408648a4743a87d77adbf0c9c3512, add(add(mulmod(scratch0, M02, F), mulmod(scratch1, M12, F)), mulmod(scratch2, M22, F)))\n      scratch0 := mulmod(state0, state0, F)\n      state0 := mulmod(mulmod(scratch0, scratch0, F), state0, F)\n      scratch0 := add(0x00248156142fd0373a479f91ff239e960f599ff7e94be69b7f2a290305e1198d, add(add(mulmod(state0, M00, F), mulmod(state1, M10, F)), mulmod(state2, M20, F)))\n      scratch1 := add(0x171d5620b87bfb1328cf8c02ab3f0c9a397196aa6a542c2350eb512a2b2bcda9, add(add(mulmod(state0, M01, F), mulmod(state1, M11, F)), mulmod(state2, M21, F)))\n      scratch2 := add(0x170a4f55536f7dc970087c7c10d6fad760c952172dd54dd99d1045e4ec34a808, add(add(mulmod(state0, M02, F), mulmod(state1, M12, F)), mulmod(state2, M22, F)))\n      state0 := mulmod(scratch0, scratch0, F)\n      scratch0 := mulmod(mulmod(state0, state0, F), scratch0, F)\n      state0 := add(0x29aba33f799fe66c2ef3134aea04336ecc37e38c1cd211ba482eca17e2dbfae1, add(add(mulmod(scratch0, M00, F), mulmod(scratch1, M10, F)), mulmod(scratch2, M20, F)))\n      state1 := add(0x1e9bc179a4fdd758fdd1bb1945088d47e70d114a03f6a0e8b5ba650369e64973, add(add(mulmod(scratch0, M01, F), mulmod(scratch1, M11, F)), mulmod(scratch2, M21, F)))\n      state2 := add(0x1dd269799b660fad58f7f4892dfb0b5afeaad869a9c4b44f9c9e1c43bdaf8f09, add(add(mulmod(scratch0, M02, F), mulmod(scratch1, M12, F)), mulmod(scratch2, M22, F)))\n      scratch0 := mulmod(state0, state0, F)\n      state0 := mulmod(mulmod(scratch0, scratch0, F), state0, F)\n      scratch0 := add(0x22cdbc8b70117ad1401181d02e15459e7ccd426fe869c7c95d1dd2cb0f24af38, add(add(mulmod(state0, M00, F), mulmod(state1, M10, F)), mulmod(state2, M20, F)))\n      scratch1 := add(0x0ef042e454771c533a9f57a55c503fcefd3150f52ed94a7cd5ba93b9c7dacefd, add(add(mulmod(state0, M01, F), mulmod(state1, M11, F)), mulmod(state2, M21, F)))\n      scratch2 := add(0x11609e06ad6c8fe2f287f3036037e8851318e8b08a0359a03b304ffca62e8284, add(add(mulmod(state0, M02, F), mulmod(state1, M12, F)), mulmod(state2, M22, F)))\n      state0 := mulmod(scratch0, scratch0, F)\n      scratch0 := mulmod(mulmod(state0, state0, F), scratch0, F)\n      state0 := add(0x1166d9e554616dba9e753eea427c17b7fecd58c076dfe42708b08f5b783aa9af, add(add(mulmod(scratch0, M00, F), mulmod(scratch1, M10, F)), mulmod(scratch2, M20, F)))\n      state1 := add(0x2de52989431a859593413026354413db177fbf4cd2ac0b56f855a888357ee466, add(add(mulmod(scratch0, M01, F), mulmod(scratch1, M11, F)), mulmod(scratch2, M21, F)))\n      state2 := add(0x3006eb4ffc7a85819a6da492f3a8ac1df51aee5b17b8e89d74bf01cf5f71e9ad, add(add(mulmod(scratch0, M02, F), mulmod(scratch1, M12, F)), mulmod(scratch2, M22, F)))\n      scratch0 := mulmod(state0, state0, F)\n      state0 := mulmod(mulmod(scratch0, scratch0, F), state0, F)\n      scratch0 := add(0x2af41fbb61ba8a80fdcf6fff9e3f6f422993fe8f0a4639f962344c8225145086, add(add(mulmod(state0, M00, F), mulmod(state1, M10, F)), mulmod(state2, M20, F)))\n      scratch1 := add(0x119e684de476155fe5a6b41a8ebc85db8718ab27889e85e781b214bace4827c3, add(add(mulmod(state0, M01, F), mulmod(state1, M11, F)), mulmod(state2, M21, F)))\n      scratch2 := add(0x1835b786e2e8925e188bea59ae363537b51248c23828f047cff784b97b3fd800, add(add(mulmod(state0, M02, F), mulmod(state1, M12, F)), mulmod(state2, M22, F)))\n      state0 := mulmod(scratch0, scratch0, F)\n      scratch0 := mulmod(mulmod(state0, state0, F), scratch0, F)\n      state0 := add(0x28201a34c594dfa34d794996c6433a20d152bac2a7905c926c40e285ab32eeb6, add(add(mulmod(scratch0, M00, F), mulmod(scratch1, M10, F)), mulmod(scratch2, M20, F)))\n      state1 := add(0x083efd7a27d1751094e80fefaf78b000864c82eb571187724a761f88c22cc4e7, add(add(mulmod(scratch0, M01, F), mulmod(scratch1, M11, F)), mulmod(scratch2, M21, F)))\n      state2 := add(0x0b6f88a3577199526158e61ceea27be811c16df7774dd8519e079564f61fd13b, add(add(mulmod(scratch0, M02, F), mulmod(scratch1, M12, F)), mulmod(scratch2, M22, F)))\n      scratch0 := mulmod(state0, state0, F)\n      state0 := mulmod(mulmod(scratch0, scratch0, F), state0, F)\n      scratch0 := add(0x0ec868e6d15e51d9644f66e1d6471a94589511ca00d29e1014390e6ee4254f5b, add(add(mulmod(state0, M00, F), mulmod(state1, M10, F)), mulmod(state2, M20, F)))\n      scratch1 := add(0x2af33e3f866771271ac0c9b3ed2e1142ecd3e74b939cd40d00d937ab84c98591, add(add(mulmod(state0, M01, F), mulmod(state1, M11, F)), mulmod(state2, M21, F)))\n      scratch2 := add(0x0b520211f904b5e7d09b5d961c6ace7734568c547dd6858b364ce5e47951f178, add(add(mulmod(state0, M02, F), mulmod(state1, M12, F)), mulmod(state2, M22, F)))\n      state0 := mulmod(scratch0, scratch0, F)\n      scratch0 := mulmod(mulmod(state0, state0, F), scratch0, F)\n      state0 := add(0x0b2d722d0919a1aad8db58f10062a92ea0c56ac4270e822cca228620188a1d40, add(add(mulmod(scratch0, M00, F), mulmod(scratch1, M10, F)), mulmod(scratch2, M20, F)))\n      state1 := add(0x1f790d4d7f8cf094d980ceb37c2453e957b54a9991ca38bbe0061d1ed6e562d4, add(add(mulmod(scratch0, M01, F), mulmod(scratch1, M11, F)), mulmod(scratch2, M21, F)))\n      state2 := add(0x0171eb95dfbf7d1eaea97cd385f780150885c16235a2a6a8da92ceb01e504233, add(add(mulmod(scratch0, M02, F), mulmod(scratch1, M12, F)), mulmod(scratch2, M22, F)))\n      scratch0 := mulmod(state0, state0, F)\n      state0 := mulmod(mulmod(scratch0, scratch0, F), state0, F)\n      scratch0 := add(0x0c2d0e3b5fd57549329bf6885da66b9b790b40defd2c8650762305381b168873, add(add(mulmod(state0, M00, F), mulmod(state1, M10, F)), mulmod(state2, M20, F)))\n      scratch1 := add(0x1162fb28689c27154e5a8228b4e72b377cbcafa589e283c35d3803054407a18d, add(add(mulmod(state0, M01, F), mulmod(state1, M11, F)), mulmod(state2, M21, F)))\n      scratch2 := add(0x2f1459b65dee441b64ad386a91e8310f282c5a92a89e19921623ef8249711bc0, add(add(mulmod(state0, M02, F), mulmod(state1, M12, F)), mulmod(state2, M22, F)))\n      state0 := mulmod(scratch0, scratch0, F)\n      scratch0 := mulmod(mulmod(state0, state0, F), scratch0, F)\n      state0 := add(0x1e6ff3216b688c3d996d74367d5cd4c1bc489d46754eb712c243f70d1b53cfbb, add(add(mulmod(scratch0, M00, F), mulmod(scratch1, M10, F)), mulmod(scratch2, M20, F)))\n      state1 := add(0x01ca8be73832b8d0681487d27d157802d741a6f36cdc2a0576881f9326478875, add(add(mulmod(scratch0, M01, F), mulmod(scratch1, M11, F)), mulmod(scratch2, M21, F)))\n      state2 := add(0x1f7735706ffe9fc586f976d5bdf223dc680286080b10cea00b9b5de315f9650e, add(add(mulmod(scratch0, M02, F), mulmod(scratch1, M12, F)), mulmod(scratch2, M22, F)))\n      scratch0 := mulmod(state0, state0, F)\n      state0 := mulmod(mulmod(scratch0, scratch0, F), state0, F)\n      scratch0 := add(0x2522b60f4ea3307640a0c2dce041fba921ac10a3d5f096ef4745ca838285f019, add(add(mulmod(state0, M00, F), mulmod(state1, M10, F)), mulmod(state2, M20, F)))\n      scratch1 := add(0x23f0bee001b1029d5255075ddc957f833418cad4f52b6c3f8ce16c235572575b, add(add(mulmod(state0, M01, F), mulmod(state1, M11, F)), mulmod(state2, M21, F)))\n      scratch2 := add(0x2bc1ae8b8ddbb81fcaac2d44555ed5685d142633e9df905f66d9401093082d59, add(add(mulmod(state0, M02, F), mulmod(state1, M12, F)), mulmod(state2, M22, F)))\n      state0 := mulmod(scratch0, scratch0, F)\n      scratch0 := mulmod(mulmod(state0, state0, F), scratch0, F)\n      state0 := add(0x0f9406b8296564a37304507b8dba3ed162371273a07b1fc98011fcd6ad72205f, add(add(mulmod(scratch0, M00, F), mulmod(scratch1, M10, F)), mulmod(scratch2, M20, F)))\n      state1 := add(0x2360a8eb0cc7defa67b72998de90714e17e75b174a52ee4acb126c8cd995f0a8, add(add(mulmod(scratch0, M01, F), mulmod(scratch1, M11, F)), mulmod(scratch2, M21, F)))\n      state2 := add(0x15871a5cddead976804c803cbaef255eb4815a5e96df8b006dcbbc2767f88948, add(add(mulmod(scratch0, M02, F), mulmod(scratch1, M12, F)), mulmod(scratch2, M22, F)))\n      scratch0 := mulmod(state0, state0, F)\n      state0 := mulmod(mulmod(scratch0, scratch0, F), state0, F)\n      scratch0 := add(0x193a56766998ee9e0a8652dd2f3b1da0362f4f54f72379544f957ccdeefb420f, add(add(mulmod(state0, M00, F), mulmod(state1, M10, F)), mulmod(state2, M20, F)))\n      scratch1 := add(0x2a394a43934f86982f9be56ff4fab1703b2e63c8ad334834e4309805e777ae0f, add(add(mulmod(state0, M01, F), mulmod(state1, M11, F)), mulmod(state2, M21, F)))\n      scratch2 := add(0x1859954cfeb8695f3e8b635dcb345192892cd11223443ba7b4166e8876c0d142, add(add(mulmod(state0, M02, F), mulmod(state1, M12, F)), mulmod(state2, M22, F)))\n      state0 := mulmod(scratch0, scratch0, F)\n      scratch0 := mulmod(mulmod(state0, state0, F), scratch0, F)\n      state0 := add(0x04e1181763050e58013444dbcb99f1902b11bc25d90bbdca408d3819f4fed32b, add(add(mulmod(scratch0, M00, F), mulmod(scratch1, M10, F)), mulmod(scratch2, M20, F)))\n      state1 := add(0x0fdb253dee83869d40c335ea64de8c5bb10eb82db08b5e8b1f5e5552bfd05f23, add(add(mulmod(scratch0, M01, F), mulmod(scratch1, M11, F)), mulmod(scratch2, M21, F)))\n      state2 := add(0x058cbe8a9a5027bdaa4efb623adead6275f08686f1c08984a9d7c5bae9b4f1c0, add(add(mulmod(scratch0, M02, F), mulmod(scratch1, M12, F)), mulmod(scratch2, M22, F)))\n      scratch0 := mulmod(state0, state0, F)\n      state0 := mulmod(mulmod(scratch0, scratch0, F), state0, F)\n      scratch0 := add(0x1382edce9971e186497eadb1aeb1f52b23b4b83bef023ab0d15228b4cceca59a, add(add(mulmod(state0, M00, F), mulmod(state1, M10, F)), mulmod(state2, M20, F)))\n      scratch1 := add(0x03464990f045c6ee0819ca51fd11b0be7f61b8eb99f14b77e1e6634601d9e8b5, add(add(mulmod(state0, M01, F), mulmod(state1, M11, F)), mulmod(state2, M21, F)))\n      scratch2 := add(0x23f7bfc8720dc296fff33b41f98ff83c6fcab4605db2eb5aaa5bc137aeb70a58, add(add(mulmod(state0, M02, F), mulmod(state1, M12, F)), mulmod(state2, M22, F)))\n      state0 := mulmod(scratch0, scratch0, F)\n      scratch0 := mulmod(mulmod(state0, state0, F), scratch0, F)\n      state0 := add(0x0a59a158e3eec2117e6e94e7f0e9decf18c3ffd5e1531a9219636158bbaf62f2, add(add(mulmod(scratch0, M00, F), mulmod(scratch1, M10, F)), mulmod(scratch2, M20, F)))\n      state1 := add(0x06ec54c80381c052b58bf23b312ffd3ce2c4eba065420af8f4c23ed0075fd07b, add(add(mulmod(scratch0, M01, F), mulmod(scratch1, M11, F)), mulmod(scratch2, M21, F)))\n      state2 := add(0x118872dc832e0eb5476b56648e867ec8b09340f7a7bcb1b4962f0ff9ed1f9d01, add(add(mulmod(scratch0, M02, F), mulmod(scratch1, M12, F)), mulmod(scratch2, M22, F)))\n      scratch0 := mulmod(state0, state0, F)\n      state0 := mulmod(mulmod(scratch0, scratch0, F), state0, F)\n      scratch0 := add(0x13d69fa127d834165ad5c7cba7ad59ed52e0b0f0e42d7fea95e1906b520921b1, add(add(mulmod(state0, M00, F), mulmod(state1, M10, F)), mulmod(state2, M20, F)))\n      scratch1 := add(0x169a177f63ea681270b1c6877a73d21bde143942fb71dc55fd8a49f19f10c77b, add(add(mulmod(state0, M01, F), mulmod(state1, M11, F)), mulmod(state2, M21, F)))\n      scratch2 := add(0x04ef51591c6ead97ef42f287adce40d93abeb032b922f66ffb7e9a5a7450544d, add(add(mulmod(state0, M02, F), mulmod(state1, M12, F)), mulmod(state2, M22, F)))\n      state0 := mulmod(scratch0, scratch0, F)\n      scratch0 := mulmod(mulmod(state0, state0, F), scratch0, F)\n      state0 := add(0x256e175a1dc079390ecd7ca703fb2e3b19ec61805d4f03ced5f45ee6dd0f69ec, add(add(mulmod(scratch0, M00, F), mulmod(scratch1, M10, F)), mulmod(scratch2, M20, F)))\n      state1 := add(0x30102d28636abd5fe5f2af412ff6004f75cc360d3205dd2da002813d3e2ceeb2, add(add(mulmod(scratch0, M01, F), mulmod(scratch1, M11, F)), mulmod(scratch2, M21, F)))\n      state2 := add(0x10998e42dfcd3bbf1c0714bc73eb1bf40443a3fa99bef4a31fd31be182fcc792, add(add(mulmod(scratch0, M02, F), mulmod(scratch1, M12, F)), mulmod(scratch2, M22, F)))\n      scratch0 := mulmod(state0, state0, F)\n      state0 := mulmod(mulmod(scratch0, scratch0, F), state0, F)\n      scratch0 := add(0x193edd8e9fcf3d7625fa7d24b598a1d89f3362eaf4d582efecad76f879e36860, add(add(mulmod(state0, M00, F), mulmod(state1, M10, F)), mulmod(state2, M20, F)))\n      scratch1 := add(0x18168afd34f2d915d0368ce80b7b3347d1c7a561ce611425f2664d7aa51f0b5d, add(add(mulmod(state0, M01, F), mulmod(state1, M11, F)), mulmod(state2, M21, F)))\n      scratch2 := add(0x29383c01ebd3b6ab0c017656ebe658b6a328ec77bc33626e29e2e95b33ea6111, add(add(mulmod(state0, M02, F), mulmod(state1, M12, F)), mulmod(state2, M22, F)))\n      state0 := mulmod(scratch0, scratch0, F)\n      scratch0 := mulmod(mulmod(state0, state0, F), scratch0, F)\n      state0 := add(0x10646d2f2603de39a1f4ae5e7771a64a702db6e86fb76ab600bf573f9010c711, add(add(mulmod(scratch0, M00, F), mulmod(scratch1, M10, F)), mulmod(scratch2, M20, F)))\n      state1 := add(0x0beb5e07d1b27145f575f1395a55bf132f90c25b40da7b3864d0242dcb1117fb, add(add(mulmod(scratch0, M01, F), mulmod(scratch1, M11, F)), mulmod(scratch2, M21, F)))\n      state2 := add(0x16d685252078c133dc0d3ecad62b5c8830f95bb2e54b59abdffbf018d96fa336, add(add(mulmod(scratch0, M02, F), mulmod(scratch1, M12, F)), mulmod(scratch2, M22, F)))\n      scratch0 := mulmod(state0, state0, F)\n      state0 := mulmod(mulmod(scratch0, scratch0, F), state0, F)\n      scratch0 := add(0x0a6abd1d833938f33c74154e0404b4b40a555bbbec21ddfafd672dd62047f01a, add(add(mulmod(state0, M00, F), mulmod(state1, M10, F)), mulmod(state2, M20, F)))\n      scratch1 := add(0x1a679f5d36eb7b5c8ea12a4c2dedc8feb12dffeec450317270a6f19b34cf1860, add(add(mulmod(state0, M01, F), mulmod(state1, M11, F)), mulmod(state2, M21, F)))\n      scratch2 := add(0x0980fb233bd456c23974d50e0ebfde4726a423eada4e8f6ffbc7592e3f1b93d6, add(add(mulmod(state0, M02, F), mulmod(state1, M12, F)), mulmod(state2, M22, F)))\n      state0 := mulmod(scratch0, scratch0, F)\n      scratch0 := mulmod(mulmod(state0, state0, F), scratch0, F)\n      state0 := add(0x161b42232e61b84cbf1810af93a38fc0cece3d5628c9282003ebacb5c312c72b, add(add(mulmod(scratch0, M00, F), mulmod(scratch1, M10, F)), mulmod(scratch2, M20, F)))\n      state1 := add(0x0ada10a90c7f0520950f7d47a60d5e6a493f09787f1564e5d09203db47de1a0b, add(add(mulmod(scratch0, M01, F), mulmod(scratch1, M11, F)), mulmod(scratch2, M21, F)))\n      state2 := add(0x1a730d372310ba82320345a29ac4238ed3f07a8a2b4e121bb50ddb9af407f451, add(add(mulmod(scratch0, M02, F), mulmod(scratch1, M12, F)), mulmod(scratch2, M22, F)))\n      scratch0 := mulmod(state0, state0, F)\n      state0 := mulmod(mulmod(scratch0, scratch0, F), state0, F)\n      scratch0 := add(0x2c8120f268ef054f817064c369dda7ea908377feaba5c4dffbda10ef58e8c556, add(add(mulmod(state0, M00, F), mulmod(state1, M10, F)), mulmod(state2, M20, F)))\n      scratch1 := add(0x1c7c8824f758753fa57c00789c684217b930e95313bcb73e6e7b8649a4968f70, add(add(mulmod(state0, M01, F), mulmod(state1, M11, F)), mulmod(state2, M21, F)))\n      scratch2 := add(0x2cd9ed31f5f8691c8e39e4077a74faa0f400ad8b491eb3f7b47b27fa3fd1cf77, add(add(mulmod(state0, M02, F), mulmod(state1, M12, F)), mulmod(state2, M22, F)))\n      state0 := mulmod(scratch0, scratch0, F)\n      scratch0 := mulmod(mulmod(state0, state0, F), scratch0, F)\n      state0 := add(0x23ff4f9d46813457cf60d92f57618399a5e022ac321ca550854ae23918a22eea, add(add(mulmod(scratch0, M00, F), mulmod(scratch1, M10, F)), mulmod(scratch2, M20, F)))\n      state1 := add(0x09945a5d147a4f66ceece6405dddd9d0af5a2c5103529407dff1ea58f180426d, add(add(mulmod(scratch0, M01, F), mulmod(scratch1, M11, F)), mulmod(scratch2, M21, F)))\n      state2 := add(0x188d9c528025d4c2b67660c6b771b90f7c7da6eaa29d3f268a6dd223ec6fc630, add(add(mulmod(scratch0, M02, F), mulmod(scratch1, M12, F)), mulmod(scratch2, M22, F)))\n      scratch0 := mulmod(state0, state0, F)\n      state0 := mulmod(mulmod(scratch0, scratch0, F), state0, F)\n      scratch0 := add(0x3050e37996596b7f81f68311431d8734dba7d926d3633595e0c0d8ddf4f0f47f, add(add(mulmod(state0, M00, F), mulmod(state1, M10, F)), mulmod(state2, M20, F)))\n      scratch1 := add(0x15af1169396830a91600ca8102c35c426ceae5461e3f95d89d829518d30afd78, add(add(mulmod(state0, M01, F), mulmod(state1, M11, F)), mulmod(state2, M21, F)))\n      scratch2 := add(0x1da6d09885432ea9a06d9f37f873d985dae933e351466b2904284da3320d8acc, add(add(mulmod(state0, M02, F), mulmod(state1, M12, F)), mulmod(state2, M22, F)))\n      state0 := mulmod(scratch0, scratch0, F)\n      scratch0 := mulmod(mulmod(state0, state0, F), scratch0, F)\n      state0 := add(0x2796ea90d269af29f5f8acf33921124e4e4fad3dbe658945e546ee411ddaa9cb, add(add(mulmod(scratch0, M00, F), mulmod(scratch1, M10, F)), mulmod(scratch2, M20, F)))\n      state1 := add(0x202d7dd1da0f6b4b0325c8b3307742f01e15612ec8e9304a7cb0319e01d32d60, add(add(mulmod(scratch0, M01, F), mulmod(scratch1, M11, F)), mulmod(scratch2, M21, F)))\n      state2 := add(0x096d6790d05bb759156a952ba263d672a2d7f9c788f4c831a29dace4c0f8be5f, add(add(mulmod(scratch0, M02, F), mulmod(scratch1, M12, F)), mulmod(scratch2, M22, F)))\n      scratch0 := mulmod(state0, state0, F)\n      state0 := mulmod(mulmod(scratch0, scratch0, F), state0, F)\n      scratch0 := add(0x054efa1f65b0fce283808965275d877b438da23ce5b13e1963798cb1447d25a4, add(add(mulmod(state0, M00, F), mulmod(state1, M10, F)), mulmod(state2, M20, F)))\n      scratch1 := add(0x1b162f83d917e93edb3308c29802deb9d8aa690113b2e14864ccf6e18e4165f1, add(add(mulmod(state0, M01, F), mulmod(state1, M11, F)), mulmod(state2, M21, F)))\n      scratch2 := add(0x21e5241e12564dd6fd9f1cdd2a0de39eedfefc1466cc568ec5ceb745a0506edc, add(add(mulmod(state0, M02, F), mulmod(state1, M12, F)), mulmod(state2, M22, F)))\n      state0 := mulmod(scratch0, scratch0, F)\n      scratch0 := mulmod(mulmod(state0, state0, F), scratch0, F)\n      state0 := mulmod(scratch1, scratch1, F)\n      scratch1 := mulmod(mulmod(state0, state0, F), scratch1, F)\n      state0 := mulmod(scratch2, scratch2, F)\n      scratch2 := mulmod(mulmod(state0, state0, F), scratch2, F)\n      state0 := add(0x1cfb5662e8cf5ac9226a80ee17b36abecb73ab5f87e161927b4349e10e4bdf08, add(add(mulmod(scratch0, M00, F), mulmod(scratch1, M10, F)), mulmod(scratch2, M20, F)))\n      state1 := add(0x0f21177e302a771bbae6d8d1ecb373b62c99af346220ac0129c53f666eb24100, add(add(mulmod(scratch0, M01, F), mulmod(scratch1, M11, F)), mulmod(scratch2, M21, F)))\n      state2 := add(0x1671522374606992affb0dd7f71b12bec4236aede6290546bcef7e1f515c2320, add(add(mulmod(scratch0, M02, F), mulmod(scratch1, M12, F)), mulmod(scratch2, M22, F)))\n      scratch0 := mulmod(state0, state0, F)\n      state0 := mulmod(mulmod(scratch0, scratch0, F), state0, F)\n      scratch0 := mulmod(state1, state1, F)\n      state1 := mulmod(mulmod(scratch0, scratch0, F), state1, F)\n      scratch0 := mulmod(state2, state2, F)\n      state2 := mulmod(mulmod(scratch0, scratch0, F), state2, F)\n      scratch0 := add(0x0fa3ec5b9488259c2eb4cf24501bfad9be2ec9e42c5cc8ccd419d2a692cad870, add(add(mulmod(state0, M00, F), mulmod(state1, M10, F)), mulmod(state2, M20, F)))\n      scratch1 := add(0x193c0e04e0bd298357cb266c1506080ed36edce85c648cc085e8c57b1ab54bba, add(add(mulmod(state0, M01, F), mulmod(state1, M11, F)), mulmod(state2, M21, F)))\n      scratch2 := add(0x102adf8ef74735a27e9128306dcbc3c99f6f7291cd406578ce14ea2adaba68f8, add(add(mulmod(state0, M02, F), mulmod(state1, M12, F)), mulmod(state2, M22, F)))\n      state0 := mulmod(scratch0, scratch0, F)\n      scratch0 := mulmod(mulmod(state0, state0, F), scratch0, F)\n      state0 := mulmod(scratch1, scratch1, F)\n      scratch1 := mulmod(mulmod(state0, state0, F), scratch1, F)\n      state0 := mulmod(scratch2, scratch2, F)\n      scratch2 := mulmod(mulmod(state0, state0, F), scratch2, F)\n      state0 := add(0x0fe0af7858e49859e2a54d6f1ad945b1316aa24bfbdd23ae40a6d0cb70c3eab1, add(add(mulmod(scratch0, M00, F), mulmod(scratch1, M10, F)), mulmod(scratch2, M20, F)))\n      state1 := add(0x216f6717bbc7dedb08536a2220843f4e2da5f1daa9ebdefde8a5ea7344798d22, add(add(mulmod(scratch0, M01, F), mulmod(scratch1, M11, F)), mulmod(scratch2, M21, F)))\n      state2 := add(0x1da55cc900f0d21f4a3e694391918a1b3c23b2ac773c6b3ef88e2e4228325161, add(add(mulmod(scratch0, M02, F), mulmod(scratch1, M12, F)), mulmod(scratch2, M22, F)))\n      scratch0 := mulmod(state0, state0, F)\n      state0 := mulmod(mulmod(scratch0, scratch0, F), state0, F)\n      scratch0 := mulmod(state1, state1, F)\n      state1 := mulmod(mulmod(scratch0, scratch0, F), state1, F)\n      scratch0 := mulmod(state2, state2, F)\n      state2 := mulmod(mulmod(scratch0, scratch0, F), state2, F)\n\n      mstore(0x0, mod(add(add(mulmod(state0, M00, F), mulmod(state1, M10, F)), mulmod(state2, M20, F)), F))\n\n      return(0, 0x20)\n    }\n  }\n}\n"
      },
      "project/contracts/evm/adapters/L1AztecBridgeAdapter.sol": {
        "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.29;\n\n// Messaging\nimport {IRegistry} from \"../aztec-interfaces/IRegistry.sol\";\nimport {IInbox} from \"../aztec-interfaces/messagebridge/IInbox.sol\";\nimport {IOutbox} from \"../aztec-interfaces/messagebridge/IOutbox.sol\";\nimport {IRollup} from \"../aztec-interfaces/IRollup.sol\";\nimport {DataStructures} from \"../aztec-interfaces/CoreDataStructures.sol\";\nimport {ILocalRootProvider, IGigaRootRecipient} from  \"../interfaces/IRootMessengers.sol\";\n// hash for message passing to L2\nimport {Hash} from \"../aztec-interfaces/crypto/Hash.sol\";\nimport {IL1BridgeAdapter} from \"../interfaces/IL1BridgeAdapter.sol\";\n\ncontract L1AztecBridgeAdapter is IL1BridgeAdapter, ILocalRootProvider, IGigaRootRecipient {\n    event NewGigaRootSentToAztec(bytes32 indexed newGigaRoot, bytes32 key, uint256 index); //newGigaRoot is also the content hash! wow!'\n    \n    modifier onlyGigaBridge() {\n        require(msg.sender == gigaBridge, \"Not gigaBridge\");\n        _; // what is that?\n    }\n\n    modifier onlyDeployer() {\n        require(msg.sender == deployer, \"Not the deployer\");\n        _; // what is that?\n    }\n    // IRegistry public registry; not used\n    bytes32 public l2AztecBridgeAdapter;\n    // most recent warp toad state root from the L2\n    uint256 public mostRecentL2Root;\n    // the L2 block that the most recent L2 root came from\n    uint256 public mostRecentL2RootBlockNumber;\n\n    IRollup public rollup;\n    IOutbox public outbox;\n    IInbox public inbox;\n    uint256 public rollupVersion;\n\n    address public gigaBridge;\n\n    address deployer;\n\n    bool isInitialized = false;\n    constructor() {\n        deployer = msg.sender;\n    }\n    /**\n     * @notice Initialize the portal\n     * @param _registry - The registry address\n     * @param _l2AztecBridgeAdapter - The L2 bridge address\n     */\n    function initialize(\n        address _registry,\n        bytes32 _l2AztecBridgeAdapter,\n        address _gigaRootBridge\n    ) external onlyDeployer() {\n        require(isInitialized == false, \"cant initialize twice\");\n        isInitialized = true;\n\n        l2AztecBridgeAdapter = _l2AztecBridgeAdapter;\n\n        rollup = IRollup(IRegistry(_registry).getCanonicalRollup());\n        outbox = rollup.getOutbox();\n        inbox = rollup.getInbox();\n        rollupVersion = rollup.getVersion();\n\n        gigaBridge = _gigaRootBridge;\n    }\n\n    /**\n     * @notice adds an L2 message which can only be consumed publicly on Aztec\n     * @param _newGigaRoot - The new gigaRoot to send to L2 as a message\n     */\n    function receiveGigaRoot(\n        uint256 _newGigaRoot\n    ) external payable onlyGigaBridge {\n        _bridgeGigaRootToL2(_newGigaRoot);\n    }\n\n    function _bridgeGigaRootToL2(uint256 _newGigaRoot) internal {\n        // l2AztecBridgeAdapter is the Aztec address of the contract that will be retrieving the\n        // message on the L2\n        DataStructures.L2Actor memory actor = DataStructures.L2Actor(\n            l2AztecBridgeAdapter,\n            rollupVersion\n        );\n\n        // Aztec docs assume that the message being passed is larger than a Field element\n        // so it recommends you hash it and verify the hash on the L2 when retrieving the message.\n        // Luckily for us, the GigaRoot is the size of a Field so we don't have to hash it\n        // and can directly retrieve it on the L2.\n        bytes32 contentHash = bytes32(_newGigaRoot);\n\n        // `secret` is used to make the consumption of a message on the L2 private.\n        // we don't care about keeping message consumption private at all so to\n        // simplify things we hardcode the secret as 0 in the noir side and hardcode\n        // Hash(0) here in the L1\n        bytes32 secretHash = 0x001dc7b0244cb71a4609d526300ba6771064bd046848666f7bfe577053d630c5;\n\n        // Send message to rollup\n        (bytes32 key, uint256 index) = inbox.sendL2Message(\n            actor,\n            contentHash,\n            secretHash\n        );\n\n        // Emit event\n        emit NewGigaRootSentToAztec(contentHash, key, index);\n    } \n\n    function getLocalRootAndBlock() view external returns (uint256, uint256) {\n        require(\n            mostRecentL2Root > 0,\n            \"An L2 root hasn't yet been bridged to this contract. refreshRoot must be called.\"\n        );\n        require(\n            mostRecentL2RootBlockNumber > 0,\n            \"An L2 root hasn't yet been bridged to this contract. refreshRoot must be called.\"\n        );\n        return (mostRecentL2Root, mostRecentL2RootBlockNumber);\n    }\n\n    /**\n     * @notice gets the L2 root from the portal\n     * @dev Second part of getting the L2 root to L1, must be initiated from L2 first as it will consume a message from outbox\n     * @param _newL2Root - the merkle root currently on the L2 to add into the GigaRoot\n     * @param _bridgedL2BlockNumber - the block number that is in the content hash (should exactly match the block _newL2Root is from)\n     * @param _witnessL2BlockNumber - the block number where we retrieve the message proof from (should exactly match the block at which the witness (aka _path) is retrieved )\n     * @param _leafIndex - The amount to withdraw\n     * @param _path - Must match the caller of the message (specified from L2) to consume it.\n     */\n    function getNewRootFromL2(\n        bytes32 _newL2Root,\n        uint256 _bridgedL2BlockNumber,\n        uint256 _witnessL2BlockNumber,\n        uint256 _leafIndex,\n        bytes32[] calldata _path\n    ) external {\n        // this hash should match the hash created on the aztec side of this root bridge\n        // adapter\n        bytes32 contentHash = getContentHash(_newL2Root, _bridgedL2BlockNumber);\n\n        DataStructures.L2ToL1Msg memory message = DataStructures.L2ToL1Msg({\n            sender: DataStructures.L2Actor(l2AztecBridgeAdapter, rollupVersion),\n            recipient: DataStructures.L1Actor(address(this), block.chainid),\n            content: contentHash\n        });\n\n        outbox.consume(message, _witnessL2BlockNumber, _leafIndex, _path);\n\n        // convert from bytes32 to uint256\n        uint256 newL2RootCast = uint256(_newL2Root);\n\n        if (mostRecentL2RootBlockNumber <= _bridgedL2BlockNumber ) {\n            emit ReceivedNewL2Root(newL2RootCast, _bridgedL2BlockNumber);\n            mostRecentL2Root = newL2RootCast;\n            mostRecentL2RootBlockNumber = _bridgedL2BlockNumber;\n        }\n        // TODO put in history\n    }\n\n    // hashes _newL2Root and _l2BlockNumber so it's representation can fit inside of a\n    // Field element.  This should match how they are hashed in the Aztec side of this bridge\n    // adapter\n    function getContentHash(\n        bytes32 _newL2Root,\n        uint256 _bridgedL2BlockNumber\n    ) public pure returns (bytes32) {\n        return Hash.sha256ToField(abi.encode(_newL2Root, _bridgedL2BlockNumber));\n    }\n}\n"
      },
      "project/contracts/evm/adapters/L1ScrollBridgeAdapter.sol": {
        "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.29;\n\nimport {ILocalRootProvider, IGigaRootRecipient, IGigaRootProvider} from  \"../interfaces/IRootMessengers.sol\";\nimport {IL1BridgeAdapter} from \"../interfaces/IL1BridgeAdapter.sol\";\nimport {IL1ScrollMessenger} from \"@scroll-tech/contracts/L1/IL1ScrollMessenger.sol\";\n\n// no IGigaRootRecipient because we have L1SLOAD!\ncontract L1ScrollBridgeAdapter is IL1BridgeAdapter, ILocalRootProvider, IGigaRootRecipient {\n    modifier onlyGigaBridge() {\n        require(msg.sender == gigaBridge, \"Not gigaBridge\");\n        _; // what is that?\n    }\n\n    modifier onlyDeployer() {\n        require(msg.sender == deployer, \"Not the deployer\");\n        _; // what is that?\n    }\n    address public l2ScrollBridgeAdapter;\n    // most recent warp toad state root from the L2\n    uint256 public mostRecentL2Root;\n    // the L2 block that the most recent L2 root came from\n    uint256 public mostRecentL2RootBlockNumber;\n\n    address public gigaBridge;\n\n    address deployer;\n\n    address public l1ScrollMessenger;\n\n    bool isInitialized = false;\n    constructor(address _l1ScrollMessenger ) {\n        deployer = msg.sender;\n        l1ScrollMessenger = _l1ScrollMessenger;\n    }\n\n    function initialize(\n        address _l2ScrollBridgeAdapter,\n        address _gigaRootBridge\n    ) external onlyDeployer() {\n        require(isInitialized == false, \"cant initialize only once\");\n        isInitialized = true;\n        l2ScrollBridgeAdapter = _l2ScrollBridgeAdapter;\n        gigaBridge = _gigaRootBridge;\n    }\n\n\n    function getNewRootFromL2(uint256 _l2Root, uint256 _l2BlockNumber) external {\n        require(msg.sender == l1ScrollMessenger,\"function not called by l1ScrollMessenger\");\n        require(l2ScrollBridgeAdapter == IL1ScrollMessenger(l1ScrollMessenger).xDomainMessageSender(),\"contract messaging from L2 is not the L2ScrollBridgeAdapter\");\n\n        if(mostRecentL2RootBlockNumber <= _l2BlockNumber) {\n            emit ReceivedNewL2Root(_l2Root, _l2BlockNumber);\n            mostRecentL2Root = _l2Root;\n            mostRecentL2RootBlockNumber = _l2BlockNumber;\n        }\n    }\n\n    function receiveGigaRoot(\n        uint256 _newGigaRoot\n    ) external payable onlyGigaBridge {\n        _bridgeGigaRootToL2(_newGigaRoot, 2000000);\n    }\n\n    // just incase the hardcoded gaslimit fails\n    function receiveGigaRoot(\n        uint256 _newGigaRoot,\n        uint256 _gasLimit\n    ) external payable {\n        _bridgeGigaRootToL2(_newGigaRoot, _gasLimit);\n    }\n\n    function _bridgeGigaRootToL2(uint256 _newGigaRoot, uint256 _gasLimit) internal {\n        // uint256 _newGigaRoot = IGigaRootProvider(gigaBridge).gigaRoot();\n        // sendMessage is able to execute any function by encoding the abi using the encodeWithSignature function\n        //IScrollMessenger(l1ScrollMessenger).sendMessage{value: msg.value}(\n        IL1ScrollMessenger(l1ScrollMessenger).sendMessage{value: msg.value}( // can this be 0?? or can we pay for some relayer?? check docs!\n            l2ScrollBridgeAdapter,\n            0,\n            abi.encodeWithSignature(\n                \"receiveGigaRoot(uint256)\",\n                _newGigaRoot\n            ),\n            _gasLimit,\n            tx.origin // refund goes to the eoa initiating the tx\n        );\n        \n    } \n\n    function getLocalRootAndBlock() view external returns (uint256, uint256) {\n        require(\n            mostRecentL2Root > 0,\n            \"An L2 root hasn't yet been bridged to this contract. refreshRoot must be called.\"\n        );\n        require(\n            mostRecentL2RootBlockNumber > 0,\n            \"An L2 root hasn't yet been bridged to this contract. refreshRoot must be called.\"\n        );\n        return (mostRecentL2Root, mostRecentL2RootBlockNumber);\n    }\n}\n"
      },
      "project/contracts/evm/adapters/L2ScrollBridgeAdapter.sol": {
        "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.29;\n\nimport {IL2ScrollMessenger} from \"@scroll-tech/contracts/L2/IL2ScrollMessenger.sol\";\nimport {IGigaRootProvider, IGigaRootRecipient, ILocalRootRecipient, ILocalRootProvider} from \"../interfaces/IRootMessengers.sol\";\nimport {IL2BridgeAdapter} from \"../interfaces/IL2BridgeAdapter.sol\";\n\ncontract L2ScrollBridgeAdapter is\n    IL2BridgeAdapter,\n    IGigaRootProvider,\n    ILocalRootRecipient\n{\n    uint256 public gigaRoot;\n\n    // TODO erhm so scroll probably dropped L1SLOAD \n    // address L1_SLOAD_ADDRESS = 0x0000000000000000000000000000000000000101;\n    // uint256 gigaRootL1Slot = 0;\n\n    address l1ScrollBridgeAdapter;\n    address l2ScrollMessenger;\n    address l2WarpToad; // L2 warptoad\n\n    event SentLocalRootToL1(uint256 indexed localRoot);\n    event NewGigaRoot(uint256 indexed gigaRoot);\n    constructor(\n        address _l2ScrollMessenger,\n        address _l1ScrollBridgeAdapter,\n        address _l2WarpToad\n    ) {\n        l1ScrollBridgeAdapter = _l1ScrollBridgeAdapter;\n        l2ScrollMessenger = _l2ScrollMessenger;\n        l2WarpToad = _l2WarpToad;\n    }\n\n    // extra for the contracts that want it.\n    // receiveGigaRoot (called by the L2ScrollBridge) will send it to L2Warptoad already\n    function sendGigaRoot(address _gigaRootRecipient) public payable {\n        IGigaRootRecipient(_gigaRootRecipient).receiveGigaRoot(gigaRoot);\n    }\n\n    function sentLocalRootToL1() public {\n        (uint256 _l2Root, uint256 _l2BlockNumber) = ILocalRootProvider(\n            l2WarpToad\n        ).getLocalRootAndBlock();\n        // sendMessage is able to execute any function by encoding the abi using the encodeWithSignature function\n        //IScrollMessenger(l2ScrollMessenger).sendMessage{value: msg.value}(\n        uint256 gasLimit = 2000000;\n        IL2ScrollMessenger(l2ScrollMessenger).sendMessage{value: 0}( // can this be 0?? or can we pay for some relayer?? check docs!\n            l1ScrollBridgeAdapter, // TODO send to a L1Adapter first\n            0,\n            abi.encodeWithSignature(\"getNewRootFromL2(uint256,uint256)\",_l2Root,_l2BlockNumber),\n            gasLimit,\n            msg.sender\n        );\n\n\n        emit SentLocalRootToL1(_l2Root);\n    }\n\n    function sentLocalRootToL1(uint256 _gasLimit) public {\n        (uint256 _l2Root, uint256 _l2BlockNumber) = ILocalRootProvider(\n            l2WarpToad\n        ).getLocalRootAndBlock();\n        // sendMessage is able to execute any function by encoding the abi using the encodeWithSignature function\n        //IScrollMessenger(l2ScrollMessenger).sendMessage{value: msg.value}(\n        IL2ScrollMessenger(l2ScrollMessenger).sendMessage{value: 0}( // can this be 0?? or can we pay for some relayer?? check docs!\n            l1ScrollBridgeAdapter, // TODO send to a L1Adapter first\n            0,\n            abi.encodeWithSignature(\"getNewRootFromL2(uint256,uint256)\",_l2Root,_l2BlockNumber),\n            _gasLimit,\n            msg.sender\n        );\n\n        emit SentLocalRootToL1(_l2Root);\n    }\n   \n    function receiveGigaRoot(uint256 _gigaRoot) public payable {\n        require(msg.sender == l2ScrollMessenger,\"function not called by l1ScrollMessenger\");\n        require(l1ScrollBridgeAdapter == IL2ScrollMessenger(l2ScrollMessenger).xDomainMessageSender(),\"contract messaging from L1 is not the L1ScrollBridgeAdapter\");\n        gigaRoot = _gigaRoot;\n        sendGigaRoot(l2WarpToad);\n        emit NewGigaRoot(_gigaRoot);\n    }\n}"
      },
      "project/contracts/evm/aztec-interfaces/ConfigurationLib.sol": {
        "content": "// SPDX-License-Identifier: Apache-2.0\n// Copyright 2024 Aztec Labs.\npragma solidity >=0.8.27;\n\nimport {Timestamp} from \"./TimeLib.sol\";\nimport {DataStructures} from \"./GovernanceDataStructures.sol\";\nimport {Errors} from \"./GovernanceErrors.sol\";\n\nlibrary ConfigurationLib {\n    uint256 internal constant YEAR_2100 = 4102444800;\n\n    uint256 internal constant QUORUM_LOWER = 1;\n    uint256 internal constant QUORUM_UPPER = 1e18;\n\n    uint256 internal constant DIFFERENTIAL_UPPER = 1e18;\n\n    uint256 internal constant VOTES_LOWER = 1;\n\n    Timestamp internal constant TIME_LOWER = Timestamp.wrap(60);\n    Timestamp internal constant TIME_UPPER = Timestamp.wrap(30 * 24 * 3600);\n\n    function withdrawalDelay(\n        DataStructures.Configuration storage _self\n    ) internal view returns (Timestamp) {\n        return\n            Timestamp.wrap(Timestamp.unwrap(_self.votingDelay) / 5) +\n            _self.votingDuration +\n            _self.executionDelay;\n    }\n\n    /**\n     * @notice\n     * @dev     We specify `memory` here since it is called on outside import for validation\n     *          before writing it to state.\n     */\n    function assertValid(\n        DataStructures.Configuration memory _self\n    ) internal pure returns (bool) {\n        require(\n            _self.quorum >= QUORUM_LOWER,\n            Errors.Governance__ConfigurationLib__QuorumTooSmall()\n        );\n        require(\n            _self.quorum <= QUORUM_UPPER,\n            Errors.Governance__ConfigurationLib__QuorumTooBig()\n        );\n\n        require(\n            _self.voteDifferential <= DIFFERENTIAL_UPPER,\n            Errors.Governance__ConfigurationLib__DifferentialTooBig()\n        );\n\n        require(\n            _self.minimumVotes >= VOTES_LOWER,\n            Errors.Governance__ConfigurationLib__InvalidMinimumVotes()\n        );\n        require(\n            _self.proposeConfig.lockAmount >= VOTES_LOWER,\n            Errors.Governance__ConfigurationLib__LockAmountTooSmall()\n        );\n\n        // Beyond checking the bounds like this, it might be useful to ensure that the value is larger than the withdrawal delay\n        // this, can be useful if one want to ensure that the \"locker\" cannot himself vote in the proposal, but as it is unclear\n        // if this is a useful property, it is not enforced.\n        require(\n            _self.proposeConfig.lockDelay >= TIME_LOWER,\n            Errors.Governance__ConfigurationLib__TimeTooSmall(\"LockDelay\")\n        );\n        require(\n            _self.proposeConfig.lockDelay <= TIME_UPPER,\n            Errors.Governance__ConfigurationLib__TimeTooBig(\"LockDelay\")\n        );\n\n        require(\n            _self.votingDelay >= TIME_LOWER,\n            Errors.Governance__ConfigurationLib__TimeTooSmall(\"VotingDelay\")\n        );\n        require(\n            _self.votingDelay <= TIME_UPPER,\n            Errors.Governance__ConfigurationLib__TimeTooBig(\"VotingDelay\")\n        );\n\n        require(\n            _self.votingDuration >= TIME_LOWER,\n            Errors.Governance__ConfigurationLib__TimeTooSmall(\"VotingDuration\")\n        );\n        require(\n            _self.votingDuration <= TIME_UPPER,\n            Errors.Governance__ConfigurationLib__TimeTooBig(\"VotingDuration\")\n        );\n\n        require(\n            _self.executionDelay >= TIME_LOWER,\n            Errors.Governance__ConfigurationLib__TimeTooSmall(\"ExecutionDelay\")\n        );\n        require(\n            _self.executionDelay <= TIME_UPPER,\n            Errors.Governance__ConfigurationLib__TimeTooBig(\"ExecutionDelay\")\n        );\n\n        require(\n            _self.gracePeriod >= TIME_LOWER,\n            Errors.Governance__ConfigurationLib__TimeTooSmall(\"GracePeriod\")\n        );\n        require(\n            _self.gracePeriod <= TIME_UPPER,\n            Errors.Governance__ConfigurationLib__TimeTooBig(\"GracePeriod\")\n        );\n\n        return true;\n    }\n}\n"
      },
      "project/contracts/evm/aztec-interfaces/ConstantsGen.sol": {
        "content": "// GENERATED FILE - DO NOT EDIT, RUN yarn remake-constants in yarn-project/constants\n// SPDX-License-Identifier: Apache-2.0\n// Copyright 2023 Aztec Labs.\npragma solidity >=0.8.27;\n\n/**\n * @title Constants Library\n * @author Aztec Labs\n * @notice Library that contains constants used throughout the Aztec protocol\n */\nlibrary Constants {\n  // Prime field modulus\n  uint256 internal constant P =\n    21888242871839275222246405745257275088548364400416034343698204186575808495617;\n\n  uint256 internal constant MAX_FIELD_VALUE =\n    21888242871839275222246405745257275088548364400416034343698204186575808495616;\n  uint256 internal constant ARGS_LENGTH = 16;\n  uint256 internal constant MAX_FR_CALLDATA_TO_ALL_ENQUEUED_CALLS = 16000;\n  uint256 internal constant MAX_NOTE_HASHES_PER_CALL = 16;\n  uint256 internal constant MAX_NULLIFIERS_PER_CALL = 16;\n  uint256 internal constant MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL = 5;\n  uint256 internal constant MAX_ENQUEUED_CALLS_PER_CALL = 16;\n  uint256 internal constant MAX_L2_TO_L1_MSGS_PER_CALL = 2;\n  uint256 internal constant MAX_PUBLIC_DATA_UPDATE_REQUESTS_PER_CALL = 63;\n  uint256 internal constant MAX_PUBLIC_DATA_READS_PER_CALL = 64;\n  uint256 internal constant MAX_NOTE_HASH_READ_REQUESTS_PER_CALL = 16;\n  uint256 internal constant MAX_NULLIFIER_READ_REQUESTS_PER_CALL = 16;\n  uint256 internal constant MAX_NULLIFIER_NON_EXISTENT_READ_REQUESTS_PER_CALL = 16;\n  uint256 internal constant MAX_L1_TO_L2_MSG_READ_REQUESTS_PER_CALL = 16;\n  uint256 internal constant MAX_KEY_VALIDATION_REQUESTS_PER_CALL = 16;\n  uint256 internal constant MAX_PRIVATE_LOGS_PER_CALL = 16;\n  uint256 internal constant MAX_PUBLIC_LOGS_PER_CALL = 4;\n  uint256 internal constant MAX_CONTRACT_CLASS_LOGS_PER_CALL = 1;\n  uint256 internal constant ARCHIVE_HEIGHT = 29;\n  uint256 internal constant VK_TREE_HEIGHT = 6;\n  uint256 internal constant PROTOCOL_CONTRACT_TREE_HEIGHT = 3;\n  uint256 internal constant FUNCTION_TREE_HEIGHT = 5;\n  uint256 internal constant NOTE_HASH_TREE_HEIGHT = 40;\n  uint256 internal constant PUBLIC_DATA_TREE_HEIGHT = 40;\n  uint256 internal constant NULLIFIER_TREE_HEIGHT = 40;\n  uint256 internal constant L1_TO_L2_MSG_TREE_HEIGHT = 39;\n  uint256 internal constant ARTIFACT_FUNCTION_TREE_MAX_HEIGHT = 5;\n  uint256 internal constant NULLIFIER_TREE_ID = 0;\n  uint256 internal constant NOTE_HASH_TREE_ID = 1;\n  uint256 internal constant PUBLIC_DATA_TREE_ID = 2;\n  uint256 internal constant L1_TO_L2_MESSAGE_TREE_ID = 3;\n  uint256 internal constant ARCHIVE_TREE_ID = 4;\n  uint256 internal constant NOTE_HASH_SUBTREE_HEIGHT = 6;\n  uint256 internal constant NULLIFIER_SUBTREE_HEIGHT = 6;\n  uint256 internal constant PUBLIC_DATA_SUBTREE_HEIGHT = 6;\n  uint256 internal constant L1_TO_L2_MSG_SUBTREE_HEIGHT = 4;\n  uint256 internal constant NOTE_HASH_SUBTREE_SIBLING_PATH_LENGTH = 34;\n  uint256 internal constant NULLIFIER_SUBTREE_SIBLING_PATH_LENGTH = 34;\n  uint256 internal constant L1_TO_L2_MSG_SUBTREE_SIBLING_PATH_LENGTH = 35;\n  uint256 internal constant MAX_NOTE_HASHES_PER_TX = 64;\n  uint256 internal constant MAX_NULLIFIERS_PER_TX = 64;\n  uint256 internal constant MAX_PRIVATE_CALL_STACK_LENGTH_PER_TX = 8;\n  uint256 internal constant MAX_ENQUEUED_CALLS_PER_TX = 32;\n  uint256 internal constant PROTOCOL_PUBLIC_DATA_UPDATE_REQUESTS_PER_TX = 1;\n  uint256 internal constant MAX_TOTAL_PUBLIC_DATA_UPDATE_REQUESTS_PER_TX = 64;\n  uint256 internal constant MAX_PUBLIC_DATA_UPDATE_REQUESTS_PER_TX = 63;\n  uint256 internal constant MAX_PUBLIC_DATA_READS_PER_TX = 64;\n  uint256 internal constant MAX_L2_TO_L1_MSGS_PER_TX = 8;\n  uint256 internal constant MAX_NOTE_HASH_READ_REQUESTS_PER_TX = 64;\n  uint256 internal constant MAX_NULLIFIER_READ_REQUESTS_PER_TX = 64;\n  uint256 internal constant MAX_NULLIFIER_NON_EXISTENT_READ_REQUESTS_PER_TX = 64;\n  uint256 internal constant MAX_L1_TO_L2_MSG_READ_REQUESTS_PER_TX = 64;\n  uint256 internal constant MAX_KEY_VALIDATION_REQUESTS_PER_TX = 64;\n  uint256 internal constant MAX_PRIVATE_LOGS_PER_TX = 32;\n  uint256 internal constant MAX_PUBLIC_LOGS_PER_TX = 8;\n  uint256 internal constant MAX_CONTRACT_CLASS_LOGS_PER_TX = 1;\n  uint256 internal constant NUMBER_OF_L1_L2_MESSAGES_PER_ROLLUP = 16;\n  uint256 internal constant PRIVATE_KERNEL_INIT_INDEX = 0;\n  uint256 internal constant PRIVATE_KERNEL_INNER_INDEX = 1;\n  uint256 internal constant PRIVATE_KERNEL_TAIL_INDEX = 2;\n  uint256 internal constant PRIVATE_KERNEL_TAIL_TO_PUBLIC_INDEX = 3;\n  uint256 internal constant TUBE_VK_INDEX = 4;\n  uint256 internal constant PRIVATE_BASE_ROLLUP_VK_INDEX = 6;\n  uint256 internal constant PUBLIC_BASE_ROLLUP_VK_INDEX = 7;\n  uint256 internal constant MERGE_ROLLUP_INDEX = 8;\n  uint256 internal constant BLOCK_ROOT_ROLLUP_INDEX = 9;\n  uint256 internal constant BLOCK_ROOT_ROLLUP_SINGLE_TX_INDEX = 10;\n  uint256 internal constant BLOCK_ROOT_ROLLUP_EMPTY_INDEX = 11;\n  uint256 internal constant BLOCK_MERGE_ROLLUP_INDEX = 12;\n  uint256 internal constant ROOT_ROLLUP_INDEX = 13;\n  uint256 internal constant BASE_PARITY_INDEX = 14;\n  uint256 internal constant ROOT_PARITY_INDEX = 15;\n  uint256 internal constant PRIVATE_KERNEL_RESET_INDEX = 20;\n  uint256 internal constant FUNCTION_SELECTOR_NUM_BYTES = 4;\n  uint256 internal constant INITIALIZATION_SLOT_SEPARATOR = 1000000000;\n  uint256 internal constant INITIAL_L2_BLOCK_NUM = 1;\n  uint256 internal constant FIELDS_PER_BLOB = 4096;\n  uint256 internal constant BLOBS_PER_BLOCK = 3;\n  uint256 internal constant PUBLIC_LOG_DATA_SIZE_IN_FIELDS = 13;\n  uint256 internal constant PUBLIC_LOG_SIZE_IN_FIELDS = 14;\n  uint256 internal constant PRIVATE_LOG_SIZE_IN_FIELDS = 18;\n  uint256 internal constant AZTEC_MAX_EPOCH_DURATION = 48;\n  uint256 internal constant GENESIS_BLOCK_HASH =\n    20646204262468251631976884937192820660867507115079672078981654411421834866549;\n  uint256 internal constant GENESIS_ARCHIVE_ROOT =\n    1002640778211850180189505934749257244705296832326768971348723156503780793518;\n  uint256 internal constant FEE_JUICE_INITIAL_MINT = 200000000000000000000000;\n  uint256 internal constant PUBLIC_DISPATCH_SELECTOR = 3578010381;\n  uint256 internal constant MAX_PACKED_PUBLIC_BYTECODE_SIZE_IN_FIELDS = 3000;\n  uint256 internal constant MAX_PACKED_BYTECODE_SIZE_PER_PRIVATE_FUNCTION_IN_FIELDS = 3000;\n  uint256 internal constant MAX_PACKED_BYTECODE_SIZE_PER_UNCONSTRAINED_FUNCTION_IN_FIELDS = 3000;\n  uint256 internal constant REGISTERER_PRIVATE_FUNCTION_BROADCASTED_ADDITIONAL_FIELDS = 19;\n  uint256 internal constant REGISTERER_UNCONSTRAINED_FUNCTION_BROADCASTED_ADDITIONAL_FIELDS = 12;\n  uint256 internal constant REGISTERER_CONTRACT_CLASS_REGISTERED_MAGIC_VALUE =\n    11121068431693264234253912047066709627593769337094408533543930778360;\n  uint256 internal constant REGISTERER_PRIVATE_FUNCTION_BROADCASTED_MAGIC_VALUE =\n    2889881020989534926461066592611988634597302675057895885580456197069;\n  uint256 internal constant REGISTERER_UNCONSTRAINED_FUNCTION_BROADCASTED_MAGIC_VALUE =\n    24399338136397901754495080759185489776044879232766421623673792970137;\n  uint256 internal constant DEPLOYER_CONTRACT_INSTANCE_DEPLOYED_MAGIC_VALUE =\n    14061769416655647708490531650437236735160113654556896985372298487345;\n  uint256 internal constant DEPLOYER_CONTRACT_INSTANCE_UPDATED_MAGIC_VALUE =\n    1534834688047131268740281708431107902615560100979874281215533519862;\n  uint256 internal constant MAX_PROTOCOL_CONTRACTS = 7;\n  uint256 internal constant CANONICAL_AUTH_REGISTRY_ADDRESS = 1;\n  uint256 internal constant DEPLOYER_CONTRACT_ADDRESS = 2;\n  uint256 internal constant REGISTERER_CONTRACT_ADDRESS = 3;\n  uint256 internal constant MULTI_CALL_ENTRYPOINT_ADDRESS = 4;\n  uint256 internal constant FEE_JUICE_ADDRESS = 5;\n  uint256 internal constant ROUTER_ADDRESS = 6;\n  uint256 internal constant REGISTERER_CONTRACT_BYTECODE_CAPSULE_SLOT = 79025834455612;\n  uint256 internal constant FEE_JUICE_BALANCES_SLOT = 1;\n  uint256 internal constant UPDATED_CLASS_IDS_SLOT = 1;\n  uint256 internal constant DEFAULT_NPK_M_X =\n    582240093077765400562621227108555700500271598878376310175765873770292988861;\n  uint256 internal constant DEFAULT_NPK_M_Y =\n    10422444662424639723529825114205836958711284159673861467999592572974769103684;\n  uint256 internal constant DEFAULT_IVPK_M_X =\n    339708709767762472786445938838804872781183545349360029270386718856175781484;\n  uint256 internal constant DEFAULT_IVPK_M_Y =\n    12719619215050539905199178334954929730355853796706924300730604757520758976849;\n  uint256 internal constant DEFAULT_OVPK_M_X =\n    12212787719617305570587928860288475454328008955283046946846066128763901043335;\n  uint256 internal constant DEFAULT_OVPK_M_Y =\n    3646747884782549389807830220601404629716007431341772952958971658285958854707;\n  uint256 internal constant DEFAULT_TPK_M_X =\n    728059161893070741164607238299536939695876538801885465230641192969135857403;\n  uint256 internal constant DEFAULT_TPK_M_Y =\n    14575718736702206050102425029229426215631664471161015518982549597389390371695;\n  uint256 internal constant AZTEC_ADDRESS_LENGTH = 1;\n  uint256 internal constant GAS_FEES_LENGTH = 2;\n  uint256 internal constant GAS_LENGTH = 2;\n  uint256 internal constant GAS_SETTINGS_LENGTH = 8;\n  uint256 internal constant CALL_CONTEXT_LENGTH = 4;\n  uint256 internal constant CONTENT_COMMITMENT_LENGTH = 4;\n  uint256 internal constant CONTRACT_INSTANCE_LENGTH = 16;\n  uint256 internal constant CONTRACT_STORAGE_READ_LENGTH = 3;\n  uint256 internal constant CONTRACT_STORAGE_UPDATE_REQUEST_LENGTH = 3;\n  uint256 internal constant ETH_ADDRESS_LENGTH = 1;\n  uint256 internal constant FUNCTION_DATA_LENGTH = 2;\n  uint256 internal constant FUNCTION_LEAF_PREIMAGE_LENGTH = 5;\n  uint256 internal constant GLOBAL_VARIABLES_LENGTH = 9;\n  uint256 internal constant APPEND_ONLY_TREE_SNAPSHOT_LENGTH = 2;\n  uint256 internal constant APPEND_ONLY_TREE_SNAPSHOT_LENGTH_BYTES = 36;\n  uint256 internal constant SPONGE_BLOB_LENGTH = 11;\n  uint256 internal constant BLOB_PUBLIC_INPUTS = 6;\n  uint256 internal constant BLOB_PUBLIC_INPUTS_BYTES = 112;\n  uint256 internal constant L1_TO_L2_MESSAGE_LENGTH = 6;\n  uint256 internal constant L2_TO_L1_MESSAGE_LENGTH = 3;\n  uint256 internal constant SCOPED_L2_TO_L1_MESSAGE_LENGTH = 4;\n  uint256 internal constant MAX_BLOCK_NUMBER_LENGTH = 2;\n  uint256 internal constant KEY_VALIDATION_REQUEST_LENGTH = 4;\n  uint256 internal constant KEY_VALIDATION_REQUEST_AND_GENERATOR_LENGTH = 5;\n  uint256 internal constant SCOPED_KEY_VALIDATION_REQUEST_AND_GENERATOR_LENGTH = 6;\n  uint256 internal constant PARTIAL_STATE_REFERENCE_LENGTH = 6;\n  uint256 internal constant READ_REQUEST_LENGTH = 2;\n  uint256 internal constant TREE_LEAF_READ_REQUEST_LENGTH = 2;\n  uint256 internal constant PRIVATE_LOG_DATA_LENGTH = 20;\n  uint256 internal constant SCOPED_PRIVATE_LOG_DATA_LENGTH = 21;\n  uint256 internal constant CONTRACT_CLASS_LOG_DATA_SIZE_IN_FIELDS = 3019;\n  uint256 internal constant CONTRACT_CLASS_LOG_SIZE_IN_FIELDS = 3020;\n  uint256 internal constant LOG_HASH_LENGTH = 3;\n  uint256 internal constant SCOPED_LOG_HASH_LENGTH = 4;\n  uint256 internal constant NOTE_HASH_LENGTH = 2;\n  uint256 internal constant SCOPED_NOTE_HASH_LENGTH = 3;\n  uint256 internal constant NULLIFIER_LENGTH = 3;\n  uint256 internal constant SCOPED_NULLIFIER_LENGTH = 4;\n  uint256 internal constant PUBLIC_DATA_WRITE_LENGTH = 2;\n  uint256 internal constant PUBLIC_CALL_STACK_ITEM_COMPRESSED_LENGTH = 12;\n  uint256 internal constant PRIVATE_CALL_REQUEST_LENGTH = 8;\n  uint256 internal constant PUBLIC_CALL_REQUEST_LENGTH = 4;\n  uint256 internal constant COUNTED_PUBLIC_CALL_REQUEST_LENGTH = 5;\n  uint256 internal constant PUBLIC_INNER_CALL_REQUEST_LENGTH = 13;\n  uint256 internal constant ROLLUP_VALIDATION_REQUESTS_LENGTH = 2;\n  uint256 internal constant STATE_REFERENCE_LENGTH = 8;\n  uint256 internal constant TREE_SNAPSHOTS_LENGTH = 8;\n  uint256 internal constant TX_CONTEXT_LENGTH = 10;\n  uint256 internal constant TX_REQUEST_LENGTH = 14;\n  uint256 internal constant TOTAL_FEES_LENGTH = 1;\n  uint256 internal constant TOTAL_MANA_USED_LENGTH = 1;\n  uint256 internal constant BLOCK_HEADER_LENGTH = 25;\n  uint256 internal constant BLOCK_HEADER_LENGTH_BYTES = 648;\n  uint256 internal constant PRIVATE_CIRCUIT_PUBLIC_INPUTS_LENGTH = 724;\n  uint256 internal constant PUBLIC_CIRCUIT_PUBLIC_INPUTS_LENGTH = 908;\n  uint256 internal constant PRIVATE_CONTEXT_INPUTS_LENGTH = 40;\n  uint256 internal constant FEE_RECIPIENT_LENGTH = 2;\n  uint256 internal constant AGGREGATION_OBJECT_LENGTH = 16;\n  uint256 internal constant IPA_CLAIM_LENGTH = 10;\n  uint256 internal constant SCOPED_READ_REQUEST_LEN = 3;\n  uint256 internal constant PUBLIC_DATA_READ_LENGTH = 3;\n  uint256 internal constant PRIVATE_VALIDATION_REQUESTS_LENGTH = 772;\n  uint256 internal constant PRIVATE_TO_ROLLUP_ACCUMULATED_DATA_LENGTH = 740;\n  uint256 internal constant TX_CONSTANT_DATA_LENGTH = 37;\n  uint256 internal constant COMBINED_CONSTANT_DATA_LENGTH = 46;\n  uint256 internal constant PRIVATE_ACCUMULATED_DATA_LENGTH = 1380;\n  uint256 internal constant PRIVATE_KERNEL_CIRCUIT_PUBLIC_INPUTS_LENGTH = 2197;\n  uint256 internal constant PRIVATE_TO_PUBLIC_ACCUMULATED_DATA_LENGTH = 868;\n  uint256 internal constant PRIVATE_TO_AVM_ACCUMULATED_DATA_LENGTH = 160;\n  uint256 internal constant NUM_PRIVATE_TO_AVM_ACCUMULATED_DATA_ARRAYS = 3;\n  uint256 internal constant PRIVATE_TO_PUBLIC_KERNEL_CIRCUIT_PUBLIC_INPUTS_LENGTH = 1782;\n  uint256 internal constant PRIVATE_TO_ROLLUP_KERNEL_CIRCUIT_PUBLIC_INPUTS_LENGTH = 782;\n  uint256 internal constant CONSTANT_ROLLUP_DATA_LENGTH = 13;\n  uint256 internal constant BASE_OR_MERGE_PUBLIC_INPUTS_LENGTH = 52;\n  uint256 internal constant BLOCK_ROOT_OR_BLOCK_MERGE_PUBLIC_INPUTS_LENGTH = 986;\n  uint256 internal constant ROOT_ROLLUP_PUBLIC_INPUTS_LENGTH = 972;\n  uint256 internal constant GET_NOTES_ORACLE_RETURN_LENGTH = 674;\n  uint256 internal constant NOTE_HASHES_NUM_BYTES_PER_BASE_ROLLUP = 2048;\n  uint256 internal constant NULLIFIERS_NUM_BYTES_PER_BASE_ROLLUP = 2048;\n  uint256 internal constant PUBLIC_DATA_WRITES_NUM_BYTES_PER_BASE_ROLLUP = 4096;\n  uint256 internal constant PRIVATE_LOGS_NUM_BYTES_PER_BASE_ROLLUP = 18432;\n  uint256 internal constant CONTRACTS_NUM_BYTES_PER_BASE_ROLLUP = 32;\n  uint256 internal constant CONTRACT_DATA_NUM_BYTES_PER_BASE_ROLLUP = 64;\n  uint256 internal constant CONTRACT_DATA_NUM_BYTES_PER_BASE_ROLLUP_UNPADDED = 52;\n  uint256 internal constant L2_TO_L1_MSGS_NUM_BYTES_PER_BASE_ROLLUP = 256;\n  uint256 internal constant LOGS_HASHES_NUM_BYTES_PER_BASE_ROLLUP = 64;\n  uint256 internal constant NUM_MSGS_PER_BASE_PARITY = 4;\n  uint256 internal constant NUM_BASE_PARITY_PER_ROOT_PARITY = 4;\n  uint256 internal constant RECURSIVE_PROOF_LENGTH = 456;\n  uint256 internal constant NESTED_RECURSIVE_PROOF_LENGTH = 456;\n  uint256 internal constant IPA_PROOF_LENGTH = 69;\n  uint256 internal constant RECURSIVE_ROLLUP_HONK_PROOF_LENGTH = 535;\n  uint256 internal constant NESTED_RECURSIVE_ROLLUP_HONK_PROOF_LENGTH = 535;\n  uint256 internal constant TUBE_PROOF_LENGTH = 535;\n  uint256 internal constant HONK_VERIFICATION_KEY_LENGTH_IN_FIELDS = 128;\n  uint256 internal constant ROLLUP_HONK_VERIFICATION_KEY_LENGTH_IN_FIELDS = 139;\n  uint256 internal constant CLIENT_IVC_VERIFICATION_KEY_LENGTH_IN_FIELDS = 143;\n  uint256 internal constant MAX_PUBLIC_BYTECODE_SIZE_IN_BYTES = 96000;\n  uint256 internal constant MAX_PUBLIC_CALLS_TO_UNIQUE_CONTRACT_CLASS_IDS = 21;\n  uint256 internal constant MEM_TAG_FF = 0;\n  uint256 internal constant MEM_TAG_U1 = 1;\n  uint256 internal constant MEM_TAG_U8 = 2;\n  uint256 internal constant MEM_TAG_U16 = 3;\n  uint256 internal constant MEM_TAG_U32 = 4;\n  uint256 internal constant MEM_TAG_U64 = 5;\n  uint256 internal constant MEM_TAG_U128 = 6;\n  uint256 internal constant SENDER_KERNEL_INPUTS_COL_OFFSET = 0;\n  uint256 internal constant ADDRESS_KERNEL_INPUTS_COL_OFFSET = 1;\n  uint256 internal constant IS_STATIC_CALL_KERNEL_INPUTS_COL_OFFSET = 3;\n  uint256 internal constant CHAIN_ID_KERNEL_INPUTS_COL_OFFSET = 4;\n  uint256 internal constant VERSION_KERNEL_INPUTS_COL_OFFSET = 5;\n  uint256 internal constant BLOCK_NUMBER_KERNEL_INPUTS_COL_OFFSET = 6;\n  uint256 internal constant TIMESTAMP_KERNEL_INPUTS_COL_OFFSET = 7;\n  uint256 internal constant FEE_PER_DA_GAS_KERNEL_INPUTS_COL_OFFSET = 8;\n  uint256 internal constant FEE_PER_L2_GAS_KERNEL_INPUTS_COL_OFFSET = 9;\n  uint256 internal constant DA_START_GAS_KERNEL_INPUTS_COL_OFFSET = 10;\n  uint256 internal constant L2_START_GAS_KERNEL_INPUTS_COL_OFFSET = 11;\n  uint256 internal constant DA_END_GAS_KERNEL_INPUTS_COL_OFFSET = 12;\n  uint256 internal constant L2_END_GAS_KERNEL_INPUTS_COL_OFFSET = 13;\n  uint256 internal constant TRANSACTION_FEE_KERNEL_INPUTS_COL_OFFSET = 14;\n  uint256 internal constant START_NOTE_HASH_EXISTS_WRITE_OFFSET = 0;\n  uint256 internal constant START_NULLIFIER_EXISTS_OFFSET = 16;\n  uint256 internal constant START_NULLIFIER_NON_EXISTS_OFFSET = 32;\n  uint256 internal constant START_L1_TO_L2_MSG_EXISTS_WRITE_OFFSET = 48;\n  uint256 internal constant START_SSTORE_WRITE_OFFSET = 64;\n  uint256 internal constant START_SLOAD_WRITE_OFFSET = 127;\n  uint256 internal constant START_EMIT_NOTE_HASH_WRITE_OFFSET = 191;\n  uint256 internal constant START_EMIT_NULLIFIER_WRITE_OFFSET = 207;\n  uint256 internal constant START_EMIT_L2_TO_L1_MSG_WRITE_OFFSET = 223;\n  uint256 internal constant START_EMIT_UNENCRYPTED_LOG_WRITE_OFFSET = 225;\n  uint256 internal constant DEFAULT_GAS_LIMIT = 1000000000;\n  uint256 internal constant MAX_L2_GAS_PER_TX_PUBLIC_PORTION = 6000000;\n  uint256 internal constant DEFAULT_TEARDOWN_GAS_LIMIT = 6000000;\n  uint256 internal constant DA_BYTES_PER_FIELD = 32;\n  uint256 internal constant DA_GAS_PER_BYTE = 16;\n  uint256 internal constant FIXED_DA_GAS = 512;\n  uint256 internal constant FIXED_L2_GAS = 512;\n  uint256 internal constant FIXED_AVM_STARTUP_L2_GAS = 20000;\n  uint256 internal constant L2_GAS_DISTRIBUTED_STORAGE_PREMIUM = 1024;\n  uint256 internal constant L2_GAS_PER_READ_MERKLE_HASH = 36;\n  uint256 internal constant L2_GAS_PER_WRITE_MERKLE_HASH = 36;\n  uint256 internal constant L2_GAS_PER_PUBLIC_DATA_UPDATE = 6784;\n  uint256 internal constant L2_GAS_PER_NOTE_HASH = 3904;\n  uint256 internal constant L2_GAS_PER_NULLIFIER = 5344;\n  uint256 internal constant L2_GAS_PER_PUBLIC_DATA_READ = 1440;\n  uint256 internal constant L2_GAS_PER_NOTE_HASH_READ_REQUEST = 1440;\n  uint256 internal constant L2_GAS_PER_NULLIFIER_READ_REQUEST = 1440;\n  uint256 internal constant L2_GAS_PER_L1_TO_L2_MSG_READ_REQUEST = 1404;\n  uint256 internal constant L2_GAS_PER_LOG_BYTE = 4;\n  uint256 internal constant L2_GAS_PER_PRIVATE_LOG = 0;\n  uint256 internal constant L2_GAS_PER_CONTRACT_CLASS_LOG = 0;\n  uint256 internal constant L2_GAS_PER_L2_TO_L1_MSG = 200;\n  uint256 internal constant TX_START_PREFIX = 8392562855083340404;\n  uint256 internal constant REVERT_CODE_PREFIX = 1;\n  uint256 internal constant TX_FEE_PREFIX = 2;\n  uint256 internal constant NOTES_PREFIX = 3;\n  uint256 internal constant NULLIFIERS_PREFIX = 4;\n  uint256 internal constant L2_L1_MSGS_PREFIX = 5;\n  uint256 internal constant PUBLIC_DATA_UPDATE_REQUESTS_PREFIX = 6;\n  uint256 internal constant PRIVATE_LOGS_PREFIX = 7;\n  uint256 internal constant PUBLIC_LOGS_PREFIX = 8;\n  uint256 internal constant CONTRACT_CLASS_LOGS_PREFIX = 9;\n  uint256 internal constant PROOF_TYPE_PLONK = 0;\n  uint256 internal constant PROOF_TYPE_HONK = 1;\n  uint256 internal constant PROOF_TYPE_OINK = 2;\n  uint256 internal constant PROOF_TYPE_PG = 3;\n  uint256 internal constant PROOF_TYPE_AVM = 4;\n  uint256 internal constant PROOF_TYPE_ROLLUP_HONK = 5;\n  uint256 internal constant PROOF_TYPE_ROOT_ROLLUP_HONK = 6;\n  uint256 internal constant TWO_POW_64 = 18446744073709551616;\n  uint256 internal constant DEFAULT_UPDATE_DELAY = 3600;\n  uint256 internal constant MINIMUM_UPDATE_DELAY = 25;\n  uint256 internal constant UPDATES_VALUE_SIZE = 1;\n  uint256 internal constant UPDATES_SHARED_MUTABLE_VALUES_LEN = 3;\n  uint256 internal constant GRUMPKIN_ONE_X = 1;\n  uint256 internal constant GRUMPKIN_ONE_Y =\n    17631683881184975370165255887551781615748388533673675138860;\n}\n"
      },
      "project/contracts/evm/aztec-interfaces/CoreDataStructures.sol": {
        "content": "// SPDX-License-Identifier: Apache-2.0\n// Copyright 2024 Aztec Labs.\npragma solidity >=0.8.27;\n\n/**\n * @title Data Structures Library\n * @author Aztec Labs\n * @notice Library that contains data structures used throughout the Aztec protocol\n */\nlibrary DataStructures {\n    // docs:start:l1_actor\n    /**\n     * @notice Actor on L1.\n     * @param actor - The address of the actor\n     * @param chainId - The chainId of the actor\n     */\n    struct L1Actor {\n        address actor;\n        uint256 chainId;\n    }\n    // docs:end:l1_actor\n\n    // docs:start:l2_actor\n    /**\n     * @notice Actor on L2.\n     * @param actor - The aztec address of the actor\n     * @param version - Ahe Aztec instance the actor is on\n     */\n    struct L2Actor {\n        bytes32 actor;\n        uint256 version;\n    }\n    // docs:end:l2_actor\n\n    // docs:start:l1_to_l2_msg\n    /**\n     * @notice Struct containing a message from L1 to L2\n     * @param sender - The sender of the message\n     * @param recipient - The recipient of the message\n     * @param content - The content of the message (application specific) padded to bytes32 or hashed if larger.\n     * @param secretHash - The secret hash of the message (make it possible to hide when a specific message is consumed on L2).\n     * @param index - Global leaf index on the L1 to L2 messages tree.\n     */\n    struct L1ToL2Msg {\n        L1Actor sender;\n        L2Actor recipient;\n        bytes32 content;\n        bytes32 secretHash;\n        uint256 index;\n    }\n    // docs:end:l1_to_l2_msg\n\n    // docs:start:l2_to_l1_msg\n    /**\n     * @notice Struct containing a message from L2 to L1\n     * @param sender - The sender of the message\n     * @param recipient - The recipient of the message\n     * @param content - The content of the message (application specific) padded to bytes32 or hashed if larger.\n     * @dev Not to be confused with L2ToL1Message in Noir circuits\n     */\n    struct L2ToL1Msg {\n        DataStructures.L2Actor sender;\n        DataStructures.L1Actor recipient;\n        bytes32 content;\n    }\n    // docs:end:l2_to_l1_msg\n}\n"
      },
      "project/contracts/evm/aztec-interfaces/CoreErrors.sol": {
        "content": "// SPDX-License-Identifier: Apache-2.0\n// Copyright 2024 Aztec Labs.\npragma solidity >=0.8.27;\n\nimport {Timestamp, Slot, Epoch} from \"./TimeLib.sol\";\n\n/**\n * @title Errors Library\n * @author Aztec Labs\n * @notice Library that contains errors used throughout the Aztec protocol\n * Errors are prefixed with the contract name to make it easy to identify where the error originated\n * when there are multiple contracts that could have thrown the error.\n *\n * Sigs are provided for easy reference, but don't trust; verify! run `forge inspect src/core/libraries/Errors.sol:Errors errors`\n */\nlibrary Errors {\n    // DEVNET related\n    error DevNet__NoPruningAllowed(); // 0x6984c590\n    error DevNet__InvalidProposer(address expected, address actual); // 0x11e6e6f7\n\n    // Inbox\n    error Inbox__Unauthorized(); // 0xe5336a6b\n    error Inbox__ActorTooLarge(bytes32 actor); // 0xa776a06e\n    error Inbox__VersionMismatch(uint256 expected, uint256 actual); // 0x47452014\n    error Inbox__ContentTooLarge(bytes32 content); // 0x47452014\n    error Inbox__SecretHashTooLarge(bytes32 secretHash); // 0xecde7e2c\n    error Inbox__MustBuildBeforeConsume(); // 0xc4901999\n\n    // Outbox\n    error Outbox__Unauthorized(); // 0x2c9490c2\n    error Outbox__InvalidChainId(); // 0x577ec7c4\n    error Outbox__VersionMismatch(uint256 expected, uint256 actual);\n    error Outbox__NothingToConsume(bytes32 messageHash); // 0xfb4fb506\n    error Outbox__IncompatibleEntryArguments(\n        bytes32 messageHash,\n        uint64 storedFee,\n        uint64 feePassed,\n        uint32 storedVersion,\n        uint32 versionPassed,\n        uint32 storedDeadline,\n        uint32 deadlinePassed\n    ); // 0x5e789f34\n    error Outbox__InvalidPathLength(uint256 expected, uint256 actual); // 0x481bcd9c\n    error Outbox__RootAlreadySetAtBlock(uint256 l2BlockNumber); // 0x3eccfd3e\n    error Outbox__InvalidRecipient(address expected, address actual); // 0x57aad581\n    error Outbox__AlreadyNullified(uint256 l2BlockNumber, uint256 leafIndex); // 0xfd71c2d4\n    error Outbox__NothingToConsumeAtBlock(uint256 l2BlockNumber); // 0xa4508f22\n    error Outbox__BlockNotProven(uint256 l2BlockNumber); // 0x0e194a6d\n\n    // Rollup\n    error Rollup__InsufficientBondAmount(uint256 minimum, uint256 provided); // 0xa165f276\n    error Rollup__InsufficientFundsInEscrow(\n        uint256 required,\n        uint256 available\n    ); // 0xa165f276\n    error Rollup__InvalidArchive(bytes32 expected, bytes32 actual); // 0xb682a40e\n    error Rollup__InvalidBlockHash(bytes32 expected, bytes32 actual);\n    error Rollup__InvalidBlockNumber(uint256 expected, uint256 actual); // 0xe5edf847\n    error Rollup__InvalidChainId(uint256 expected, uint256 actual); // 0x37b5bc12\n    error Rollup__InvalidInHash(bytes32 expected, bytes32 actual); // 0xcd6f4233\n    error Rollup__InvalidPreviousArchive(bytes32 expected, bytes32 actual); // 0xb682a40e\n    error Rollup__InvalidPreviousBlockHash(bytes32 expected, bytes32 actual);\n    error Rollup__InvalidProof(); // 0xa5b2ba17\n    error Rollup__InvalidProposedArchive(bytes32 expected, bytes32 actual); // 0x32532e73\n    error Rollup__InvalidTimestamp(Timestamp expected, Timestamp actual); // 0x3132e895\n    error Rollup__InvalidVersion(uint256 expected, uint256 actual); // 0x9ef30794\n    error Rollup__InvalidBlobHash(bytes32 blobHash); // 0xc4a168c6\n    error Rollup__InvalidBlobProof(bytes32 blobHash); // 0x5ca17bef\n    error Rollup__InvalidBlobPublicInputsHash(bytes32 expected, bytes32 actual); // 0xfe6b4994\n    error Rollup__NoEpochToProve(); // 0xcbaa3951\n    error Rollup__NonSequentialProving(); // 0x1e5be132\n    error Rollup__NothingToPrune(); // 0x850defd3\n    error Rollup__SlotAlreadyInChain(Slot lastSlot, Slot proposedSlot); // 0x83510bd0\n    error Rollup__TimestampInFuture(Timestamp max, Timestamp actual); // 0x89f30690\n    error Rollup__TimestampTooOld(); // 0x72ed9c81\n    error Rollup__TryingToProveNonExistingBlock(); // 0x34ef4954\n    error Rollup__UnavailableTxs(bytes32 txsHash); // 0x414906c3\n    error Rollup__NonZeroDaFee(); // 0xd9c75f52\n    error Rollup__InvalidBasisPointFee(uint256 basisPointFee); // 0x4292d136\n    error Rollup__InvalidManaBaseFee(uint256 expected, uint256 actual); // 0x73b6d896\n    error Rollup__StartAndEndNotSameEpoch(Epoch start, Epoch end);\n    error Rollup__StartIsNotFirstBlockOfEpoch();\n    error Rollup__StartIsNotBuildingOnProven();\n    error Rollup__AlreadyClaimed(address prover, Epoch epoch);\n    error Rollup__NotPastDeadline(Slot deadline, Slot currentSlot);\n    error Rollup__PastDeadline(Slot deadline, Slot currentSlot);\n    error Rollup__ProverHaveAlreadySubmitted(address prover, Epoch epoch);\n    error Rollup__ManaLimitExceeded();\n\n    // HeaderLib\n    error HeaderLib__InvalidHeaderSize(uint256 expected, uint256 actual); // 0xf3ccb247\n    error HeaderLib__InvalidSlotNumber(Slot expected, Slot actual); // 0x09ba91ff\n\n    // MerkleLib\n    error MerkleLib__InvalidRoot(\n        bytes32 expected,\n        bytes32 actual,\n        bytes32 leaf,\n        uint256 leafIndex\n    ); // 0x5f216bf1\n\n    // SignatureLib\n    error SignatureLib__CannotVerifyEmpty(); // 0xc7690a37\n    error SignatureLib__InvalidSignature(address expected, address recovered); // 0xd9cbae6c\n\n    // SampleLib\n    error SampleLib__IndexOutOfBounds(uint256 requested, uint256 bound); // 0xa12fc559\n    error SampleLib__SampleLargerThanIndex(uint256 sample, uint256 index); // 0xa11b0f79\n\n    // Sequencer Selection (ValidatorSelection)\n    error ValidatorSelection__EpochNotSetup(); // 0x10816cae\n    error ValidatorSelection__InvalidProposer(address expected, address actual); // 0xa8843a68\n    error ValidatorSelection__InvalidDeposit(\n        address attester,\n        address proposer\n    ); // 0x533169bd\n    error ValidatorSelection__InsufficientAttestations(\n        uint256 minimumNeeded,\n        uint256 provided\n    ); // 0xaf47297f\n    error ValidatorSelection__InsufficientAttestationsProvided(\n        uint256 minimumNeeded,\n        uint256 provided\n    ); // 0x4d4f66ac\n\n    // Staking\n    error Staking__AlreadyActive(address attester); // 0x5e206fa4\n    error Staking__AlreadyRegistered(address); // 0x18047699\n    error Staking__CannotSlashExitedStake(address); // 0x45bf4940\n    error Staking__FailedToRemove(address); // 0xa7d7baab\n    error Staking__InvalidDeposit(address attester, address proposer); // 0xf33fe8c6\n    error Staking__InsufficientStake(uint256, uint256); // 0x903aee24\n    error Staking__NoOneToSlash(address); // 0x7e2f7f1c\n    error Staking__NotExiting(address); // 0xef566ee0\n    error Staking__NotSlasher(address, address); // 0x23a6f432\n    error Staking__NotWithdrawer(address, address); // 0x8e668e5d\n    error Staking__NothingToExit(address); // 0xd2aac9b6\n    error Staking__WithdrawalNotUnlockedYet(Timestamp, Timestamp); // 0x88e1826c\n\n    // Fee Juice Portal\n    error FeeJuicePortal__AlreadyInitialized(); // 0xc7a172fe\n    error FeeJuicePortal__InvalidInitialization(); // 0xfd9b3208\n    error FeeJuicePortal__Unauthorized(); // 0x67e3691e\n\n    // Proof Commitment Escrow\n    error ProofCommitmentEscrow__InsufficientBalance(\n        uint256 balance,\n        uint256 requested\n    ); // 0x09b8b789\n    error ProofCommitmentEscrow__NotOwner(address caller); // 0x2ac332c1\n    error ProofCommitmentEscrow__WithdrawRequestNotReady(\n        uint256 current,\n        Timestamp readyAt\n    ); // 0xb32ab8a7\n\n    // FeeLib\n    error FeeLib__InvalidFeeAssetPriceModifier(); // 0xf2fb32ad\n}\n"
      },
      "project/contracts/evm/aztec-interfaces/crypto/FrontierLib.sol": {
        "content": "// SPDX-License-Identifier: Apache-2.0\n// Copyright 2024 Aztec Labs.\npragma solidity >=0.8.27;\n\nimport {Hash} from \"./Hash.sol\";\n\n/**\n * @title FrontierLib\n * @author Aztec Labs\n * @notice Library for managing frontier trees.\n */\nlibrary FrontierLib {\n    struct Forest {\n        mapping(uint256 index => bytes32 zero) zeros;\n    }\n\n    struct Tree {\n        uint256 nextIndex;\n        mapping(uint256 => bytes32) frontier;\n    }\n\n    function initialize(Forest storage _self, uint256 _height) internal {\n        _self.zeros[0] = bytes32(0);\n        for (uint256 i = 1; i <= _height; i++) {\n            _self.zeros[i] = Hash.sha256ToField(\n                bytes.concat(_self.zeros[i - 1], _self.zeros[i - 1])\n            );\n        }\n    }\n\n    function insertLeaf(\n        Tree storage _self,\n        bytes32 _leaf\n    ) internal returns (uint256) {\n        uint256 index = _self.nextIndex;\n        uint256 level = computeLevel(index);\n        bytes32 right = _leaf;\n        for (uint256 i = 0; i < level; i++) {\n            right = Hash.sha256ToField(bytes.concat(_self.frontier[i], right));\n        }\n        _self.frontier[level] = right;\n\n        _self.nextIndex++;\n\n        return index;\n    }\n\n    function root(\n        Tree storage _self,\n        Forest storage _forest,\n        uint256 _height,\n        uint256 _size\n    ) internal view returns (bytes32) {\n        uint256 next = _self.nextIndex;\n        if (next == 0) {\n            return _forest.zeros[_height];\n        }\n        if (next == _size) {\n            return _self.frontier[_height];\n        }\n\n        uint256 index = next - 1;\n        uint256 level = computeLevel(index);\n\n        // We should start at the highest frontier level with a left leaf\n        bytes32 temp = _self.frontier[level];\n\n        uint256 bits = index >> level;\n        for (uint256 i = level; i < _height; i++) {\n            bool isRight = bits & 1 == 1;\n            if (isRight) {\n                if (_self.frontier[i] == temp) {\n                    // We will never hit the case that frontier[i] == temp\n                    // because this require that frontier[i] is the right child\n                    // and in that case we started higher up the tree\n                    revert(\"Mistakes were made\");\n                }\n                temp = Hash.sha256ToField(\n                    bytes.concat(_self.frontier[i], temp)\n                );\n            } else {\n                temp = Hash.sha256ToField(bytes.concat(temp, _forest.zeros[i]));\n            }\n            bits >>= 1;\n        }\n\n        return temp;\n    }\n\n    function isFull(\n        Tree storage _self,\n        uint256 _size\n    ) internal view returns (bool) {\n        return _self.nextIndex == _size;\n    }\n\n    function computeLevel(uint256 _leafIndex) internal pure returns (uint256) {\n        // The number of trailing ones is how many times in a row we are the right child.\n        // e.g., each time this happens we go another layer up to update the parent.\n        uint256 count = 0;\n        uint256 index = _leafIndex;\n        while (index & 1 == 1) {\n            count++;\n            index >>= 1;\n        }\n        return count;\n    }\n}\n"
      },
      "project/contracts/evm/aztec-interfaces/crypto/Hash.sol": {
        "content": "// SPDX-License-Identifier: Apache-2.0\n// Copyright 2024 Aztec Labs.\npragma solidity >=0.8.27;\n\nimport {DataStructures} from \"../CoreDataStructures.sol\";\n\n/**\n * @title Hash library\n * @author Aztec Labs\n * @notice Library that contains helper functions to compute hashes for data structures and convert to field elements\n * Using sha256 as the hash function since it hits a good balance between gas cost and circuit size.\n */\nlibrary Hash {\n    /**\n     * @notice Computes the sha256 hash of the L1 to L2 message and converts it to a field element\n     * @param _message - The L1 to L2 message to hash\n     * @return The hash of the provided message as a field element\n     */\n    function sha256ToField(\n        DataStructures.L1ToL2Msg memory _message\n    ) internal pure returns (bytes32) {\n        return\n            sha256ToField(\n                abi.encode(\n                    _message.sender,\n                    _message.recipient,\n                    _message.content,\n                    _message.secretHash,\n                    _message.index\n                )\n            );\n    }\n\n    /**\n     * @notice Computes the sha256 hash of the L2 to L1 message and converts it to a field element\n     * @param _message - The L2 to L1 message to hash\n     * @return The hash of the provided message as a field element\n     */\n    function sha256ToField(\n        DataStructures.L2ToL1Msg memory _message\n    ) internal pure returns (bytes32) {\n        return\n            sha256ToField(\n                abi.encode(\n                    _message.sender,\n                    _message.recipient,\n                    _message.content\n                )\n            );\n    }\n\n    /**\n     * @notice Computes the sha256 hash of the provided data and converts it to a field element\n     * @dev Truncating one byte to convert the hash to a field element. We prepend a byte rather than cast bytes31(bytes32) to match Noir's to_be_bytes.\n     * @param _data - The bytes to hash\n     * @return The hash of the provided data as a field element\n     */\n    function sha256ToField(bytes memory _data) internal pure returns (bytes32) {\n        return bytes32(bytes.concat(new bytes(1), bytes31(sha256(_data))));\n    }\n\n    /**\n     * @notice Computes the sha256 hash of the provided data and converts it to a field element\n     * @dev Truncating one byte to convert the hash to a field element.\n     * @param _data - A bytes32 value to hash\n     * @return The hash of the provided data as a field element\n     */\n    function sha256ToField(bytes32 _data) internal pure returns (bytes32) {\n        return sha256ToField(abi.encodePacked(_data));\n    }\n}\n"
      },
      "project/contracts/evm/aztec-interfaces/crypto/MerkleLib.sol": {
        "content": "// SPDX-License-Identifier: Apache-2.0\n// Copyright 2024 Aztec Labs.\npragma solidity >=0.8.27;\n\nimport {Hash} from \"./Hash.sol\";\nimport {Errors} from \"../CoreErrors.sol\";\n\n/**\n * @title Merkle Library\n * @author Aztec Labs\n * @notice Library that contains functions useful when interacting with Merkle Trees\n */\nlibrary MerkleLib {\n    /**\n     * @notice Verifies the membership of a leaf and path against an expected root.\n     * @dev In the case of a mismatched root, and subsequent inability to verify membership, this function throws.\n     * @param _path - The sibling path of the message as a leaf, used to prove message inclusion\n     * @param _leaf - The hash of the message we are trying to prove inclusion for\n     * @param _index - The index of the message inside the L2 to L1 message tree\n     * @param _expectedRoot - The expected root to check the validity of the message and sibling path with.\n     * @notice -\n     * E.g. A sibling path for a leaf at index 3 (L) in a tree of depth 3 (between 5 and 8 leafs) consists of the 3 elements denoted as *'s\n     * d0:                                            [ root ]\n     * d1:                      [ ]                                               [*]\n     * d2:         [*]                      [ ]                       [ ]                     [ ]\n     * d3:   [ ]         [ ]          [*]         [L]           [ ]         [ ]          [ ]        [ ].\n     * And the elements would be ordered as: [ d3_index_2, d2_index_0, d1_index_1 ].\n     */\n    function verifyMembership(\n        bytes32[] calldata _path,\n        bytes32 _leaf,\n        uint256 _index,\n        bytes32 _expectedRoot\n    ) internal pure {\n        bytes32 subtreeRoot = _leaf;\n        /// @notice - We use the indexAtHeight to see whether our child of the next subtree is at the left or the right side\n        uint256 indexAtHeight = _index;\n\n        for (uint256 height = 0; height < _path.length; height++) {\n            /// @notice - This affects the way we concatenate our two children to then hash and calculate the root, as any odd indexes (index bit-masked with least significant bit) are right-sided children.\n            bool isRight = (indexAtHeight & 1) == 1;\n\n            subtreeRoot = isRight\n                ? Hash.sha256ToField(bytes.concat(_path[height], subtreeRoot))\n                : Hash.sha256ToField(bytes.concat(subtreeRoot, _path[height]));\n            /// @notice - We divide by two here to get the index of the parent of the current subtreeRoot in its own layer\n            indexAtHeight >>= 1;\n        }\n\n        require(\n            subtreeRoot == _expectedRoot,\n            Errors.MerkleLib__InvalidRoot(\n                _expectedRoot,\n                subtreeRoot,\n                _leaf,\n                _index\n            )\n        );\n    }\n\n    /**\n     * @notice Computes the minimum and maximum path size of an unbalanced tree.\n     * @dev Follows structure of rollup circuits by greedy filling subtrees.\n     * @param _numTxs - The number of txs to form into subtrees.\n     * @return (min, max) - The min and max path sizes.\n     */\n    function computeMinMaxPathLength(\n        uint256 _numTxs\n    ) internal pure returns (uint256, uint256) {\n        if (_numTxs < 2) {\n            return (0, 0);\n        }\n\n        uint256 numSubtrees = 0;\n        uint256 currentSubtreeSize = 1;\n        uint256 currentSubtreeHeight = 0;\n        uint256 firstSubtreeHeight;\n        uint256 finalSubtreeHeight;\n        while (_numTxs != 0) {\n            // If size & txs == 0, the subtree doesn't exist for this number of txs\n            if (currentSubtreeSize & _numTxs == 0) {\n                currentSubtreeSize <<= 1;\n                currentSubtreeHeight++;\n                continue;\n            }\n            // Assign the smallest rightmost subtree height\n            if (numSubtrees == 0) finalSubtreeHeight = currentSubtreeHeight;\n            // Assign the largest leftmost subtree height\n            if (_numTxs - currentSubtreeSize == 0)\n                firstSubtreeHeight = currentSubtreeHeight;\n            _numTxs -= currentSubtreeSize;\n            currentSubtreeSize <<= 1;\n            currentSubtreeHeight++;\n            numSubtrees++;\n        }\n        if (numSubtrees == 1) {\n            // We have a balanced tree\n            return (firstSubtreeHeight, firstSubtreeHeight);\n        }\n        uint256 min = finalSubtreeHeight + numSubtrees - 1;\n        uint256 max = firstSubtreeHeight + 1;\n        return (min, max);\n    }\n\n    /**\n     * @notice Calculates a tree height from the amount of elements in the tree\n     * @dev - This mirrors the function in TestUtil, but assumes _size is an exact power of 2 or = 1\n     * @param _size - The number of elements in the tree\n     */\n    function calculateTreeHeightFromSize(\n        uint256 _size\n    ) internal pure returns (uint256) {\n        /// We need the height of the tree that will contain all of our leaves,\n        /// hence the next highest power of two from the amount of leaves - Math.ceil(Math.log2(x))\n        uint256 height = 0;\n\n        if (_size == 1) {\n            return 0;\n        }\n\n        /// While size > 1, we divide by two, and count how many times we do this; producing a rudimentary way of calculating Math.Floor(Math.log2(x))\n        while (_size > 1) {\n            _size >>= 1;\n            height++;\n        }\n        return height;\n    }\n\n    /**\n     * @notice Computes the root for a binary Merkle-tree given the leafs.\n     * @dev Uses sha256.\n     * @param _leafs - The 32 bytes leafs to build the tree of.\n     * @return The root of the Merkle tree.\n     */\n    function computeRoot(\n        bytes32[] memory _leafs\n    ) internal pure returns (bytes32) {\n        // @todo Must pad the tree\n        uint256 treeDepth = 0;\n        while (2 ** treeDepth < _leafs.length) {\n            treeDepth++;\n        }\n        uint256 treeSize = 2 ** treeDepth;\n        assembly {\n            mstore(_leafs, treeSize)\n        }\n\n        for (uint256 i = 0; i < treeDepth; i++) {\n            for (uint256 j = 0; j < treeSize; j += 2) {\n                _leafs[j / 2] = Hash.sha256ToField(\n                    bytes.concat(_leafs[j], _leafs[j + 1])\n                );\n            }\n            treeSize /= 2;\n        }\n\n        return _leafs[0];\n    }\n\n    /**\n     * @notice Computes the root for a binary unbalanced Merkle-tree given the leaves.\n     * @dev Filled in greedily with subtrees. Useful for outHash tree.\n     * @param _leaves - The 32 bytes leafs to build the tree of.\n     * @return The root of the Merkle tree.\n     */\n    function computeUnbalancedRoot(\n        bytes32[] memory _leaves\n    ) internal pure returns (bytes32) {\n        // e.g. an unbalanced tree of 7 txs will contain subtrees of 4, 2, and 1 tx(s) = 111\n        // e.g. an unbalanced tree of 9 txs will contain subtrees of 8 and 1 tx(s) = 1001\n        // We collect the roots of each subtree\n        bytes32 root;\n        uint256 currentSubtreeSize = 1;\n        uint256 numTxs = _leaves.length;\n        // We must calculate the smaller rightmost subtrees first, hence starting at 1\n        while (numTxs != 0) {\n            // If size & txs == 0, the subtree doesn't exist for this number of txs\n            if (currentSubtreeSize & numTxs == 0) {\n                currentSubtreeSize <<= 1;\n                continue;\n            }\n            bytes32[] memory leavesInSubtree = new bytes32[](\n                currentSubtreeSize\n            );\n            uint256 start = numTxs - currentSubtreeSize;\n            for (uint256 i = start; i < numTxs; i++) {\n                leavesInSubtree[i - start] = _leaves[i];\n            }\n            bytes32 subtreeRoot = computeRoot(leavesInSubtree);\n            root = numTxs == _leaves.length\n                ? subtreeRoot\n                : Hash.sha256ToField(bytes.concat(subtreeRoot, root));\n            numTxs -= currentSubtreeSize;\n            currentSubtreeSize <<= 1;\n        }\n        return root;\n    }\n}\n"
      },
      "project/contracts/evm/aztec-interfaces/crypto/SampleLib.sol": {
        "content": "// SPDX-License-Identifier: Apache-2.0\n// Copyright 2024 Aztec Labs.\npragma solidity >=0.8.27;\n\nimport {Errors} from \"../CoreErrors.sol\";\nimport {SlotDerivation} from \"../SlotDerivation.sol\";\nimport {TransientSlot} from \"../TransientSlot.sol\";\n\n/**\n * @title   SampleLib\n * @author  Anaxandridas II\n * @notice  A tiny library to draw committee indices using a sample without replacement algorithm.\n */\nlibrary SampleLib {\n    using SlotDerivation for string;\n    using SlotDerivation for bytes32;\n    using TransientSlot for *;\n\n    // Namespace for transient storage keys used within this library\n    string private constant OVERRIDE_NAMESPACE = \"Aztec.SampleLib.Override\";\n\n    /**\n     * Compute Committee\n     *\n     * @param _committeeSize - The size of the committee\n     * @param _indexCount - The total number of indices\n     * @param _seed - The seed to use for shuffling\n     *\n     * @dev assumption, _committeeSize <= _indexCount\n     *\n     * @return indices - The indices of the committee\n     */\n    function computeCommittee(\n        uint256 _committeeSize,\n        uint256 _indexCount,\n        uint256 _seed\n    ) internal returns (uint256[] memory) {\n        require(\n            _committeeSize <= _indexCount,\n            Errors.SampleLib__SampleLargerThanIndex(_committeeSize, _indexCount)\n        );\n\n        uint256[] memory sampledIndices = new uint256[](_committeeSize);\n\n        uint256 upperLimit = _indexCount - 1;\n\n        for (uint256 index = 0; index < _committeeSize; index++) {\n            uint256 sampledIndex = computeSampleIndex(index, upperLimit, _seed);\n\n            // Get index, or its swapped override\n            sampledIndices[index] = getValue(sampledIndex);\n            if (upperLimit > 0) {\n                // Swap with the last index\n                setOverrideValue(sampledIndex, getValue(upperLimit));\n                // Decrement the upper limit\n                upperLimit--;\n            }\n        }\n\n        return sampledIndices;\n    }\n\n    function setOverrideValue(uint256 _index, uint256 _value) internal {\n        OVERRIDE_NAMESPACE\n            .erc7201Slot()\n            .deriveMapping(_index)\n            .asUint256()\n            .tstore(_value);\n    }\n\n    function getValue(uint256 _index) internal view returns (uint256) {\n        uint256 overrideValue = getOverrideValue(_index);\n        if (overrideValue != 0) {\n            return overrideValue;\n        }\n\n        return _index;\n    }\n\n    function getOverrideValue(uint256 _index) internal view returns (uint256) {\n        return\n            OVERRIDE_NAMESPACE\n                .erc7201Slot()\n                .deriveMapping(_index)\n                .asUint256()\n                .tload();\n    }\n\n    /**\n     * @notice  Compute the sample index for a given index, seed and index count.\n     *\n     * @param _index - The index to shuffle\n     * @param _indexCount - The total number of indices\n     * @param _seed - The seed to use for shuffling\n     *\n     * @return shuffledIndex - The shuffled index\n     */\n    function computeSampleIndex(\n        uint256 _index,\n        uint256 _indexCount,\n        uint256 _seed\n    ) internal pure returns (uint256) {\n        // Cannot modulo by 0\n        if (_indexCount == 0) {\n            return 0;\n        }\n\n        return\n            uint256(keccak256(abi.encodePacked(_seed, _index))) % _indexCount;\n    }\n}\n"
      },
      "project/contracts/evm/aztec-interfaces/crypto/SignatureLib.sol": {
        "content": "// SPDX-License-Identifier: Apache-2.0\n// Copyright 2024 Aztec Labs.\npragma solidity ^0.8.27;\n\nimport {Errors} from \"../CoreErrors.sol\";\n\nstruct Signature {\n    bool isEmpty;\n    uint8 v;\n    bytes32 r;\n    bytes32 s;\n}\n\nlibrary SignatureLib {\n    /**\n     * @notice The domain separator for the signatures\n     */\n    enum SignatureDomainSeparator {\n        blockProposal,\n        blockAttestation\n    }\n\n    /**\n     * @notice Verified a signature, throws if the signature is invalid or empty\n     *\n     * @param _signature - The signature to verify\n     * @param _signer - The expected signer of the signature\n     * @param _digest - The digest that was signed\n     */\n    function verify(\n        Signature memory _signature,\n        address _signer,\n        bytes32 _digest\n    ) internal pure {\n        require(!_signature.isEmpty, Errors.SignatureLib__CannotVerifyEmpty());\n        address recovered = ecrecover(\n            _digest,\n            _signature.v,\n            _signature.r,\n            _signature.s\n        );\n        require(\n            _signer == recovered,\n            Errors.SignatureLib__InvalidSignature(_signer, recovered)\n        );\n    }\n\n    function toBytes(\n        Signature memory _signature\n    ) internal pure returns (bytes memory) {\n        return abi.encodePacked(_signature.r, _signature.s, _signature.v);\n    }\n}\n"
      },
      "project/contracts/evm/aztec-interfaces/GovernanceDataStructures.sol": {
        "content": "// SPDX-License-Identifier: Apache-2.0\n// Copyright 2024 Aztec Labs.\npragma solidity >=0.8.27;\n\nimport {Timestamp} from \"./TimeLib.sol\";\nimport {IPayload} from \"./IPayload.sol\";\n\n/**\n * @title Data Structures Library\n * @author Aztec Labs\n * @notice Library that contains data structures used throughout Aztec governance\n */\nlibrary DataStructures {\n    struct ProposeConfiguration {\n        Timestamp lockDelay;\n        uint256 lockAmount;\n    }\n\n    struct Configuration {\n        ProposeConfiguration proposeConfig;\n        Timestamp votingDelay;\n        Timestamp votingDuration;\n        Timestamp executionDelay;\n        Timestamp gracePeriod;\n        uint256 quorum;\n        uint256 voteDifferential;\n        uint256 minimumVotes;\n    }\n\n    struct Ballot {\n        uint256 yea;\n        uint256 nea;\n    }\n\n    // @notice if this changes, please update the enum in governance.ts\n    enum ProposalState {\n        Pending,\n        Active,\n        Queued,\n        Executable,\n        Rejected,\n        Executed,\n        Dropped,\n        Expired\n    }\n\n    struct Proposal {\n        Configuration config;\n        ProposalState state;\n        IPayload payload;\n        address governanceProposer;\n        Timestamp creation;\n        Ballot summedBallot;\n    }\n\n    struct CheckPoint {\n        Timestamp time;\n        uint256 power;\n    }\n\n    struct User {\n        uint256 numCheckPoints;\n        mapping(uint256 checkpointIndex => CheckPoint) checkpoints;\n    }\n\n    struct Withdrawal {\n        uint256 amount;\n        Timestamp unlocksAt;\n        address recipient;\n        bool claimed;\n    }\n}\n"
      },
      "project/contracts/evm/aztec-interfaces/GovernanceErrors.sol": {
        "content": "// SPDX-License-Identifier: Apache-2.0\n// Copyright 2024 Aztec Labs.\npragma solidity >=0.8.27;\n\nimport {Slot, Timestamp} from \"./TimeLib.sol\";\nimport {IPayload} from \"./IPayload.sol\";\n\n/**\n * @title Errors Library\n * @author Aztec Labs\n * @notice Library that contains errors used throughout the Aztec governance\n * Errors are prefixed with the contract name to make it easy to identify where the error originated\n * when there are multiple contracts that could have thrown the error.\n */\nlibrary Errors {\n    error Governance__CallerNotGovernanceProposer(\n        address caller,\n        address governanceProposer\n    );\n    error Governance__CallerNotSelf(address caller, address self);\n    error Governance__NoCheckpointsFound();\n    error Governance__InsufficientPower(\n        address voter,\n        uint256 have,\n        uint256 required\n    );\n    error Governance__InvalidConfiguration();\n    error Governance__WithdrawalAlreadyclaimed();\n    error Governance__WithdrawalNotUnlockedYet(\n        Timestamp currentTime,\n        Timestamp unlocksAt\n    );\n    error Governance__ProposalNotActive();\n    error Governance__ProposalNotExecutable();\n    error Governance__CannotCallAsset();\n    error Governance__CallFailed(address target);\n    error Governance__ProposalDoesNotExists(uint256 proposalId);\n    error Governance__ProposalAlreadyDropped();\n    error Governance__ProposalCannotBeDropped();\n\n    error Governance__UserLib__NotInPast();\n\n    error Governance__ConfigurationLib__InvalidMinimumVotes();\n    error Governance__ConfigurationLib__LockAmountTooSmall();\n    error Governance__ConfigurationLib__QuorumTooSmall();\n    error Governance__ConfigurationLib__QuorumTooBig();\n    error Governance__ConfigurationLib__DifferentialTooSmall();\n    error Governance__ConfigurationLib__DifferentialTooBig();\n    error Governance__ConfigurationLib__TimeTooSmall(string name);\n    error Governance__ConfigurationLib__TimeTooBig(string name);\n\n    error Governance__ProposalLib__ZeroMinimum();\n    error Governance__ProposalLib__ZeroVotesNeeded();\n    error Governance__ProposalLib__MoreVoteThanExistNeeded();\n    error Governance__ProposalLib__ZeroYeaVotesNeeded();\n    error Governance__ProposalLib__MoreYeaVoteThanExistNeeded();\n\n    error GovernanceProposer__CanOnlyExecuteProposalInPast(); // 0x8bf1d3b8\n    error GovernanceProposer__FailedToPropose(IPayload proposal); // 0x8d94fbfc\n    error GovernanceProposer__InstanceHaveNoCode(address instance); // 0x5fa92625\n    error GovernanceProposer__InsufficientVotes(\n        uint256 votesCast,\n        uint256 votesNeeded\n    ); // 0xd4ad89c2\n    error GovernanceProposer__InvalidNAndMValues(uint256 n, uint256 m); // 0x520d9704\n    error GovernanceProposer__NCannotBeLargerTHanM(uint256 n, uint256 m); // 0x2fdfc063\n    error GovernanceProposer__OnlyProposerCanVote(\n        address caller,\n        address proposer\n    ); // 0xba27df38\n    error GovernanceProposer__ProposalAlreadyExecuted(uint256 roundNumber); // 0x7aeacb17\n    error GovernanceProposer__ProposalCannotBeAddressZero(); // 0x16ac1942\n    error GovernanceProposer__ProposalHaveNoCode(IPayload proposal); // 0xb69440a1\n    error GovernanceProposer__ProposalTooOld(\n        uint256 roundNumber,\n        uint256 currentRoundNumber\n    ); // 0xc3d7aa4f\n    error GovernanceProposer__VoteAlreadyCastForSlot(Slot slot); // 0x3a6150ca\n\n    error CoinIssuer__InsufficientMintAvailable(\n        uint256 available,\n        uint256 needed\n    ); // 0xa1cc8799\n\n    error Registry__RollupAlreadyRegistered(address rollup); // 0x3c34eabf\n    error Registry__RollupNotRegistered(uint256 version);\n    error Registry__NoRollupsRegistered();\n\n    error RewardDistributor__InvalidCaller(address caller, address canonical); // 0xb95e39f6\n}\n"
      },
      "project/contracts/evm/aztec-interfaces/ICoinIssuer.sol": {
        "content": "// SPDX-License-Identifier: Apache-2.0\n// Copyright 2024 Aztec Labs.\npragma solidity >=0.8.27;\n\ninterface ICoinIssuer {\n  function mint(address _to, uint256 _amount) external;\n  function mintAvailable() external view returns (uint256);\n}\n"
      },
      "project/contracts/evm/aztec-interfaces/IFeeJuicePortal.sol": {
        "content": "// SPDX-License-Identifier: Apache-2.0\n// Copyright 2024 Aztec Labs.\npragma solidity >=0.8.27;\n\nimport {IRollup} from \"./IRollup.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {IInbox} from \"./messagebridge/IInbox.sol\";\n\ninterface IFeeJuicePortal {\n    event DepositToAztecPublic(\n        bytes32 indexed to,\n        uint256 amount,\n        bytes32 secretHash,\n        bytes32 key,\n        uint256 index\n    );\n    event FeesDistributed(address indexed to, uint256 amount);\n\n    function initialize() external;\n    function distributeFees(address _to, uint256 _amount) external;\n    function depositToAztecPublic(\n        bytes32 _to,\n        uint256 _amount,\n        bytes32 _secretHash\n    ) external returns (bytes32, uint256);\n\n    // solhint-disable-next-line func-name-mixedcase\n    function UNDERLYING() external view returns (IERC20);\n    // solhint-disable-next-line func-name-mixedcase\n    function L2_TOKEN_ADDRESS() external view returns (bytes32);\n    // solhint-disable-next-line func-name-mixedcase\n    function VERSION() external view returns (uint256);\n    // solhint-disable-next-line func-name-mixedcase\n    function INBOX() external view returns (IInbox);\n    // solhint-disable-next-line func-name-mixedcase\n    function ROLLUP() external view returns (IRollup);\n}\n"
      },
      "project/contracts/evm/aztec-interfaces/IGovernance.sol": {
        "content": "// SPDX-License-Identifier: Apache-2.0\n// Copyright 2024 Aztec Labs.\npragma solidity >=0.8.27;\n\nimport {Timestamp} from \"./TimeLib.sol\";\nimport {IPayload} from \"./IPayload.sol\";\nimport {DataStructures} from \"./GovernanceDataStructures.sol\";\n\ninterface IGovernance {\n    event Proposed(uint256 indexed proposalId, address indexed proposal);\n    event VoteCast(\n        uint256 indexed proposalId,\n        address indexed voter,\n        bool support,\n        uint256 amount\n    );\n    event ProposalExecuted(uint256 indexed proposalId);\n    event GovernanceProposerUpdated(address indexed governanceProposer);\n    event ConfigurationUpdated(Timestamp indexed time);\n\n    event Deposit(\n        address indexed depositor,\n        address indexed onBehalfOf,\n        uint256 amount\n    );\n    event WithdrawInitiated(\n        uint256 indexed withdrawalId,\n        address indexed recipient,\n        uint256 amount\n    );\n    event WithdrawFinalised(uint256 indexed withdrawalId);\n\n    function updateGovernanceProposer(address _governanceProposer) external;\n    function updateConfiguration(\n        DataStructures.Configuration memory _configuration\n    ) external;\n    function deposit(address _onBehalfOf, uint256 _amount) external;\n    function initiateWithdraw(\n        address _to,\n        uint256 _amount\n    ) external returns (uint256);\n    function finaliseWithdraw(uint256 _withdrawalId) external;\n    function propose(IPayload _proposal) external returns (bool);\n    function proposeWithLock(\n        IPayload _proposal,\n        address _to\n    ) external returns (bool);\n    function vote(\n        uint256 _proposalId,\n        uint256 _amount,\n        bool _support\n    ) external returns (bool);\n    function execute(uint256 _proposalId) external returns (bool);\n    function dropProposal(uint256 _proposalId) external returns (bool);\n\n    function powerAt(\n        address _owner,\n        Timestamp _ts\n    ) external view returns (uint256);\n    function totalPowerAt(Timestamp _ts) external view returns (uint256);\n    function getProposalState(\n        uint256 _proposalId\n    ) external view returns (DataStructures.ProposalState);\n    function getConfiguration()\n        external\n        view\n        returns (DataStructures.Configuration memory);\n    function getProposal(\n        uint256 _proposalId\n    ) external view returns (DataStructures.Proposal memory);\n    function getWithdrawal(\n        uint256 _withdrawalId\n    ) external view returns (DataStructures.Withdrawal memory);\n}\n"
      },
      "project/contracts/evm/aztec-interfaces/IGovernanceProposer.sol": {
        "content": "// SPDX-License-Identifier: Apache-2.0\n// Copyright 2024 Aztec Labs.\npragma solidity >=0.8.27;\n\nimport {Slot} from \"./TimeLib.sol\";\nimport {IPayload} from \"./IPayload.sol\";\n\ninterface IGovernanceProposer {\n    event VoteCast(\n        IPayload indexed proposal,\n        uint256 indexed round,\n        address indexed voter\n    );\n    event ProposalExecuted(IPayload indexed proposal, uint256 indexed round);\n\n    function vote(IPayload _proposal) external returns (bool);\n    function executeProposal(uint256 _roundNumber) external returns (bool);\n    function yeaCount(\n        address _instance,\n        uint256 _round,\n        IPayload _proposal\n    ) external view returns (uint256);\n    function computeRound(Slot _slot) external view returns (uint256);\n    function getInstance() external view returns (address);\n    function getExecutor() external view returns (address);\n}\n"
      },
      "project/contracts/evm/aztec-interfaces/IInstance.sol": {
        "content": "// SPDX-License-Identifier: Apache-2.0\n// Copyright 2024 Aztec Labs.\npragma solidity >=0.8.27;\n\nimport {IRollup, ITestRollup} from \"./IRollup.sol\";\nimport {IStaking} from \"./IStaking.sol\";\nimport {IValidatorSelection} from \"./IValidatorSelection.sol\";\n\ninterface IInstance is IStaking, IValidatorSelection, IRollup, ITestRollup {}\n"
      },
      "project/contracts/evm/aztec-interfaces/IMintableERC20.sol": {
        "content": "// SPDX-License-Identifier: Apache-2.0\n// Copyright 2024 Aztec Labs.\npragma solidity >=0.8.27;\n\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\ninterface IMintableERC20 is IERC20 {\n    event MinterAdded(address indexed minter);\n    event MinterRemoved(address indexed minter);\n\n    error NotMinter(address caller);\n\n    function mint(address _to, uint256 _amount) external;\n    function addMinter(address _minter) external;\n    function removeMinter(address _minter) external;\n}\n"
      },
      "project/contracts/evm/aztec-interfaces/IPayload.sol": {
        "content": "// SPDX-License-Identifier: Apache-2.0\n// Copyright 2024 Aztec Labs.\npragma solidity >=0.8.27;\n\ninterface IPayload {\n  struct Action {\n    address target;\n    bytes data;\n  }\n\n  function getActions() external view returns (Action[] memory);\n}\n"
      },
      "project/contracts/evm/aztec-interfaces/IRegistry.sol": {
        "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity >=0.8.27;\n\nimport {IRollup} from \"./IRollup.sol\";\nimport {IRewardDistributor} from \"./IRewardDistributor.sol\";\n\ninterface IRegistry {\n    event InstanceAdded(address indexed instance, uint256 indexed version);\n    event GovernanceUpdated(address indexed governance);\n\n    function addRollup(IRollup _rollup) external;\n    function updateGovernance(address _governance) external;\n\n    // docs:start:registry_get_canonical_rollup\n    function getCanonicalRollup() external view returns (IRollup);\n    // docs:end:registry_get_canonical_rollup\n\n    // docs:start:registry_get_rollup\n    function getRollup(uint256 _chainId) external view returns (IRollup);\n    // docs:end:registry_get_rollup\n\n    // docs:start:registry_number_of_versions\n    function numberOfVersions() external view returns (uint256);\n    // docs:end:registry_number_of_versions\n\n    function getGovernance() external view returns (address);\n\n    function getRewardDistributor() external view returns (IRewardDistributor);\n\n    function getVersion(uint256 _index) external view returns (uint256);\n}\n"
      },
      "project/contracts/evm/aztec-interfaces/IRewardDistributor.sol": {
        "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity >=0.8.27;\n\ninterface IRewardDistributor {\n  function claim(address _to) external returns (uint256);\n  function claimBlockRewards(address _to, uint256 _amount) external returns (uint256);\n  function canonicalRollup() external view returns (address);\n}\n"
      },
      "project/contracts/evm/aztec-interfaces/IRollup.sol": {
        "content": "// SPDX-License-Identifier: Apache-2.0\n// Copyright 2024 Aztec Labs.\npragma solidity >=0.8.27;\n\nimport {IFeeJuicePortal} from \"./IFeeJuicePortal.sol\";\nimport {IVerifier} from \"./IVerifier.sol\";\nimport {IInbox} from \"./messagebridge/IInbox.sol\";\nimport {IOutbox} from \"./messagebridge/IOutbox.sol\";\nimport {Signature} from \"./crypto/SignatureLib.sol\";\nimport {FeeHeader, L1FeeData, ManaBaseFeeComponents} from \"./rollup/FeeLib.sol\";\nimport {FeeAssetPerEthE9, EthValue, FeeAssetValue} from \"./rollup/FeeLib.sol\";\nimport {ProposeArgs} from \"./rollup/ProposeLib.sol\";\nimport {Timestamp, Slot, Epoch} from \"./TimeLib.sol\";\nimport {IRewardDistributor} from \"./IRewardDistributor.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\nstruct PublicInputArgs {\n    bytes32 previousArchive;\n    bytes32 endArchive;\n    bytes32 previousBlockHash; // @todo #8829 Not needed as public input, unconstrained on L1\n    bytes32 endBlockHash; // @todo #8829 Not needed as public input, unconstrained on L1\n    Timestamp endTimestamp;\n    bytes32 outHash;\n    address proverId;\n}\n\nstruct SubmitEpochRootProofArgs {\n    uint256 start; // inclusive\n    uint256 end; // inclusive\n    PublicInputArgs args;\n    bytes32[] fees;\n    bytes blobPublicInputs;\n    bytes aggregationObject;\n    bytes proof;\n}\n\nstruct BlockLog {\n    bytes32 archive;\n    bytes32 blockHash;\n    Slot slotNumber;\n}\n\nstruct ChainTips {\n    uint256 pendingBlockNumber;\n    uint256 provenBlockNumber;\n}\n\nstruct SubEpochRewards {\n    uint256 summedCount;\n    mapping(address prover => bool proofSubmitted) hasSubmitted;\n}\n\nstruct EpochRewards {\n    uint256 longestProvenLength;\n    uint256 rewards;\n    mapping(uint256 length => SubEpochRewards) subEpoch;\n}\n\n/**\n * @notice Struct for storing flags for block header validation\n * @param ignoreDA - True will ignore DA check, otherwise checks\n * @param ignoreSignature - True will ignore the signatures, otherwise checks\n */\nstruct BlockHeaderValidationFlags {\n    bool ignoreDA;\n    bool ignoreSignatures;\n}\n\nstruct GenesisState {\n    bytes32 vkTreeRoot;\n    bytes32 protocolContractTreeRoot;\n    bytes32 genesisArchiveRoot;\n    bytes32 genesisBlockHash;\n}\n\nstruct RollupConfigInput {\n    uint256 aztecSlotDuration;\n    uint256 aztecEpochDuration;\n    uint256 targetCommitteeSize;\n    uint256 aztecProofSubmissionWindow;\n    uint256 minimumStake;\n    uint256 slashingQuorum;\n    uint256 slashingRoundSize;\n    uint256 manaTarget;\n    EthValue provingCostPerMana;\n}\n\nstruct RollupConfig {\n    uint256 proofSubmissionWindow;\n    IERC20 feeAsset;\n    IFeeJuicePortal feeAssetPortal;\n    IRewardDistributor rewardDistributor;\n    bytes32 vkTreeRoot;\n    bytes32 protocolContractTreeRoot;\n    IVerifier epochProofVerifier;\n    IInbox inbox;\n    IOutbox outbox;\n    uint256 version;\n}\n\n// The below blobPublicInputsHashes are filled when proposing a block, then used to verify an epoch proof.\n// TODO(#8955): When implementing batched kzg proofs, store one instance per epoch rather than block\nstruct RollupStore {\n    ChainTips tips; // put first such that the struct slot structure is easy to follow for cheatcodes\n    mapping(uint256 blockNumber => BlockLog log) blocks;\n    mapping(uint256 blockNumber => bytes32) blobPublicInputsHashes;\n    mapping(address => uint256) sequencerRewards;\n    mapping(Epoch => EpochRewards) epochRewards;\n    // @todo Below can be optimised with a bitmap as we can benefit from provers likely proving for epochs close\n    // to one another.\n    mapping(address prover => mapping(Epoch epoch => bool claimed)) proverClaimed;\n    RollupConfig config;\n}\n\nstruct CheatDepositArgs {\n    address attester;\n    address proposer;\n    address withdrawer;\n    uint256 amount;\n}\n\ninterface ITestRollup {\n    event ManaTargetUpdated(uint256 indexed manaTarget);\n\n    function setEpochVerifier(address _verifier) external;\n    function setVkTreeRoot(bytes32 _vkTreeRoot) external;\n    function setProtocolContractTreeRoot(\n        bytes32 _protocolContractTreeRoot\n    ) external;\n    function cheat__InitialiseValidatorSet(\n        CheatDepositArgs[] memory _args\n    ) external;\n    function updateManaTarget(uint256 _manaTarget) external;\n}\n\ninterface IRollupCore {\n    event L2BlockProposed(\n        uint256 indexed blockNumber,\n        bytes32 indexed archive,\n        bytes32[] versionedBlobHashes\n    );\n    event L2ProofVerified(\n        uint256 indexed blockNumber,\n        address indexed proverId\n    );\n    event PrunedPending(uint256 provenBlockNumber, uint256 pendingBlockNumber);\n\n    function claimSequencerRewards(\n        address _recipient\n    ) external returns (uint256);\n    function claimProverRewards(\n        address _recipient,\n        Epoch[] memory _epochs\n    ) external returns (uint256);\n\n    function prune() external;\n    function updateL1GasFeeOracle() external;\n\n    function setProvingCostPerMana(EthValue _provingCostPerMana) external;\n\n    function propose(\n        ProposeArgs calldata _args,\n        Signature[] memory _signatures,\n        bytes calldata _blobInput\n    ) external;\n\n    function submitEpochRootProof(\n        SubmitEpochRootProofArgs calldata _args\n    ) external;\n\n    // solhint-disable-next-line func-name-mixedcase\n    function L1_BLOCK_AT_GENESIS() external view returns (uint256);\n}\n\ninterface IRollup is IRollupCore {\n    function validateHeader(\n        bytes calldata _header,\n        Signature[] memory _signatures,\n        bytes32 _digest,\n        Timestamp _currentTime,\n        bytes32 _blobsHash,\n        BlockHeaderValidationFlags memory _flags\n    ) external;\n\n    function canProposeAtTime(\n        Timestamp _ts,\n        bytes32 _archive\n    ) external returns (Slot, uint256);\n\n    function getTips() external view returns (ChainTips memory);\n\n    function status(\n        uint256 _myHeaderBlockNumber\n    )\n        external\n        view\n        returns (\n            uint256 provenBlockNumber,\n            bytes32 provenArchive,\n            uint256 pendingBlockNumber,\n            bytes32 pendingArchive,\n            bytes32 archiveOfMyBlock,\n            Epoch provenEpochNumber\n        );\n\n    function getEpochProofPublicInputs(\n        uint256 _start,\n        uint256 _end,\n        PublicInputArgs calldata _args,\n        bytes32[] calldata _fees,\n        bytes calldata _blobPublicInputs,\n        bytes calldata _aggregationObject\n    ) external view returns (bytes32[] memory);\n\n    function validateBlobs(\n        bytes calldata _blobsInputs\n    ) external view returns (bytes32[] memory, bytes32, bytes32);\n\n    function getManaBaseFeeComponentsAt(\n        Timestamp _timestamp,\n        bool _inFeeAsset\n    ) external view returns (ManaBaseFeeComponents memory);\n    function getManaBaseFeeAt(\n        Timestamp _timestamp,\n        bool _inFeeAsset\n    ) external view returns (uint256);\n    function getL1FeesAt(\n        Timestamp _timestamp\n    ) external view returns (L1FeeData memory);\n    function getFeeAssetPerEth() external view returns (FeeAssetPerEthE9);\n\n    function getEpochForBlock(\n        uint256 _blockNumber\n    ) external view returns (Epoch);\n    function canPruneAtTime(Timestamp _ts) external view returns (bool);\n\n    function archive() external view returns (bytes32);\n    function archiveAt(uint256 _blockNumber) external view returns (bytes32);\n    function getProvenBlockNumber() external view returns (uint256);\n    function getPendingBlockNumber() external view returns (uint256);\n    function getBlock(\n        uint256 _blockNumber\n    ) external view returns (BlockLog memory);\n    function getFeeHeader(\n        uint256 _blockNumber\n    ) external view returns (FeeHeader memory);\n    function getBlobPublicInputsHash(\n        uint256 _blockNumber\n    ) external view returns (bytes32);\n\n    function getSequencerRewards(\n        address _sequencer\n    ) external view returns (uint256);\n    function getCollectiveProverRewardsForEpoch(\n        Epoch _epoch\n    ) external view returns (uint256);\n    function getSpecificProverRewardsForEpoch(\n        Epoch _epoch,\n        address _prover\n    ) external view returns (uint256);\n    function getHasSubmitted(\n        Epoch _epoch,\n        uint256 _length,\n        address _prover\n    ) external view returns (bool);\n\n    function getProofSubmissionWindow() external view returns (uint256);\n    function getManaTarget() external view returns (uint256);\n    function getManaLimit() external view returns (uint256);\n    function getProvingCostPerManaInEth() external view returns (EthValue);\n\n    function getProvingCostPerManaInFeeAsset()\n        external\n        view\n        returns (FeeAssetValue);\n\n    function getFeeAsset() external view returns (IERC20);\n    function getFeeAssetPortal() external view returns (IFeeJuicePortal);\n    function getRewardDistributor() external view returns (IRewardDistributor);\n    function getBurnAddress() external view returns (address);\n\n    function getInbox() external view returns (IInbox);\n    function getOutbox() external view returns (IOutbox);\n    function getVersion() external view returns (uint256);\n}\n"
      },
      "project/contracts/evm/aztec-interfaces/ISlasher.sol": {
        "content": "// SPDX-License-Identifier: Apache-2.0\n// Copyright 2024 Aztec Labs.\npragma solidity >=0.8.27;\n\nimport {IPayload} from \"./IPayload.sol\";\n\ninterface ISlasher {\n    function slash(IPayload _payload) external returns (bool);\n}\n"
      },
      "project/contracts/evm/aztec-interfaces/IStaking.sol": {
        "content": "// SPDX-License-Identifier: Apache-2.0\n// Copyright 2024 Aztec Labs.\npragma solidity >=0.8.27;\n\nimport {Timestamp} from \"./TimeMath.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {EnumerableSet} from \"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\";\n\n// None -> Does not exist in our setup\n// Validating -> Participating as validator\n// Living -> Not participating as validator, but have funds in setup,\n// \t\t\t hit if slashes and going below the minimum\n// Exiting -> In the process of exiting the system\nenum Status {\n    NONE,\n    VALIDATING,\n    LIVING,\n    EXITING\n}\n\nstruct ValidatorInfo {\n    uint256 stake;\n    address withdrawer;\n    address proposer;\n    Status status;\n}\n\nstruct OperatorInfo {\n    address proposer;\n    address attester;\n}\n\nstruct Exit {\n    Timestamp exitableAt;\n    address recipient;\n}\n\nstruct StakingStorage {\n    IERC20 stakingAsset;\n    address slasher;\n    uint256 minimumStake;\n    Timestamp exitDelay;\n    EnumerableSet.AddressSet attesters;\n    mapping(address attester => ValidatorInfo) info;\n    mapping(address attester => Exit) exits;\n}\n\ninterface IStakingCore {\n    event Deposit(\n        address indexed attester,\n        address indexed proposer,\n        address indexed withdrawer,\n        uint256 amount\n    );\n    event WithdrawInitiated(\n        address indexed attester,\n        address indexed recipient,\n        uint256 amount\n    );\n    event WithdrawFinalised(\n        address indexed attester,\n        address indexed recipient,\n        uint256 amount\n    );\n    event Slashed(address indexed attester, uint256 amount);\n\n    function deposit(\n        address _attester,\n        address _proposer,\n        address _withdrawer,\n        uint256 _amount\n    ) external;\n    function initiateWithdraw(\n        address _attester,\n        address _recipient\n    ) external returns (bool);\n    function finaliseWithdraw(address _attester) external;\n    function slash(address _attester, uint256 _amount) external;\n}\n\ninterface IStaking is IStakingCore {\n    function getInfo(\n        address _attester\n    ) external view returns (ValidatorInfo memory);\n    function getExit(address _attester) external view returns (Exit memory);\n    function getActiveAttesterCount() external view returns (uint256);\n    function getAttesterAtIndex(uint256 _index) external view returns (address);\n    function getProposerAtIndex(uint256 _index) external view returns (address);\n    function getProposerForAttester(\n        address _attester\n    ) external view returns (address);\n    function getOperatorAtIndex(\n        uint256 _index\n    ) external view returns (OperatorInfo memory);\n    function getSlasher() external view returns (address);\n    function getStakingAsset() external view returns (IERC20);\n    function getMinimumStake() external view returns (uint256);\n    function getExitDelay() external view returns (Timestamp);\n}\n"
      },
      "project/contracts/evm/aztec-interfaces/IValidatorSelection.sol": {
        "content": "// SPDX-License-Identifier: Apache-2.0\n// Copyright 2024 Aztec Labs.\npragma solidity >=0.8.27;\n\nimport {Timestamp, Slot, Epoch} from \"./TimeLib.sol\";\n\n/**\n * @notice  The data structure for an epoch\n * @param committee - The attesters for the epoch\n * @param sampleSeed - The seed used to sample the attesters of the epoch\n * @param nextSeed - The seed used to influence the NEXT epoch\n */\nstruct EpochData {\n    address[] committee;\n    uint256 sampleSeed;\n    uint256 nextSeed;\n}\n\nstruct ValidatorSelectionStorage {\n    // A mapping to snapshots of the validator set\n    mapping(Epoch => EpochData) epochs;\n    // The last stored randao value, same value as `seed` in the last inserted epoch\n    uint256 lastSeed;\n    uint256 targetCommitteeSize;\n}\n\ninterface IValidatorSelectionCore {\n    function setupEpoch() external;\n}\n\ninterface IValidatorSelection is IValidatorSelectionCore {\n    // Likely changing to optimize in Pleistarchus\n    function getCurrentProposer() external returns (address);\n    function getProposerAt(Timestamp _ts) external returns (address);\n\n    // Non view as uses transient storage\n    function getCurrentEpochCommittee() external returns (address[] memory);\n    function getCommitteeAt(Timestamp _ts) external returns (address[] memory);\n    function getEpochCommittee(\n        Epoch _epoch\n    ) external returns (address[] memory);\n\n    // Stable\n    function getCurrentEpoch() external view returns (Epoch);\n    function getCurrentSlot() external view returns (Slot);\n\n    // Consider removing below this point\n    function getTimestampForSlot(\n        Slot _slotNumber\n    ) external view returns (Timestamp);\n\n    // Likely removal of these to replace with a size and indiviual getter\n    // Get the current epoch committee\n    function getAttesters() external view returns (address[] memory);\n\n    function getSampleSeedAt(Timestamp _ts) external view returns (uint256);\n    function getCurrentSampleSeed() external view returns (uint256);\n\n    function getEpochAt(Timestamp _ts) external view returns (Epoch);\n    function getSlotAt(Timestamp _ts) external view returns (Slot);\n    function getEpochAtSlot(Slot _slotNumber) external view returns (Epoch);\n\n    function getGenesisTime() external view returns (Timestamp);\n    function getSlotDuration() external view returns (uint256);\n    function getEpochDuration() external view returns (uint256);\n    function getTargetCommitteeSize() external view returns (uint256);\n}\n"
      },
      "project/contracts/evm/aztec-interfaces/IVerifier.sol": {
        "content": "// SPDX-License-Identifier: Apache-2.0\n// Copyright 2024 Aztec Labs.\npragma solidity >=0.8.27;\n\ninterface IVerifier {\n  function verify(bytes calldata _proof, bytes32[] calldata _publicInputs)\n    external\n    view\n    returns (bool);\n}\n"
      },
      "project/contracts/evm/aztec-interfaces/messagebridge/IInbox.sol": {
        "content": "// SPDX-License-Identifier: Apache-2.0\n// Copyright 2024 Aztec Labs.\npragma solidity >=0.8.27;\n\nimport {DataStructures} from \"../CoreDataStructures.sol\";\n\n/**\n * @title Inbox\n * @author Aztec Labs\n * @notice Lives on L1 and is used to pass messages into the rollup from L1.\n */\ninterface IInbox {\n    /**\n     * @notice Emitted when a message is sent\n     * @param l2BlockNumber - The L2 block number in which the message is included\n     * @param index - The index of the message in the L1 to L2 messages tree\n     * @param hash - The hash of the message\n     */\n    event MessageSent(\n        uint256 indexed l2BlockNumber,\n        uint256 index,\n        bytes32 indexed hash\n    );\n\n    // docs:start:send_l1_to_l2_message\n    /**\n     * @notice Inserts a new message into the Inbox\n     * @dev Emits `MessageSent` with data for easy access by the sequencer\n     * @param _recipient - The recipient of the message\n     * @param _content - The content of the message (application specific)\n     * @param _secretHash - The secret hash of the message (make it possible to hide when a specific message is consumed on L2)\n     * @return The key of the message in the set and its leaf index in the tree\n     */\n    function sendL2Message(\n        DataStructures.L2Actor memory _recipient,\n        bytes32 _content,\n        bytes32 _secretHash\n    ) external returns (bytes32, uint256);\n    // docs:end:send_l1_to_l2_message\n\n    // docs:start:consume\n    /**\n     * @notice Consumes the current tree, and starts a new one if needed\n     * @dev Only callable by the rollup contract\n     * @dev In the first iteration we return empty tree root because first block's messages tree is always\n     * empty because there has to be a 1 block lag to prevent sequencer DOS attacks\n     *\n     * @param _toConsume - The block number to consume\n     *\n     * @return The root of the consumed tree\n     */\n    function consume(uint256 _toConsume) external returns (bytes32);\n    // docs:end:consume\n\n    function getRoot(uint256 _blockNumber) external view returns (bytes32);\n}\n"
      },
      "project/contracts/evm/aztec-interfaces/messagebridge/IOutbox.sol": {
        "content": "// SPDX-License-Identifier: Apache-2.0\n// Copyright 2024 Aztec Labs.\npragma solidity >=0.8.27;\n\nimport {DataStructures} from \"../CoreDataStructures.sol\";\n\n/**\n * @title IOutbox\n * @author Aztec Labs\n * @notice Lives on L1 and is used to consume L2 -> L1 messages. Messages are inserted by the Rollup\n * and will be consumed by the portal contracts.\n */\ninterface IOutbox {\n    event RootAdded(\n        uint256 indexed l2BlockNumber,\n        bytes32 indexed root,\n        uint256 minHeight\n    );\n    event MessageConsumed(\n        uint256 indexed l2BlockNumber,\n        bytes32 indexed root,\n        bytes32 indexed messageHash,\n        uint256 leafIndex\n    );\n\n    // docs:start:outbox_insert\n    /**\n     * @notice Inserts the root of a merkle tree containing all of the L2 to L1 messages in\n     * a block specified by _l2BlockNumber.\n     * @dev Only callable by the rollup contract\n     * @dev Emits `RootAdded` upon inserting the root successfully\n     * @param _l2BlockNumber - The L2 Block Number in which the L2 to L1 messages reside\n     * @param _root - The merkle root of the tree where all the L2 to L1 messages are leaves\n     * @param _minHeight - The min height of the merkle tree that the root corresponds to\n     */\n    function insert(\n        uint256 _l2BlockNumber,\n        bytes32 _root,\n        uint256 _minHeight\n    ) external;\n    // docs:end:outbox_insert\n\n    // docs:start:outbox_consume\n    /**\n     * @notice Consumes an entry from the Outbox\n     * @dev Only useable by portals / recipients of messages\n     * @dev Emits `MessageConsumed` when consuming messages\n     * @param _message - The L2 to L1 message\n     * @param _l2BlockNumber - The block number specifying the block that contains the message we want to consume\n     * @param _leafIndex - The index inside the merkle tree where the message is located\n     * @param _path - The sibling path used to prove inclusion of the message, the _path length directly depends\n     * on the total amount of L2 to L1 messages in the block. i.e. the length of _path is equal to the depth of the\n     * L1 to L2 message tree.\n     */\n    function consume(\n        DataStructures.L2ToL1Msg calldata _message,\n        uint256 _l2BlockNumber,\n        uint256 _leafIndex,\n        bytes32[] calldata _path\n    ) external;\n    // docs:end:outbox_consume\n\n    // docs:start:outbox_has_message_been_consumed_at_block_and_index\n    /**\n     * @notice Checks to see if an index of the L2 to L1 message tree for a specific block has been consumed\n     * @dev - This function does not throw. Out-of-bounds access is considered valid, but will always return false\n     * @param _l2BlockNumber - The block number specifying the block that contains the index of the message we want to check\n     * @param _leafIndex - The index of the message inside the merkle tree\n     */\n    function hasMessageBeenConsumedAtBlockAndIndex(\n        uint256 _l2BlockNumber,\n        uint256 _leafIndex\n    ) external view returns (bool);\n    // docs:end:outbox_has_message_been_consumed_at_block_and_index\n\n    /**\n     * @notice  Fetch the root data for a given block number\n     *          Returns (0, 0) if the block is not proven\n     *\n     * @param _l2BlockNumber - The block number to fetch the root data for\n     *\n     * @return root - The root of the merkle tree containing the L2 to L1 messages\n     * @return minHeight - The min height for the merkle tree that the root corresponds to\n     */\n    function getRootData(\n        uint256 _l2BlockNumber\n    ) external view returns (bytes32 root, uint256 minHeight);\n}\n"
      },
      "project/contracts/evm/aztec-interfaces/ProposalLib.sol": {
        "content": "// SPDX-License-Identifier: Apache-2.0\n// Copyright 2024 Aztec Labs.\npragma solidity >=0.8.27;\n\nimport {Timestamp} from \"./TimeLib.sol\";\nimport {DataStructures} from \"./GovernanceDataStructures.sol\";\nimport {Math} from \"@openzeppelin/contracts/utils/math/Math.sol\";\n\nenum VoteTabulationReturn {\n    Accepted,\n    Rejected,\n    Invalid\n}\n\nenum VoteTabulationInfo {\n    MinimumEqZero,\n    TotalPowerLtMinimum,\n    VotesNeededEqZero,\n    VotesNeededGtTotalPower,\n    VotesCastLtVotesNeeded,\n    YeaLimitEqZero,\n    YeaLimitGtVotesCast,\n    YeaLimitEqVotesCast,\n    YeaVotesEqVotesCast,\n    YeaVotesLeYeaLimit,\n    YeaVotesGtYeaLimit\n}\n\n/**\n * @notice  Library for dealing with proposal math\n *\n *          In particular, dealing with the computation to evaluate\n *          whether a proposal should be rejected or not.\n *\n *          We will be using `Ceil` as the rounding.\n *          The intuition is fairly straight forward, see the voting\n *          as repaying a debt. We want to ensure that the protocol\n *          is never \"underpaid\" when it is to perform an election.\n *          So when it computes the total debt repayment needed to\n *          execute the proposal, it will be rounding up.\n *\n *          If we do not round up, a mulDiv with small values could\n *          for example ending at 0, having a case where no votes are needed\n */\nlibrary ProposalLib {\n    function voteTabulation(\n        DataStructures.Proposal storage _self,\n        uint256 _totalPower\n    ) internal view returns (VoteTabulationReturn, VoteTabulationInfo) {\n        if (_self.config.minimumVotes == 0) {\n            return (\n                VoteTabulationReturn.Invalid,\n                VoteTabulationInfo.MinimumEqZero\n            );\n        }\n        if (_totalPower < _self.config.minimumVotes) {\n            return (\n                VoteTabulationReturn.Rejected,\n                VoteTabulationInfo.TotalPowerLtMinimum\n            );\n        }\n\n        uint256 votesNeeded = Math.mulDiv(\n            _totalPower,\n            _self.config.quorum,\n            1e18,\n            Math.Rounding.Ceil\n        );\n        if (votesNeeded == 0) {\n            return (\n                VoteTabulationReturn.Invalid,\n                VoteTabulationInfo.VotesNeededEqZero\n            );\n        }\n        if (votesNeeded > _totalPower) {\n            return (\n                VoteTabulationReturn.Invalid,\n                VoteTabulationInfo.VotesNeededGtTotalPower\n            );\n        }\n\n        uint256 votesCast = _self.summedBallot.nea + _self.summedBallot.yea;\n        if (votesCast < votesNeeded) {\n            return (\n                VoteTabulationReturn.Rejected,\n                VoteTabulationInfo.VotesCastLtVotesNeeded\n            );\n        }\n\n        // Edge case where all the votes are yea, no need to compute differential\n        // Assumes a \"sane\" value for differential, e.g., you cannot require more votes\n        // to be yes than total votes.\n        if (_self.summedBallot.yea == votesCast) {\n            return (\n                VoteTabulationReturn.Accepted,\n                VoteTabulationInfo.YeaVotesEqVotesCast\n            );\n        }\n\n        uint256 yeaLimitFraction = Math.ceilDiv(\n            1e18 + _self.config.voteDifferential,\n            2\n        );\n        uint256 yeaLimit = Math.mulDiv(\n            votesCast,\n            yeaLimitFraction,\n            1e18,\n            Math.Rounding.Ceil\n        );\n\n        /*if (yeaLimit == 0) {\n      // It should be impossible to hit this case as `yeaLimitFraction` cannot be 0,\n      // and due to rounding, only way to hit this would be if `votesCast = 0`,\n      // which is already handled as `votesCast >= votesNeeded` and `votesNeeded > 0`.\n      return (VoteTabulationReturn.Invalid, VoteTabulationInfo.YeaLimitEqZero);\n    }*/\n        if (yeaLimit > votesCast) {\n            return (\n                VoteTabulationReturn.Invalid,\n                VoteTabulationInfo.YeaLimitGtVotesCast\n            );\n        }\n\n        // We want to see that there are MORE votes on yea than needed\n        // We explictly need MORE to ensure we don't \"tie\".\n        // If we need as many yea as there are votes, we know it is impossible already.\n        // due to the check earlier, that summedBallot.yea == votesCast.\n        if (_self.summedBallot.yea <= yeaLimit) {\n            return (\n                VoteTabulationReturn.Rejected,\n                VoteTabulationInfo.YeaVotesLeYeaLimit\n            );\n        }\n\n        return (\n            VoteTabulationReturn.Accepted,\n            VoteTabulationInfo.YeaVotesGtYeaLimit\n        );\n    }\n\n    /**\n     * @notice\tA stable state is one which cannoted be moved away from\n     */\n    function isStable(\n        DataStructures.Proposal storage _self\n    ) internal view returns (bool) {\n        DataStructures.ProposalState s = _self.state; // cache\n        return\n            s == DataStructures.ProposalState.Executed ||\n            s == DataStructures.ProposalState.Dropped;\n    }\n\n    function pendingThrough(\n        DataStructures.Proposal storage _self\n    ) internal view returns (Timestamp) {\n        return _self.creation + _self.config.votingDelay;\n    }\n\n    function activeThrough(\n        DataStructures.Proposal storage _self\n    ) internal view returns (Timestamp) {\n        return ProposalLib.pendingThrough(_self) + _self.config.votingDuration;\n    }\n\n    function queuedThrough(\n        DataStructures.Proposal storage _self\n    ) internal view returns (Timestamp) {\n        return ProposalLib.activeThrough(_self) + _self.config.executionDelay;\n    }\n\n    function executableThrough(\n        DataStructures.Proposal storage _self\n    ) internal view returns (Timestamp) {\n        return ProposalLib.queuedThrough(_self) + _self.config.gracePeriod;\n    }\n}\n"
      },
      "project/contracts/evm/aztec-interfaces/rollup/BlobLib.sol": {
        "content": "// SPDX-License-Identifier: Apache-2.0\n// Copyright 2024 Aztec Labs.\npragma solidity >=0.8.27;\n\nimport {Constants} from \"../ConstantsGen.sol\";\nimport {Hash} from \"../crypto/Hash.sol\";\nimport {Errors} from \"../CoreErrors.sol\";\nimport {Vm} from \"../Vm.sol\";\n\nlibrary BlobLib {\n    address public constant VM_ADDRESS =\n        address(uint160(uint256(keccak256(\"hevm cheat code\"))));\n\n    /**\n     * @notice  Get the blob base fee\n     *\n     * @dev     If we are in a foundry test, we use the cheatcode to get the blob base fee.\n     *          Otherwise, we use the `block.blobbasefee`\n     *\n     * @return uint256 - The blob base fee\n     */\n    function getBlobBaseFee() internal view returns (uint256) {\n        if (VM_ADDRESS.code.length > 0) {\n            return Vm(VM_ADDRESS).getBlobBaseFee();\n        }\n        return block.blobbasefee;\n    }\n\n    /**\n     * @notice  Validate an L2 block's blobs and return the hashed blobHashes and public inputs.\n     * Input bytes:\n     * input[:1] - num blobs in block\n     * input[1:] - 192 * num blobs of the above _blobInput\n     * @param _blobsInput - The above bytes to verify a blob\n     */\n    function validateBlobs(\n        bytes calldata _blobsInput,\n        bool _checkBlob\n    )\n        internal\n        view\n        returns (\n            // All of the blob hashes included in this blob\n            bytes32[] memory blobHashes,\n            bytes32 blobsHashesCommitment,\n            bytes32 blobPublicInputsHash\n        )\n    {\n        // We cannot input the incorrect number of blobs below, as the blobsHash\n        // and epoch proof verification will fail.\n        uint8 numBlobs = uint8(_blobsInput[0]);\n        blobHashes = new bytes32[](numBlobs);\n        bytes memory blobPublicInputs;\n        for (uint256 i = 0; i < numBlobs; i++) {\n            // Add 1 for the numBlobs prefix\n            uint256 blobInputStart = i * 192 + 1;\n            // Since an invalid blob hash here would fail the consensus checks of\n            // the header, the `blobInput` is implicitly accepted by consensus as well.\n            blobHashes[i] = validateBlob(\n                _blobsInput[blobInputStart:blobInputStart + 192],\n                i,\n                _checkBlob\n            );\n            // We want to extract the 112 bytes we use for public inputs:\n            //  * input[32:64]   - z\n            //  * input[64:96]   - y\n            //  * input[96:144]  - commitment C\n            // Out of 192 bytes per blob.\n            blobPublicInputs = abi.encodePacked(\n                blobPublicInputs,\n                _blobsInput[blobInputStart + 32:blobInputStart +\n                    32 +\n                    Constants.BLOB_PUBLIC_INPUTS_BYTES]\n            );\n        }\n        // Return the hash of all z, y, and Cs, so we can use them in proof verification later\n        blobPublicInputsHash = sha256(blobPublicInputs);\n        // Hash the EVM blob hashes for the block header\n        blobsHashesCommitment = Hash.sha256ToField(\n            abi.encodePacked(blobHashes)\n        );\n    }\n\n    /**\n     * @notice  Validate a blob.\n     * Input bytes:\n     * input[:32]     - versioned_hash\n     * input[32:64]   - z\n     * input[64:96]   - y\n     * input[96:144]  - commitment C\n     * input[144:192] - proof (a commitment to the quotient polynomial q(X))\n     *  - This can be relaxed to happen at the time of `submitProof` instead\n     * @notice Apparently there is no guarantee that the blobs will be processed in the order sent\n     * so the use of blobhash(_blobNumber) may fail in production\n     * @param _blobInput - The above bytes to verify a blob\n     */\n    function validateBlob(\n        bytes calldata _blobInput,\n        uint256 _blobNumber,\n        bool _checkBlob\n    ) internal view returns (bytes32 blobHash) {\n        if (!_checkBlob) {\n            return bytes32(_blobInput[0:32]);\n        }\n        assembly {\n            blobHash := blobhash(_blobNumber)\n        }\n        require(\n            blobHash == bytes32(_blobInput[0:32]),\n            Errors.Rollup__InvalidBlobHash(blobHash)\n        );\n\n        // Staticcall the point eval precompile https://eips.ethereum.org/EIPS/eip-4844#point-evaluation-precompile :\n        (bool success, ) = address(0x0a).staticcall(_blobInput);\n        require(success, Errors.Rollup__InvalidBlobProof(blobHash));\n    }\n}\n"
      },
      "project/contracts/evm/aztec-interfaces/rollup/CheatLib.sol": {
        "content": "// SPDX-License-Identifier: Apache-2.0\n// Copyright 2024 Aztec Labs.\npragma solidity >=0.8.27;\n\nimport {CheatDepositArgs} from \"../IRollup.sol\";\nimport {IVerifier} from \"../IVerifier.sol\";\nimport {STFLib} from \"../rollup/STFLib.sol\";\nimport {StakingLib} from \"../staking/StakingLib.sol\";\n\n/**\n * @title   CheatLib\n * @author  Aztec Labs\n * @notice  A library of cheat codes for the RollupCore\n *          Should be nuked from orbit.\n */\nlibrary CheatLib {\n    function cheat__InitialiseValidatorSet(\n        CheatDepositArgs[] memory _args\n    ) internal {\n        for (uint256 i = 0; i < _args.length; i++) {\n            StakingLib.deposit(\n                _args[i].attester,\n                _args[i].proposer,\n                _args[i].withdrawer,\n                _args[i].amount\n            );\n        }\n    }\n\n    function setEpochVerifier(address _verifier) internal {\n        STFLib.getStorage().config.epochProofVerifier = IVerifier(_verifier);\n    }\n\n    function setVkTreeRoot(bytes32 _vkTreeRoot) internal {\n        STFLib.getStorage().config.vkTreeRoot = _vkTreeRoot;\n    }\n\n    function setProtocolContractTreeRoot(\n        bytes32 _protocolContractTreeRoot\n    ) internal {\n        STFLib\n            .getStorage()\n            .config\n            .protocolContractTreeRoot = _protocolContractTreeRoot;\n    }\n}\n"
      },
      "project/contracts/evm/aztec-interfaces/rollup/FeeLib.sol": {
        "content": "// SPDX-License-Identifier: Apache-2.0\n// Copyright 2024 Aztec Labs.\npragma solidity >=0.8.27;\n\nimport {Math} from \"@openzeppelin/contracts/utils/math/Math.sol\";\nimport {SafeCast} from \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\nimport {SignedMath} from \"@openzeppelin/contracts/utils/math/SignedMath.sol\";\n\nimport {Errors} from \"../CoreErrors.sol\";\n\nimport {Slot, Timestamp, TimeLib} from \"../TimeLib.sol\";\nimport {BlobLib} from \"./BlobLib.sol\";\n\n// The lowest number of fee asset per eth is 10 with a precision of 1e9.\nuint256 constant MINIMUM_FEE_ASSET_PER_ETH = 10e9;\nuint256 constant MAX_FEE_ASSET_PRICE_MODIFIER = 1e6;\nuint256 constant FEE_ASSET_PRICE_UPDATE_FRACTION = 100e6;\n\nuint256 constant L1_GAS_PER_BLOCK_PROPOSED = 150000;\nuint256 constant L1_GAS_PER_EPOCH_VERIFIED = 1000000;\n\nuint256 constant MINIMUM_CONGESTION_MULTIPLIER = 1e9;\n\n// The magic values are used to have the fakeExponential case where\n// (numerator / denominator) is close to 0.117, as that leads to ~1.125 multiplier\n// per increase by TARGET of the numerator;\nuint256 constant MAGIC_CONGESTION_VALUE_DIVISOR = 1e8;\nuint256 constant MAGIC_CONGESTION_VALUE_MULTIPLIER = 854700854;\n\nuint256 constant BLOB_GAS_PER_BLOB = 2 ** 17;\nuint256 constant GAS_PER_BLOB_POINT_EVALUATION = 50_000;\nuint256 constant BLOBS_PER_BLOCK = 3;\n\nstruct OracleInput {\n    int256 feeAssetPriceModifier;\n}\n\nstruct ManaBaseFeeComponents {\n    uint256 congestionCost;\n    uint256 congestionMultiplier;\n    uint256 dataCost;\n    uint256 gasCost;\n    uint256 provingCost;\n}\n\nstruct FeeHeader {\n    uint256 excessMana;\n    uint256 manaUsed;\n    uint256 feeAssetPriceNumerator;\n    uint256 congestionCost;\n    uint256 provingCost;\n}\n\nstruct L1FeeData {\n    uint256 baseFee;\n    uint256 blobFee;\n}\n\nstruct L1GasOracleValues {\n    L1FeeData pre;\n    L1FeeData post;\n    Slot slotOfChange;\n}\n\ntype EthValue is uint256;\n\ntype FeeAssetValue is uint256;\n\n// Precision of 1e9\ntype FeeAssetPerEthE9 is uint256;\n\nfunction addEthValue(EthValue _a, EthValue _b) pure returns (EthValue) {\n    return EthValue.wrap(EthValue.unwrap(_a) + EthValue.unwrap(_b));\n}\n\nfunction subEthValue(EthValue _a, EthValue _b) pure returns (EthValue) {\n    return EthValue.wrap(EthValue.unwrap(_a) - EthValue.unwrap(_b));\n}\n\nusing {addEthValue as +, subEthValue as -} for EthValue global;\n\nlibrary PriceLib {\n    function toEth(\n        FeeAssetValue _feeAssetValue,\n        FeeAssetPerEthE9 _feeAssetPerEth\n    ) internal pure returns (EthValue) {\n        return\n            EthValue.wrap(\n                Math.mulDiv(\n                    FeeAssetValue.unwrap(_feeAssetValue),\n                    1e9,\n                    FeeAssetPerEthE9.unwrap(_feeAssetPerEth),\n                    Math.Rounding.Ceil\n                )\n            );\n    }\n\n    function toFeeAsset(\n        EthValue _ethValue,\n        FeeAssetPerEthE9 _feeAssetPerEth\n    ) internal pure returns (FeeAssetValue) {\n        return\n            FeeAssetValue.wrap(\n                Math.mulDiv(\n                    EthValue.unwrap(_ethValue),\n                    FeeAssetPerEthE9.unwrap(_feeAssetPerEth),\n                    1e9,\n                    Math.Rounding.Ceil\n                )\n            );\n    }\n}\n\nstruct CompressedFeeHeader {\n    uint64 congestionCost;\n    uint64 provingCost;\n    uint48 feeAssetPriceNumerator;\n    uint48 excessMana;\n    uint32 manaUsed;\n}\n\nlibrary FeeHeaderLib {\n    using SafeCast for uint256;\n\n    function getManaUsed(\n        CompressedFeeHeader storage _compressedFeeHeader\n    ) internal view returns (uint256) {\n        return _compressedFeeHeader.manaUsed;\n    }\n\n    function getCongestionCost(\n        CompressedFeeHeader storage _compressedFeeHeader\n    ) internal view returns (uint256) {\n        return _compressedFeeHeader.congestionCost;\n    }\n\n    function getProvingCost(\n        CompressedFeeHeader storage _compressedFeeHeader\n    ) internal view returns (uint256) {\n        return _compressedFeeHeader.provingCost;\n    }\n\n    function compress(\n        FeeHeader memory _feeHeader\n    ) internal pure returns (CompressedFeeHeader memory) {\n        return\n            CompressedFeeHeader({\n                excessMana: _feeHeader.excessMana.toUint48(),\n                manaUsed: _feeHeader.manaUsed.toUint32(),\n                feeAssetPriceNumerator: _feeHeader\n                    .feeAssetPriceNumerator\n                    .toUint48(),\n                congestionCost: _feeHeader.congestionCost.toUint64(),\n                provingCost: _feeHeader.provingCost.toUint64()\n            });\n    }\n\n    function decompress(\n        CompressedFeeHeader memory _compressedFeeHeader\n    ) internal pure returns (FeeHeader memory) {\n        return\n            FeeHeader({\n                excessMana: _compressedFeeHeader.excessMana,\n                manaUsed: _compressedFeeHeader.manaUsed,\n                feeAssetPriceNumerator: _compressedFeeHeader\n                    .feeAssetPriceNumerator,\n                congestionCost: _compressedFeeHeader.congestionCost,\n                provingCost: _compressedFeeHeader.provingCost\n            });\n    }\n}\n\nstruct FeeStore {\n    uint256 manaTarget;\n    uint256 congestionUpdateFraction;\n    EthValue provingCostPerMana;\n    L1GasOracleValues l1GasOracleValues;\n    mapping(uint256 blockNumber => CompressedFeeHeader feeHeader) feeHeaders;\n}\n\nlibrary FeeLib {\n    using Math for uint256;\n    using SafeCast for int256;\n    using SafeCast for uint256;\n    using SignedMath for int256;\n    using PriceLib for EthValue;\n    using TimeLib for Slot;\n    using TimeLib for Timestamp;\n\n    using FeeHeaderLib for FeeHeader;\n    using FeeHeaderLib for CompressedFeeHeader;\n\n    Slot internal constant LIFETIME = Slot.wrap(5);\n    Slot internal constant LAG = Slot.wrap(2);\n\n    bytes32 private constant FEE_STORE_POSITION =\n        keccak256(\"aztec.fee.storage\");\n\n    function initialize(\n        uint256 _manaTarget,\n        EthValue _provingCostPerMana\n    ) internal {\n        FeeStore storage feeStore = getStorage();\n\n        feeStore.manaTarget = _manaTarget;\n        feeStore.congestionUpdateFraction =\n            (_manaTarget * MAGIC_CONGESTION_VALUE_MULTIPLIER) /\n            MAGIC_CONGESTION_VALUE_DIVISOR;\n        feeStore.provingCostPerMana = _provingCostPerMana;\n\n        feeStore.feeHeaders[0] = FeeHeader({\n            excessMana: 0,\n            feeAssetPriceNumerator: 0,\n            manaUsed: 0,\n            congestionCost: 0,\n            provingCost: 0\n        }).compress();\n\n        feeStore.l1GasOracleValues = L1GasOracleValues({\n            pre: L1FeeData({baseFee: 1 gwei, blobFee: 1}),\n            post: L1FeeData({\n                baseFee: block.basefee,\n                blobFee: BlobLib.getBlobBaseFee()\n            }),\n            slotOfChange: LIFETIME\n        });\n    }\n\n    function updateManaTarget(uint256 _manaTarget) internal {\n        FeeStore storage feeStore = getStorage();\n        feeStore.manaTarget = _manaTarget;\n        feeStore.congestionUpdateFraction =\n            (_manaTarget * MAGIC_CONGESTION_VALUE_MULTIPLIER) /\n            MAGIC_CONGESTION_VALUE_DIVISOR;\n    }\n\n    function writeFeeHeader(\n        uint256 _blockNumber,\n        int256 _feeAssetPriceModifier,\n        uint256 _manaUsed,\n        uint256 _congestionCost,\n        uint256 _provingCost\n    ) internal {\n        require(\n            SignedMath.abs(_feeAssetPriceModifier) <=\n                MAX_FEE_ASSET_PRICE_MODIFIER,\n            Errors.FeeLib__InvalidFeeAssetPriceModifier()\n        );\n        FeeStore storage feeStore = getStorage();\n        CompressedFeeHeader storage parentFeeHeader = feeStore.feeHeaders[\n            _blockNumber - 1\n        ];\n        feeStore.feeHeaders[_blockNumber] = FeeHeader({\n            excessMana: FeeLib.computeExcessMana(parentFeeHeader),\n            feeAssetPriceNumerator: FeeLib.clampedAdd(\n                parentFeeHeader.feeAssetPriceNumerator,\n                _feeAssetPriceModifier\n            ),\n            manaUsed: _manaUsed,\n            congestionCost: _congestionCost,\n            provingCost: _provingCost\n        }).compress();\n    }\n\n    function updateL1GasFeeOracle() internal {\n        Slot slot = Timestamp.wrap(block.timestamp).slotFromTimestamp();\n        // The slot where we find a new queued value acceptable\n        FeeStore storage feeStore = getStorage();\n\n        Slot acceptableSlot = feeStore.l1GasOracleValues.slotOfChange +\n            (LIFETIME - LAG);\n\n        if (slot < acceptableSlot) {\n            return;\n        }\n\n        feeStore.l1GasOracleValues.pre = feeStore.l1GasOracleValues.post;\n        feeStore.l1GasOracleValues.post = L1FeeData({\n            baseFee: block.basefee,\n            blobFee: BlobLib.getBlobBaseFee()\n        });\n        feeStore.l1GasOracleValues.slotOfChange = slot + LAG;\n    }\n\n    function getL1FeesAt(\n        Timestamp _timestamp\n    ) internal view returns (L1FeeData memory) {\n        FeeStore storage feeStore = getStorage();\n        return\n            _timestamp.slotFromTimestamp() <\n                feeStore.l1GasOracleValues.slotOfChange\n                ? feeStore.l1GasOracleValues.pre\n                : feeStore.l1GasOracleValues.post;\n    }\n\n    function getManaBaseFeeComponentsAt(\n        uint256 _blockOfInterest,\n        Timestamp _timestamp,\n        bool _inFeeAsset\n    ) internal view returns (ManaBaseFeeComponents memory) {\n        FeeStore storage feeStore = getStorage();\n\n        uint256 manaTarget = feeStore.manaTarget;\n\n        if (manaTarget == 0) {\n            return\n                ManaBaseFeeComponents({\n                    dataCost: 0,\n                    gasCost: 0,\n                    provingCost: 0,\n                    congestionCost: 0,\n                    congestionMultiplier: 0\n                });\n        }\n\n        EthValue gasCostPerMana;\n        EthValue dataCostPerMana;\n        EthValue total;\n        {\n            uint256 gasUsed = L1_GAS_PER_BLOCK_PROPOSED +\n                BLOBS_PER_BLOCK *\n                GAS_PER_BLOB_POINT_EVALUATION +\n                L1_GAS_PER_EPOCH_VERIFIED /\n                TimeLib.getStorage().epochDuration;\n\n            L1FeeData memory fees = FeeLib.getL1FeesAt(_timestamp);\n            gasCostPerMana = EthValue.wrap(\n                Math.mulDiv(\n                    gasUsed,\n                    fees.baseFee,\n                    manaTarget,\n                    Math.Rounding.Ceil\n                )\n            );\n            dataCostPerMana = EthValue.wrap(\n                Math.mulDiv(\n                    BLOBS_PER_BLOCK * BLOB_GAS_PER_BLOB,\n                    fees.blobFee,\n                    manaTarget,\n                    Math.Rounding.Ceil\n                )\n            );\n            total =\n                dataCostPerMana +\n                gasCostPerMana +\n                feeStore.provingCostPerMana;\n        }\n\n        CompressedFeeHeader storage parentFeeHeader = feeStore.feeHeaders[\n            _blockOfInterest\n        ];\n        uint256 excessMana = FeeLib.clampedAdd(\n            parentFeeHeader.excessMana + parentFeeHeader.manaUsed,\n            -int256(manaTarget)\n        );\n        uint256 congestionMultiplier_ = congestionMultiplier(excessMana);\n\n        EthValue congestionCost = EthValue.wrap(\n            Math.mulDiv(\n                EthValue.unwrap(total),\n                congestionMultiplier_,\n                MINIMUM_CONGESTION_MULTIPLIER,\n                Math.Rounding.Floor\n            )\n        ) - total;\n\n        FeeAssetPerEthE9 feeAssetPrice = _inFeeAsset\n            ? FeeLib.getFeeAssetPerEthAtBlock(_blockOfInterest)\n            : FeeAssetPerEthE9.wrap(1e9);\n\n        return\n            ManaBaseFeeComponents({\n                dataCost: FeeAssetValue.unwrap(\n                    dataCostPerMana.toFeeAsset(feeAssetPrice)\n                ),\n                gasCost: FeeAssetValue.unwrap(\n                    gasCostPerMana.toFeeAsset(feeAssetPrice)\n                ),\n                provingCost: FeeAssetValue.unwrap(\n                    feeStore.provingCostPerMana.toFeeAsset(feeAssetPrice)\n                ),\n                congestionCost: FeeAssetValue.unwrap(\n                    congestionCost.toFeeAsset(feeAssetPrice)\n                ),\n                congestionMultiplier: congestionMultiplier_\n            });\n    }\n\n    function getManaLimit() internal view returns (uint256) {\n        FeeStore storage feeStore = getStorage();\n        return feeStore.manaTarget * 2;\n    }\n\n    function getFeeAssetPerEthAtBlock(\n        uint256 _blockNumber\n    ) internal view returns (FeeAssetPerEthE9) {\n        FeeStore storage feeStore = getStorage();\n        return\n            getFeeAssetPerEth(\n                feeStore.feeHeaders[_blockNumber].feeAssetPriceNumerator\n            );\n    }\n\n    function computeExcessMana(\n        CompressedFeeHeader storage _feeHeader\n    ) internal view returns (uint256) {\n        FeeStore storage feeStore = getStorage();\n        return\n            clampedAdd(\n                _feeHeader.excessMana + _feeHeader.manaUsed,\n                -int256(feeStore.manaTarget)\n            );\n    }\n\n    function congestionMultiplier(\n        uint256 _numerator\n    ) internal view returns (uint256) {\n        FeeStore storage feeStore = getStorage();\n        return\n            fakeExponential(\n                MINIMUM_CONGESTION_MULTIPLIER,\n                _numerator,\n                feeStore.congestionUpdateFraction\n            );\n    }\n\n    function getFeeAssetPerEth(\n        uint256 _numerator\n    ) internal pure returns (FeeAssetPerEthE9) {\n        return\n            FeeAssetPerEthE9.wrap(\n                fakeExponential(\n                    MINIMUM_FEE_ASSET_PER_ETH,\n                    _numerator,\n                    FEE_ASSET_PRICE_UPDATE_FRACTION\n                )\n            );\n    }\n\n    function summedBaseFee(\n        ManaBaseFeeComponents memory _components\n    ) internal pure returns (uint256) {\n        return\n            _components.dataCost +\n            _components.gasCost +\n            _components.provingCost +\n            _components.congestionCost;\n    }\n\n    function getStorage()\n        internal\n        pure\n        returns (FeeStore storage storageStruct)\n    {\n        bytes32 position = FEE_STORE_POSITION;\n        assembly {\n            storageStruct.slot := position\n        }\n    }\n\n    /**\n     * @notice  Clamps the addition of a signed integer to a uint256\n     *          Useful for running values, whose minimum value will be 0\n     *          but should not throw if going below.\n     * @param _a The base value\n     * @param _b The value to add\n     * @return The clamped value\n     */\n    function clampedAdd(uint256 _a, int256 _b) internal pure returns (uint256) {\n        if (_b >= 0) {\n            return _a + _b.toUint256();\n        }\n\n        uint256 sub = SignedMath.abs(_b);\n\n        if (_a > sub) {\n            return _a - sub;\n        }\n\n        return 0;\n    }\n\n    /**\n     * @notice An approximation of the exponential function: factor * e ** (numerator / denominator)\n     *\n     *         The function is the same as used in EIP-4844\n     *         https://github.com/ethereum/EIPs/blob/master/EIPS/eip-4844.md\n     *\n     *         Approximated using a taylor series.\n     *         For shorthand below, let `a = factor`, `x = numerator`, `d = denominator`\n     *\n     *         f(x) =  a\n     *              + (a * x) / d\n     *              + (a * x ** 2) / (2 * d ** 2)\n     *              + (a * x ** 3) / (6 * d ** 3)\n     *              + (a * x ** 4) / (24 * d ** 4)\n     *              + (a * x ** 5) / (120 * d ** 5)\n     *              + ...\n     *\n     *         For integer precision purposes, we will multiply by the denominator for intermediary steps and then\n     *         finally do a division by it.\n     *         The notation below might look slightly strange, but it is to try to convey the program flow below.\n     *\n     *         e(x) = (          a * d\n     *                 +         a * d * x / d\n     *                 +       ((a * d * x / d) * x) / (2 * d)\n     *                 +     ((((a * d * x / d) * x) / (2 * d)) * x) / (3 * d)\n     *                 +   ((((((a * d * x / d) * x) / (2 * d)) * x) / (3 * d)) * x) / (4 * d)\n     *                 + ((((((((a * d * x / d) * x) / (2 * d)) * x) / (3 * d)) * x) / (4 * d)) * x) / (5 * d)\n     *                 + ...\n     *                 ) / d\n     *\n     *         The notation might make it a bit of a pain to look at, but f(x) and e(x) are the same.\n     *         Gotta love integer math.\n     *\n     * @dev   Notice that as _numerator grows, the computation will quickly overflow.\n     *        As long as the `_denominator` is fairly small, it won't bring us back down to not overflow\n     *        For our purposes, this is acceptable, as if we have a fee that is so high that it would overflow and throw\n     *        then we would have other problems.\n     *\n     * @param _factor The base value\n     * @param _numerator The numerator\n     * @param _denominator The denominator\n     * @return The approximated value `_factor * e ** (_numerator / _denominator)`\n     */\n    function fakeExponential(\n        uint256 _factor,\n        uint256 _numerator,\n        uint256 _denominator\n    ) private pure returns (uint256) {\n        uint256 i = 1;\n        uint256 output = 0;\n        uint256 numeratorAccumulator = _factor * _denominator;\n        while (numeratorAccumulator > 0) {\n            output += numeratorAccumulator;\n            numeratorAccumulator =\n                (numeratorAccumulator * _numerator) /\n                (_denominator * i);\n            i += 1;\n        }\n        return output / _denominator;\n    }\n}\n"
      },
      "project/contracts/evm/aztec-interfaces/rollup/HeaderLib.sol": {
        "content": "// SPDX-License-Identifier: Apache-2.0\n// Copyright 2024 Aztec Labs.\npragma solidity >=0.8.27;\n\nimport {Constants} from \"../ConstantsGen.sol\";\nimport {Errors} from \"../CoreErrors.sol\";\n\nimport {Slot, Timestamp} from \"../TimeLib.sol\";\n\nstruct AppendOnlyTreeSnapshot {\n    bytes32 root;\n    uint32 nextAvailableLeafIndex;\n}\n\nstruct PartialStateReference {\n    AppendOnlyTreeSnapshot noteHashTree;\n    AppendOnlyTreeSnapshot nullifierTree;\n    AppendOnlyTreeSnapshot contractTree;\n    AppendOnlyTreeSnapshot publicDataTree;\n}\n\nstruct StateReference {\n    AppendOnlyTreeSnapshot l1ToL2MessageTree;\n    // Note: Can't use \"partial\" name here as in protocol specs because it is a reserved solidity keyword\n    PartialStateReference partialStateReference;\n}\n\nstruct GasFees {\n    uint256 feePerDaGas;\n    uint256 feePerL2Gas;\n}\n\nstruct GlobalVariables {\n    uint256 chainId;\n    uint256 version;\n    uint256 blockNumber;\n    Slot slotNumber;\n    Timestamp timestamp;\n    address coinbase;\n    bytes32 feeRecipient;\n    GasFees gasFees;\n}\n\nstruct ContentCommitment {\n    uint256 numTxs;\n    bytes32 blobsHash;\n    bytes32 inHash;\n    bytes32 outHash;\n}\n\nstruct Header {\n    AppendOnlyTreeSnapshot lastArchive;\n    ContentCommitment contentCommitment;\n    StateReference stateReference;\n    GlobalVariables globalVariables;\n    uint256 totalFees;\n    uint256 totalManaUsed;\n}\n\n/**\n * @title Header Library\n * @author Aztec Labs\n * @notice Decoding and validating an L2 block header\n * Concerned with readability and velocity of development not giving a damn about gas costs.\n *\n * -------------------\n * You can use https://gist.github.com/LHerskind/724a7e362c97e8ac2902c6b961d36830 to generate the below outline.\n * -------------------\n * L2 Block Header specification\n * -------------------\n *\n *  | byte start                                                                       | num bytes    | name\n *  | ---                                                                              | ---          | ---\n *  |                                                                                  |              | Header {\n *  | 0x0000                                                                           | 0x20         |   lastArchive.root\n *  | 0x0020                                                                           | 0x04         |   lastArchive.nextAvailableLeafIndex\n *  |                                                                                  |              |   ContentCommitment {\n *  | 0x0024                                                                           | 0x20         |     numTxs\n *  | 0x0044                                                                           | 0x20         |     blobsHash\n *  | 0x0064                                                                           | 0x20         |     inHash\n *  | 0x0084                                                                           | 0x20         |     outHash\n *  |                                                                                  |              |   StateReference {\n *  | 0x00a4                                                                           | 0x20         |     l1ToL2MessageTree.root\n *  | 0x00c4                                                                           | 0x04         |     l1ToL2MessageTree.nextAvailableLeafIndex\n *  |                                                                                  |              |     PartialStateReference {\n *  | 0x00c8                                                                           | 0x20         |       noteHashTree.root\n *  | 0x00e8                                                                           | 0x04         |       noteHashTree.nextAvailableLeafIndex\n *  | 0x00ec                                                                           | 0x20         |       nullifierTree.root\n *  | 0x010c                                                                           | 0x04         |       nullifierTree.nextAvailableLeafIndex\n *  | 0x0110                                                                           | 0x20         |       publicDataTree.root\n *  | 0x0130                                                                           | 0x04         |       publicDataTree.nextAvailableLeafIndex\n *  |                                                                                  |              |     }\n *  |                                                                                  |              |   }\n *  |                                                                                  |              |   GlobalVariables {\n *  | 0x0134                                                                           | 0x20         |     chainId\n *  | 0x0154                                                                           | 0x20         |     version\n *  | 0x0174                                                                           | 0x20         |     blockNumber\n *  | 0x0194                                                                           | 0x20         |     slotNumber\n *  | 0x01b4                                                                           | 0x20         |     timestamp\n *  | 0x01d4                                                                           | 0x14         |     coinbase\n *  | 0x01e8                                                                           | 0x20         |     feeRecipient\n *  | 0x0208                                                                           | 0x20         |     gasFees.feePerDaGas\n *  | 0x0228                                                                           | 0x20         |     gasFees.feePerL2Gas\n *  |                                                                                  |              |   }\n *  |                                                                                  |              | }\n *  | 0x0248                                                                           | 0x20         | total_fees\n *  | 0x0268                                                                           | 0x20         | total_mana_used\n *  | ---                                                                              | ---          | ---\n */\nlibrary HeaderLib {\n    uint256 private constant HEADER_LENGTH =\n        Constants.BLOCK_HEADER_LENGTH_BYTES; // Header byte length\n\n    /**\n     * @notice Decodes the header\n     * @param _header - The header calldata\n     * @return The decoded header\n     */\n    function decode(\n        bytes calldata _header\n    ) internal pure returns (Header memory) {\n        require(\n            _header.length == HEADER_LENGTH,\n            Errors.HeaderLib__InvalidHeaderSize(HEADER_LENGTH, _header.length)\n        );\n\n        Header memory header;\n\n        // Reading lastArchive\n        header.lastArchive = AppendOnlyTreeSnapshot(\n            bytes32(_header[0x0000:0x0020]),\n            uint32(bytes4(_header[0x0020:0x0024]))\n        );\n\n        // Reading ContentCommitment\n        header.contentCommitment.numTxs = uint256(\n            bytes32(_header[0x0024:0x0044])\n        );\n        header.contentCommitment.blobsHash = bytes32(_header[0x0044:0x0064]);\n        header.contentCommitment.inHash = bytes32(_header[0x0064:0x0084]);\n        header.contentCommitment.outHash = bytes32(_header[0x0084:0x00a4]);\n\n        // Reading StateReference\n        header.stateReference.l1ToL2MessageTree = AppendOnlyTreeSnapshot(\n            bytes32(_header[0x00a4:0x00c4]),\n            uint32(bytes4(_header[0x00c4:0x00c8]))\n        );\n        header\n            .stateReference\n            .partialStateReference\n            .noteHashTree = AppendOnlyTreeSnapshot(\n            bytes32(_header[0x00c8:0x00e8]),\n            uint32(bytes4(_header[0x00e8:0x00ec]))\n        );\n        header\n            .stateReference\n            .partialStateReference\n            .nullifierTree = AppendOnlyTreeSnapshot(\n            bytes32(_header[0x00ec:0x010c]),\n            uint32(bytes4(_header[0x010c:0x0110]))\n        );\n        header\n            .stateReference\n            .partialStateReference\n            .publicDataTree = AppendOnlyTreeSnapshot(\n            bytes32(_header[0x0110:0x0130]),\n            uint32(bytes4(_header[0x0130:0x0134]))\n        );\n\n        // Reading GlobalVariables\n        header.globalVariables.chainId = uint256(\n            bytes32(_header[0x0134:0x0154])\n        );\n        header.globalVariables.version = uint256(\n            bytes32(_header[0x0154:0x0174])\n        );\n        header.globalVariables.blockNumber = uint256(\n            bytes32(_header[0x0174:0x0194])\n        );\n        header.globalVariables.slotNumber = Slot.wrap(\n            uint256(bytes32(_header[0x0194:0x01b4]))\n        );\n        header.globalVariables.timestamp = Timestamp.wrap(\n            uint256(bytes32(_header[0x01b4:0x01d4]))\n        );\n        header.globalVariables.coinbase = address(\n            bytes20(_header[0x01d4:0x01e8])\n        );\n        header.globalVariables.feeRecipient = bytes32(_header[0x01e8:0x0208]);\n        header.globalVariables.gasFees.feePerDaGas = uint256(\n            bytes32(_header[0x0208:0x0228])\n        );\n        header.globalVariables.gasFees.feePerL2Gas = uint256(\n            bytes32(_header[0x0228:0x0248])\n        );\n\n        // Reading totalFees\n        header.totalFees = uint256(bytes32(_header[0x0248:0x0268]));\n\n        // Reading totalManaUsed\n        header.totalManaUsed = uint256(bytes32(_header[0x0268:0x0288]));\n\n        return header;\n    }\n}\n"
      },
      "project/contracts/evm/aztec-interfaces/rollup/ProposeLib.sol": {
        "content": "// SPDX-License-Identifier: Apache-2.0\n// Copyright 2024 Aztec Labs.\npragma solidity >=0.8.27;\n\nimport {RollupStore, IRollupCore, BlockLog, BlockHeaderValidationFlags} from \"../IRollup.sol\";\nimport {MerkleLib} from \"../crypto/MerkleLib.sol\";\nimport {SignatureLib} from \"../crypto/SignatureLib.sol\";\nimport {Signature} from \"../crypto/SignatureLib.sol\";\nimport {Errors} from \"../CoreErrors.sol\";\nimport {OracleInput, FeeLib, ManaBaseFeeComponents} from \"./FeeLib.sol\";\nimport {StakingLib} from \"../staking/StakingLib.sol\";\nimport {Timestamp, Slot, Epoch, TimeLib} from \"../TimeLib.sol\";\nimport {ValidatorSelectionLib} from \"../validator-selection/ValidatorSelectionLib.sol\";\nimport {BlobLib} from \"./BlobLib.sol\";\nimport {Header, HeaderLib} from \"./HeaderLib.sol\";\nimport {STFLib} from \"./STFLib.sol\";\n\nstruct ProposeArgs {\n    bytes32 archive;\n    bytes32 blockHash;\n    OracleInput oracleInput;\n    bytes header;\n    bytes32[] txHashes;\n}\n\nstruct InterimProposeValues {\n    bytes32[] blobHashes;\n    bytes32 blobsHashesCommitment;\n    bytes32 blobPublicInputsHash;\n    bytes32 inHash;\n    uint256 outboxMinsize;\n}\n\n/**\n * @param header - The proposed block header\n * @param attestations - The signatures for the attestations\n * @param digest - The digest that signatures signed\n * @param currentTime - The time of execution\n * @param blobsHashesCommitment - The blobs hash for this block, provided for simpler future simulation\n * @param flags - Flags specific to the execution, whether certain checks should be skipped\n */\nstruct ValidateHeaderArgs {\n    Header header;\n    Signature[] attestations;\n    bytes32 digest;\n    Timestamp currentTime;\n    uint256 manaBaseFee;\n    bytes32 blobsHashesCommitment;\n    BlockHeaderValidationFlags flags;\n}\n\nlibrary ProposeLib {\n    using TimeLib for Timestamp;\n    using TimeLib for Slot;\n    using TimeLib for Epoch;\n\n    /**\n     * @notice  Publishes the body and propose the block\n     * @dev     `eth_log_handlers` rely on this function\n     *\n     * @param _args - The arguments to propose the block\n     * @param _signatures - Signatures from the validators\n     * @param _blobInput - The blob evaluation KZG proof, challenge, and opening required for the precompile.\n     */\n    function propose(\n        ProposeArgs calldata _args,\n        Signature[] memory _signatures,\n        bytes calldata _blobInput,\n        bool _checkBlob\n    ) internal {\n        if (STFLib.canPruneAtTime(Timestamp.wrap(block.timestamp))) {\n            STFLib.prune();\n        }\n        FeeLib.updateL1GasFeeOracle();\n\n        InterimProposeValues memory v;\n        // Since an invalid blob hash here would fail the consensus checks of\n        // the header, the `blobInput` is implicitly accepted by consensus as well.\n        (\n            v.blobHashes,\n            v.blobsHashesCommitment,\n            v.blobPublicInputsHash\n        ) = BlobLib.validateBlobs(_blobInput, _checkBlob);\n\n        Header memory header = HeaderLib.decode(_args.header);\n\n        ValidatorSelectionLib.setupEpoch(StakingLib.getStorage());\n\n        ManaBaseFeeComponents memory components = getManaBaseFeeComponentsAt(\n            Timestamp.wrap(block.timestamp),\n            true\n        );\n\n        validateHeader(\n            ValidateHeaderArgs({\n                header: header,\n                attestations: _signatures,\n                digest: digest(_args),\n                currentTime: Timestamp.wrap(block.timestamp),\n                manaBaseFee: FeeLib.summedBaseFee(components),\n                blobsHashesCommitment: v.blobsHashesCommitment,\n                flags: BlockHeaderValidationFlags({\n                    ignoreDA: false,\n                    ignoreSignatures: false\n                })\n            })\n        );\n\n        RollupStore storage rollupStore = STFLib.getStorage();\n        uint256 blockNumber = ++rollupStore.tips.pendingBlockNumber;\n\n        rollupStore.blocks[blockNumber] = BlockLog({\n            archive: _args.archive,\n            blockHash: _args.blockHash,\n            slotNumber: header.globalVariables.slotNumber\n        });\n\n        FeeLib.writeFeeHeader(\n            blockNumber,\n            _args.oracleInput.feeAssetPriceModifier,\n            header.totalManaUsed,\n            components.congestionCost,\n            components.provingCost\n        );\n\n        rollupStore.blobPublicInputsHashes[blockNumber] = v\n            .blobPublicInputsHash;\n\n        // @note  The block number here will always be >=1 as the genesis block is at 0\n        v.inHash = rollupStore.config.inbox.consume(blockNumber);\n        require(\n            header.contentCommitment.inHash == v.inHash,\n            Errors.Rollup__InvalidInHash(\n                v.inHash,\n                header.contentCommitment.inHash\n            )\n        );\n\n        // TODO(#7218): Revert to fixed height tree for outbox, currently just providing min as interim\n        // Min size = smallest path of the rollup tree + 1\n        (v.outboxMinsize, ) = MerkleLib.computeMinMaxPathLength(\n            header.contentCommitment.numTxs\n        );\n        rollupStore.config.outbox.insert(\n            blockNumber,\n            header.contentCommitment.outHash,\n            v.outboxMinsize + 1\n        );\n\n        emit IRollupCore.L2BlockProposed(\n            blockNumber,\n            _args.archive,\n            v.blobHashes\n        );\n    }\n\n    // @note: not view as sampling validators uses tstore\n    function validateHeader(ValidateHeaderArgs memory _args) internal {\n        require(\n            block.chainid == _args.header.globalVariables.chainId,\n            Errors.Rollup__InvalidChainId(\n                block.chainid,\n                _args.header.globalVariables.chainId\n            )\n        );\n\n        require(\n            _args.header.totalManaUsed <= FeeLib.getManaLimit(),\n            Errors.Rollup__ManaLimitExceeded()\n        );\n\n        RollupStore storage rollupStore = STFLib.getStorage();\n\n        require(\n            _args.header.globalVariables.version == rollupStore.config.version,\n            Errors.Rollup__InvalidVersion(\n                rollupStore.config.version,\n                _args.header.globalVariables.version\n            )\n        );\n\n        uint256 pendingBlockNumber = STFLib.getEffectivePendingBlockNumber(\n            _args.currentTime\n        );\n\n        require(\n            _args.header.globalVariables.blockNumber == pendingBlockNumber + 1,\n            Errors.Rollup__InvalidBlockNumber(\n                pendingBlockNumber + 1,\n                _args.header.globalVariables.blockNumber\n            )\n        );\n\n        bytes32 tipArchive = rollupStore.blocks[pendingBlockNumber].archive;\n        require(\n            tipArchive == _args.header.lastArchive.root,\n            Errors.Rollup__InvalidArchive(\n                tipArchive,\n                _args.header.lastArchive.root\n            )\n        );\n\n        Slot slot = _args.header.globalVariables.slotNumber;\n        Slot lastSlot = rollupStore.blocks[pendingBlockNumber].slotNumber;\n        require(\n            slot > lastSlot,\n            Errors.Rollup__SlotAlreadyInChain(lastSlot, slot)\n        );\n\n        Slot currentSlot = _args.currentTime.slotFromTimestamp();\n        require(\n            slot == currentSlot,\n            Errors.HeaderLib__InvalidSlotNumber(currentSlot, slot)\n        );\n\n        Timestamp timestamp = TimeLib.toTimestamp(slot);\n        require(\n            _args.header.globalVariables.timestamp == timestamp,\n            Errors.Rollup__InvalidTimestamp(\n                timestamp,\n                _args.header.globalVariables.timestamp\n            )\n        );\n\n        require(\n            timestamp <= _args.currentTime,\n            Errors.Rollup__TimestampInFuture(_args.currentTime, timestamp)\n        );\n\n        require(\n            _args.flags.ignoreDA ||\n                _args.header.contentCommitment.blobsHash ==\n                _args.blobsHashesCommitment,\n            Errors.Rollup__UnavailableTxs(\n                _args.header.contentCommitment.blobsHash\n            )\n        );\n\n        require(\n            _args.header.globalVariables.gasFees.feePerDaGas == 0,\n            Errors.Rollup__NonZeroDaFee()\n        );\n        require(\n            _args.header.globalVariables.gasFees.feePerL2Gas ==\n                _args.manaBaseFee,\n            Errors.Rollup__InvalidManaBaseFee(\n                _args.manaBaseFee,\n                _args.header.globalVariables.gasFees.feePerL2Gas\n            )\n        );\n\n        ValidatorSelectionLib.verify(\n            StakingLib.getStorage(),\n            slot,\n            slot.epochFromSlot(),\n            _args.attestations,\n            _args.digest,\n            _args.flags\n        );\n    }\n\n    /**\n     * @notice  Gets the mana base fee components\n     *          For more context, consult:\n     *          https://github.com/AztecProtocol/engineering-designs/blob/main/in-progress/8757-fees/design.md\n     *\n     * @param _timestamp - The timestamp of the block\n     * @param _inFeeAsset - Whether to return the fee in the fee asset or ETH\n     *\n     * @return The mana base fee components\n     */\n    function getManaBaseFeeComponentsAt(\n        Timestamp _timestamp,\n        bool _inFeeAsset\n    ) internal view returns (ManaBaseFeeComponents memory) {\n        uint256 blockOfInterest = STFLib.getEffectivePendingBlockNumber(\n            _timestamp\n        );\n        return\n            FeeLib.getManaBaseFeeComponentsAt(\n                blockOfInterest,\n                _timestamp,\n                _inFeeAsset\n            );\n    }\n\n    function digest(ProposeArgs memory _args) internal pure returns (bytes32) {\n        return\n            keccak256(\n                abi.encode(\n                    SignatureLib.SignatureDomainSeparator.blockAttestation,\n                    _args\n                )\n            );\n    }\n}\n"
      },
      "project/contracts/evm/aztec-interfaces/rollup/RewardLib.sol": {
        "content": "// SPDX-License-Identifier: Apache-2.0\n// Copyright 2024 Aztec Labs.\npragma solidity >=0.8.27;\n\nimport {RollupStore, EpochRewards} from \"../IRollup.sol\";\nimport {Errors} from \"../CoreErrors.sol\";\nimport {STFLib} from \"./STFLib.sol\";\nimport {Epoch, Timestamp, Slot, TimeLib} from \"../TimeLib.sol\";\n\nlibrary RewardLib {\n    using TimeLib for Timestamp;\n    using TimeLib for Epoch;\n\n    function claimSequencerRewards(\n        address _recipient\n    ) internal returns (uint256) {\n        RollupStore storage rollupStore = STFLib.getStorage();\n        uint256 amount = rollupStore.sequencerRewards[msg.sender];\n        rollupStore.sequencerRewards[msg.sender] = 0;\n        rollupStore.config.feeAsset.transfer(_recipient, amount);\n\n        return amount;\n    }\n\n    function claimProverRewards(\n        address _recipient,\n        Epoch[] memory _epochs\n    ) internal returns (uint256) {\n        Slot currentSlot = Timestamp.wrap(block.timestamp).slotFromTimestamp();\n        RollupStore storage rollupStore = STFLib.getStorage();\n        uint256 proofSubmissionWindow = rollupStore\n            .config\n            .proofSubmissionWindow;\n\n        uint256 accumulatedRewards = 0;\n        for (uint256 i = 0; i < _epochs.length; i++) {\n            Slot deadline = _epochs[i].toSlots() +\n                Slot.wrap(proofSubmissionWindow);\n            require(\n                deadline < currentSlot,\n                Errors.Rollup__NotPastDeadline(deadline, currentSlot)\n            );\n\n            // We can use fancier bitmaps for performance\n            require(\n                !rollupStore.proverClaimed[msg.sender][_epochs[i]],\n                Errors.Rollup__AlreadyClaimed(msg.sender, _epochs[i])\n            );\n            rollupStore.proverClaimed[msg.sender][_epochs[i]] = true;\n\n            EpochRewards storage e = rollupStore.epochRewards[_epochs[i]];\n            if (e.subEpoch[e.longestProvenLength].hasSubmitted[msg.sender]) {\n                accumulatedRewards += (e.rewards /\n                    e.subEpoch[e.longestProvenLength].summedCount);\n            }\n        }\n\n        rollupStore.config.feeAsset.transfer(_recipient, accumulatedRewards);\n\n        return accumulatedRewards;\n    }\n}\n"
      },
      "project/contracts/evm/aztec-interfaces/rollup/STFLib.sol": {
        "content": "// SPDX-License-Identifier: Apache-2.0\n// Copyright 2024 Aztec Labs.\npragma solidity >=0.8.27;\n\nimport {RollupStore, IRollupCore, BlockLog, GenesisState} from \"../IRollup.sol\";\nimport {Errors} from \"../CoreErrors.sol\";\nimport {Timestamp, Slot, Epoch, TimeLib} from \"../TimeLib.sol\";\n\nlibrary STFLib {\n    using TimeLib for Slot;\n    using TimeLib for Epoch;\n    using TimeLib for Timestamp;\n\n    // @note  This is also used in the cheatcodes, so if updating, please also update the cheatcode.\n    bytes32 private constant STF_STORAGE_POSITION =\n        keccak256(\"aztec.stf.storage\");\n\n    function initialize(GenesisState memory _genesisState) internal {\n        RollupStore storage rollupStore = STFLib.getStorage();\n\n        rollupStore.config.vkTreeRoot = _genesisState.vkTreeRoot;\n        rollupStore.config.protocolContractTreeRoot = _genesisState\n            .protocolContractTreeRoot;\n\n        rollupStore.blocks[0] = BlockLog({\n            archive: _genesisState.genesisArchiveRoot,\n            blockHash: _genesisState.genesisBlockHash,\n            slotNumber: Slot.wrap(0)\n        });\n    }\n\n    function prune() internal {\n        RollupStore storage rollupStore = STFLib.getStorage();\n        uint256 pending = rollupStore.tips.pendingBlockNumber;\n\n        // @note  We are not deleting the blocks, but we are \"winding back\" the pendingTip to the last block that was proven.\n        //        We can do because any new block proposed will overwrite a previous block in the block log,\n        //        so no values should \"survive\".\n        //        People must therefore read the chain using the pendingTip as a boundary.\n        rollupStore.tips.pendingBlockNumber = rollupStore\n            .tips\n            .provenBlockNumber;\n\n        emit IRollupCore.PrunedPending(\n            rollupStore.tips.provenBlockNumber,\n            pending\n        );\n    }\n\n    function getEffectivePendingBlockNumber(\n        Timestamp _timestamp\n    ) internal view returns (uint256) {\n        RollupStore storage rollupStore = STFLib.getStorage();\n        return\n            STFLib.canPruneAtTime(_timestamp)\n                ? rollupStore.tips.provenBlockNumber\n                : rollupStore.tips.pendingBlockNumber;\n    }\n\n    function getEpochForBlock(\n        uint256 _blockNumber\n    ) internal view returns (Epoch) {\n        RollupStore storage rollupStore = STFLib.getStorage();\n        require(\n            _blockNumber <= rollupStore.tips.pendingBlockNumber,\n            Errors.Rollup__InvalidBlockNumber(\n                rollupStore.tips.pendingBlockNumber,\n                _blockNumber\n            )\n        );\n        return rollupStore.blocks[_blockNumber].slotNumber.epochFromSlot();\n    }\n\n    function canPruneAtTime(Timestamp _ts) internal view returns (bool) {\n        RollupStore storage rollupStore = STFLib.getStorage();\n        if (\n            rollupStore.tips.pendingBlockNumber ==\n            rollupStore.tips.provenBlockNumber\n        ) {\n            return false;\n        }\n\n        Epoch oldestPendingEpoch = getEpochForBlock(\n            rollupStore.tips.provenBlockNumber + 1\n        );\n        Slot deadline = oldestPendingEpoch.toSlots() +\n            Slot.wrap(rollupStore.config.proofSubmissionWindow);\n\n        return deadline < _ts.slotFromTimestamp();\n    }\n\n    function getStorage()\n        internal\n        pure\n        returns (RollupStore storage storageStruct)\n    {\n        bytes32 position = STF_STORAGE_POSITION;\n        assembly {\n            storageStruct.slot := position\n        }\n    }\n}\n"
      },
      "project/contracts/evm/aztec-interfaces/SlotDerivation.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (utils/SlotDerivation.sol)\n// This file was procedurally generated from scripts/generate/templates/SlotDerivation.js.\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Library for computing storage (and transient storage) locations from namespaces and deriving slots\n * corresponding to standard patterns. The derivation method for array and mapping matches the storage layout used by\n * the solidity language / compiler.\n *\n * See https://docs.soliditylang.org/en/v0.8.20/internals/layout_in_storage.html#mappings-and-dynamic-arrays[Solidity docs for mappings and dynamic arrays.].\n *\n * Example usage:\n * ```solidity\n * contract Example {\n *     // Add the library methods\n *     using StorageSlot for bytes32;\n *     using SlotDerivation for bytes32;\n *\n *     // Declare a namespace\n *     string private constant _NAMESPACE = \"<namespace>\"; // eg. OpenZeppelin.Slot\n *\n *     function setValueInNamespace(uint256 key, address newValue) internal {\n *         _NAMESPACE.erc7201Slot().deriveMapping(key).getAddressSlot().value = newValue;\n *     }\n *\n *     function getValueInNamespace(uint256 key) internal view returns (address) {\n *         return _NAMESPACE.erc7201Slot().deriveMapping(key).getAddressSlot().value;\n *     }\n * }\n * ```\n *\n * TIP: Consider using this library along with {StorageSlot}.\n *\n * NOTE: This library provides a way to manipulate storage locations in a non-standard way. Tooling for checking\n * upgrade safety will ignore the slots accessed through this library.\n *\n * _Available since v5.1._\n */\nlibrary SlotDerivation {\n    /**\n     * @dev Derive an ERC-7201 slot from a string (namespace).\n     */\n    function erc7201Slot(\n        string memory namespace\n    ) internal pure returns (bytes32 slot) {\n        assembly (\"memory-safe\") {\n            mstore(\n                0x00,\n                sub(keccak256(add(namespace, 0x20), mload(namespace)), 1)\n            )\n            slot := and(keccak256(0x00, 0x20), not(0xff))\n        }\n    }\n\n    /**\n     * @dev Add an offset to a slot to get the n-th element of a structure or an array.\n     */\n    function offset(\n        bytes32 slot,\n        uint256 pos\n    ) internal pure returns (bytes32 result) {\n        unchecked {\n            return bytes32(uint256(slot) + pos);\n        }\n    }\n\n    /**\n     * @dev Derive the location of the first element in an array from the slot where the length is stored.\n     */\n    function deriveArray(bytes32 slot) internal pure returns (bytes32 result) {\n        assembly (\"memory-safe\") {\n            mstore(0x00, slot)\n            result := keccak256(0x00, 0x20)\n        }\n    }\n\n    /**\n     * @dev Derive the location of a mapping element from the key.\n     */\n    function deriveMapping(\n        bytes32 slot,\n        address key\n    ) internal pure returns (bytes32 result) {\n        assembly (\"memory-safe\") {\n            mstore(0x00, and(key, shr(96, not(0))))\n            mstore(0x20, slot)\n            result := keccak256(0x00, 0x40)\n        }\n    }\n\n    /**\n     * @dev Derive the location of a mapping element from the key.\n     */\n    function deriveMapping(\n        bytes32 slot,\n        bool key\n    ) internal pure returns (bytes32 result) {\n        assembly (\"memory-safe\") {\n            mstore(0x00, iszero(iszero(key)))\n            mstore(0x20, slot)\n            result := keccak256(0x00, 0x40)\n        }\n    }\n\n    /**\n     * @dev Derive the location of a mapping element from the key.\n     */\n    function deriveMapping(\n        bytes32 slot,\n        bytes32 key\n    ) internal pure returns (bytes32 result) {\n        assembly (\"memory-safe\") {\n            mstore(0x00, key)\n            mstore(0x20, slot)\n            result := keccak256(0x00, 0x40)\n        }\n    }\n\n    /**\n     * @dev Derive the location of a mapping element from the key.\n     */\n    function deriveMapping(\n        bytes32 slot,\n        uint256 key\n    ) internal pure returns (bytes32 result) {\n        assembly (\"memory-safe\") {\n            mstore(0x00, key)\n            mstore(0x20, slot)\n            result := keccak256(0x00, 0x40)\n        }\n    }\n\n    /**\n     * @dev Derive the location of a mapping element from the key.\n     */\n    function deriveMapping(\n        bytes32 slot,\n        int256 key\n    ) internal pure returns (bytes32 result) {\n        assembly (\"memory-safe\") {\n            mstore(0x00, key)\n            mstore(0x20, slot)\n            result := keccak256(0x00, 0x40)\n        }\n    }\n\n    /**\n     * @dev Derive the location of a mapping element from the key.\n     */\n    function deriveMapping(\n        bytes32 slot,\n        string memory key\n    ) internal pure returns (bytes32 result) {\n        assembly (\"memory-safe\") {\n            let length := mload(key)\n            let begin := add(key, 0x20)\n            let end := add(begin, length)\n            let cache := mload(end)\n            mstore(end, slot)\n            result := keccak256(begin, add(length, 0x20))\n            mstore(end, cache)\n        }\n    }\n\n    /**\n     * @dev Derive the location of a mapping element from the key.\n     */\n    function deriveMapping(\n        bytes32 slot,\n        bytes memory key\n    ) internal pure returns (bytes32 result) {\n        assembly (\"memory-safe\") {\n            let length := mload(key)\n            let begin := add(key, 0x20)\n            let end := add(begin, length)\n            let cache := mload(end)\n            mstore(end, slot)\n            result := keccak256(begin, add(length, 0x20))\n            mstore(end, cache)\n        }\n    }\n}\n"
      },
      "project/contracts/evm/aztec-interfaces/staking/StakingLib.sol": {
        "content": "// SPDX-License-Identifier: Apache-2.0\n// Copyright 2024 Aztec Labs.\npragma solidity >=0.8.27;\n\nimport {Status, ValidatorInfo, Exit, Timestamp, StakingStorage, IStakingCore} from \"../IStaking.sol\";\nimport {Errors} from \"../CoreErrors.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {EnumerableSet} from \"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\";\n\nlibrary StakingLib {\n    using SafeERC20 for IERC20;\n    using EnumerableSet for EnumerableSet.AddressSet;\n\n    bytes32 private constant STAKING_SLOT =\n        keccak256(\"aztec.core.staking.storage\");\n\n    function initialize(\n        IERC20 _stakingAsset,\n        uint256 _minimumStake,\n        Timestamp _exitDelay,\n        address _slasher\n    ) internal {\n        StakingStorage storage store = getStorage();\n        store.stakingAsset = _stakingAsset;\n        store.minimumStake = _minimumStake;\n        store.exitDelay = _exitDelay;\n        store.slasher = _slasher;\n    }\n\n    function finaliseWithdraw(address _attester) internal {\n        StakingStorage storage store = getStorage();\n        ValidatorInfo storage validator = store.info[_attester];\n        require(\n            validator.status == Status.EXITING,\n            Errors.Staking__NotExiting(_attester)\n        );\n\n        Exit storage exit = store.exits[_attester];\n        require(\n            exit.exitableAt <= Timestamp.wrap(block.timestamp),\n            Errors.Staking__WithdrawalNotUnlockedYet(\n                Timestamp.wrap(block.timestamp),\n                exit.exitableAt\n            )\n        );\n\n        uint256 amount = validator.stake;\n        address recipient = exit.recipient;\n\n        delete store.exits[_attester];\n        delete store.info[_attester];\n\n        store.stakingAsset.transfer(recipient, amount);\n\n        emit IStakingCore.WithdrawFinalised(_attester, recipient, amount);\n    }\n\n    function slash(address _attester, uint256 _amount) internal {\n        StakingStorage storage store = getStorage();\n        require(\n            msg.sender == store.slasher,\n            Errors.Staking__NotSlasher(store.slasher, msg.sender)\n        );\n\n        ValidatorInfo storage validator = store.info[_attester];\n        require(\n            validator.status != Status.NONE,\n            Errors.Staking__NoOneToSlash(_attester)\n        );\n\n        // There is a special, case, if exiting and past the limit, it is untouchable!\n        require(\n            !(validator.status == Status.EXITING &&\n                store.exits[_attester].exitableAt <=\n                Timestamp.wrap(block.timestamp)),\n            Errors.Staking__CannotSlashExitedStake(_attester)\n        );\n        validator.stake -= _amount;\n\n        // If the attester was validating AND is slashed below the MINIMUM_STAKE we update him to LIVING\n        // When LIVING, he can only start exiting, we don't \"really\" exit him, because that cost\n        // gas and cost edge cases around recipient, so lets just avoid that.\n        if (\n            validator.status == Status.VALIDATING &&\n            validator.stake < store.minimumStake\n        ) {\n            require(\n                store.attesters.remove(_attester),\n                Errors.Staking__FailedToRemove(_attester)\n            );\n            validator.status = Status.LIVING;\n        }\n\n        emit IStakingCore.Slashed(_attester, _amount);\n    }\n\n    function deposit(\n        address _attester,\n        address _proposer,\n        address _withdrawer,\n        uint256 _amount\n    ) internal {\n        require(\n            _attester != address(0) && _proposer != address(0),\n            Errors.Staking__InvalidDeposit(_attester, _proposer)\n        );\n        StakingStorage storage store = getStorage();\n        require(\n            _amount >= store.minimumStake,\n            Errors.Staking__InsufficientStake(_amount, store.minimumStake)\n        );\n        store.stakingAsset.transferFrom(msg.sender, address(this), _amount);\n        require(\n            store.info[_attester].status == Status.NONE,\n            Errors.Staking__AlreadyRegistered(_attester)\n        );\n        require(\n            store.attesters.add(_attester),\n            Errors.Staking__AlreadyActive(_attester)\n        );\n\n        // If BLS, need to check possession of private key to avoid attacks.\n\n        store.info[_attester] = ValidatorInfo({\n            stake: _amount,\n            withdrawer: _withdrawer,\n            proposer: _proposer,\n            status: Status.VALIDATING\n        });\n\n        emit IStakingCore.Deposit(_attester, _proposer, _withdrawer, _amount);\n    }\n\n    function initiateWithdraw(\n        address _attester,\n        address _recipient\n    ) internal returns (bool) {\n        StakingStorage storage store = getStorage();\n        ValidatorInfo storage validator = store.info[_attester];\n\n        require(\n            msg.sender == validator.withdrawer,\n            Errors.Staking__NotWithdrawer(validator.withdrawer, msg.sender)\n        );\n        require(\n            validator.status == Status.VALIDATING ||\n                validator.status == Status.LIVING,\n            Errors.Staking__NothingToExit(_attester)\n        );\n        if (validator.status == Status.VALIDATING) {\n            require(\n                store.attesters.remove(_attester),\n                Errors.Staking__FailedToRemove(_attester)\n            );\n        }\n\n        // Note that the \"amount\" is not stored here, but reusing the `validators`\n        // We always exit fully.\n        // @note The attester might be chosen for the epoch, so the delay must be long enough\n        //       to allow for that.\n        store.exits[_attester] = Exit({\n            exitableAt: Timestamp.wrap(block.timestamp) + store.exitDelay,\n            recipient: _recipient\n        });\n        validator.status = Status.EXITING;\n\n        emit IStakingCore.WithdrawInitiated(\n            _attester,\n            _recipient,\n            validator.stake\n        );\n\n        return true;\n    }\n\n    function getStorage()\n        internal\n        pure\n        returns (StakingStorage storage storageStruct)\n    {\n        bytes32 position = STAKING_SLOT;\n        assembly {\n            storageStruct.slot := position\n        }\n    }\n}\n"
      },
      "project/contracts/evm/aztec-interfaces/TimeLib.sol": {
        "content": "// SPDX-License-Identifier: Apache-2.0\n// Copyright 2024 Aztec Labs.\npragma solidity >=0.8.27;\n\n// solhint-disable-next-line no-unused-import\nimport {Timestamp, Slot, Epoch, SlotLib, EpochLib} from \"./TimeMath.sol\";\n\nstruct TimeStorage {\n    uint256 genesisTime;\n    uint256 slotDuration; // Number of seconds in a slot\n    uint256 epochDuration; // Number of slots in an epoch\n}\n\nlibrary TimeLib {\n    bytes32 private constant TIME_STORAGE_POSITION =\n        keccak256(\"aztec.time.storage\");\n\n    function initialize(\n        uint256 _genesisTime,\n        uint256 _slotDuration,\n        uint256 _epochDuration\n    ) internal {\n        TimeStorage storage store = getStorage();\n        store.genesisTime = _genesisTime;\n        store.slotDuration = _slotDuration;\n        store.epochDuration = _epochDuration;\n    }\n\n    function toTimestamp(Slot _a) internal view returns (Timestamp) {\n        TimeStorage storage store = getStorage();\n        return\n            Timestamp.wrap(store.genesisTime) +\n            Timestamp.wrap(Slot.unwrap(_a) * store.slotDuration);\n    }\n\n    function slotFromTimestamp(Timestamp _a) internal view returns (Slot) {\n        TimeStorage storage store = getStorage();\n        return\n            Slot.wrap(\n                (Timestamp.unwrap(_a) - store.genesisTime) / store.slotDuration\n            );\n    }\n\n    function positionInEpoch(Slot _a) internal view returns (uint256) {\n        return Slot.unwrap(_a) % getStorage().epochDuration;\n    }\n\n    function toSlots(Epoch _a) internal view returns (Slot) {\n        return Slot.wrap(Epoch.unwrap(_a) * getStorage().epochDuration);\n    }\n\n    function toTimestamp(Epoch _a) internal view returns (Timestamp) {\n        return toTimestamp(toSlots(_a));\n    }\n\n    function epochFromTimestamp(Timestamp _a) internal view returns (Epoch) {\n        TimeStorage storage store = getStorage();\n        return\n            Epoch.wrap(\n                (Timestamp.unwrap(_a) - store.genesisTime) /\n                    (store.epochDuration * store.slotDuration)\n            );\n    }\n\n    function epochFromSlot(Slot _a) internal view returns (Epoch) {\n        return Epoch.wrap(Slot.unwrap(_a) / getStorage().epochDuration);\n    }\n\n    function getStorage()\n        internal\n        pure\n        returns (TimeStorage storage storageStruct)\n    {\n        bytes32 position = TIME_STORAGE_POSITION;\n        assembly {\n            storageStruct.slot := position\n        }\n    }\n}\n"
      },
      "project/contracts/evm/aztec-interfaces/TimeMath.sol": {
        "content": "// SPDX-License-Identifier: Apache-2.0\n// Copyright 2024 Aztec Labs.\npragma solidity >=0.8.27;\n\ntype Timestamp is uint256;\n\ntype Slot is uint256;\n\ntype Epoch is uint256;\n\nlibrary SlotLib {\n  function unwrap(Slot _a) internal pure returns (uint256) {\n    return Slot.unwrap(_a);\n  }\n}\n\nlibrary EpochLib {\n  function unwrap(Epoch _a) internal pure returns (uint256) {\n    return Epoch.unwrap(_a);\n  }\n}\n\nusing SlotLib for Slot;\nusing EpochLib for Epoch;\n\nfunction addTimestamp(Timestamp _a, Timestamp _b) pure returns (Timestamp) {\n  return Timestamp.wrap(Timestamp.unwrap(_a) + Timestamp.unwrap(_b));\n}\n\nfunction subTimestamp(Timestamp _a, Timestamp _b) pure returns (Timestamp) {\n  return Timestamp.wrap(Timestamp.unwrap(_a) - Timestamp.unwrap(_b));\n}\n\nfunction ltTimestamp(Timestamp _a, Timestamp _b) pure returns (bool) {\n  return Timestamp.unwrap(_a) < Timestamp.unwrap(_b);\n}\n\nfunction lteTimestamp(Timestamp _a, Timestamp _b) pure returns (bool) {\n  return Timestamp.unwrap(_a) <= Timestamp.unwrap(_b);\n}\n\nfunction gtTimestamp(Timestamp _a, Timestamp _b) pure returns (bool) {\n  return Timestamp.unwrap(_a) > Timestamp.unwrap(_b);\n}\n\nfunction gteTimestamp(Timestamp _a, Timestamp _b) pure returns (bool) {\n  return Timestamp.unwrap(_a) >= Timestamp.unwrap(_b);\n}\n\nfunction neqTimestamp(Timestamp _a, Timestamp _b) pure returns (bool) {\n  return Timestamp.unwrap(_a) != Timestamp.unwrap(_b);\n}\n\nfunction eqTimestamp(Timestamp _a, Timestamp _b) pure returns (bool) {\n  return Timestamp.unwrap(_a) == Timestamp.unwrap(_b);\n}\n\n// Slot\n\nfunction addSlot(Slot _a, Slot _b) pure returns (Slot) {\n  return Slot.wrap(Slot.unwrap(_a) + Slot.unwrap(_b));\n}\n\nfunction subSlot(Slot _a, Slot _b) pure returns (Slot) {\n  return Slot.wrap(Slot.unwrap(_a) - Slot.unwrap(_b));\n}\n\nfunction eqSlot(Slot _a, Slot _b) pure returns (bool) {\n  return Slot.unwrap(_a) == Slot.unwrap(_b);\n}\n\nfunction neqSlot(Slot _a, Slot _b) pure returns (bool) {\n  return Slot.unwrap(_a) != Slot.unwrap(_b);\n}\n\nfunction ltSlot(Slot _a, Slot _b) pure returns (bool) {\n  return Slot.unwrap(_a) < Slot.unwrap(_b);\n}\n\nfunction lteSlot(Slot _a, Slot _b) pure returns (bool) {\n  return Slot.unwrap(_a) <= Slot.unwrap(_b);\n}\n\nfunction gtSlot(Slot _a, Slot _b) pure returns (bool) {\n  return Slot.unwrap(_a) > Slot.unwrap(_b);\n}\n\nfunction gteSlot(Slot _a, Slot _b) pure returns (bool) {\n  return Slot.unwrap(_a) >= Slot.unwrap(_b);\n}\n\n// Epoch\n\nfunction eqEpoch(Epoch _a, Epoch _b) pure returns (bool) {\n  return Epoch.unwrap(_a) == Epoch.unwrap(_b);\n}\n\nfunction neqEpoch(Epoch _a, Epoch _b) pure returns (bool) {\n  return Epoch.unwrap(_a) != Epoch.unwrap(_b);\n}\n\nfunction subEpoch(Epoch _a, Epoch _b) pure returns (Epoch) {\n  return Epoch.wrap(Epoch.unwrap(_a) - Epoch.unwrap(_b));\n}\n\nfunction addEpoch(Epoch _a, Epoch _b) pure returns (Epoch) {\n  return Epoch.wrap(Epoch.unwrap(_a) + Epoch.unwrap(_b));\n}\n\nfunction gteEpoch(Epoch _a, Epoch _b) pure returns (bool) {\n  return Epoch.unwrap(_a) >= Epoch.unwrap(_b);\n}\n\nfunction gtEpoch(Epoch _a, Epoch _b) pure returns (bool) {\n  return Epoch.unwrap(_a) > Epoch.unwrap(_b);\n}\n\nfunction lteEpoch(Epoch _a, Epoch _b) pure returns (bool) {\n  return Epoch.unwrap(_a) <= Epoch.unwrap(_b);\n}\n\nfunction ltEpoch(Epoch _a, Epoch _b) pure returns (bool) {\n  return Epoch.unwrap(_a) < Epoch.unwrap(_b);\n}\n\nusing {\n  addTimestamp as +,\n  subTimestamp as -,\n  ltTimestamp as <,\n  gtTimestamp as >,\n  lteTimestamp as <=,\n  gteTimestamp as >=,\n  neqTimestamp as !=,\n  eqTimestamp as ==\n} for Timestamp global;\n\nusing {\n  addEpoch as +,\n  subEpoch as -,\n  eqEpoch as ==,\n  neqEpoch as !=,\n  gteEpoch as >=,\n  gtEpoch as >,\n  lteEpoch as <=,\n  ltEpoch as <\n} for Epoch global;\n\nusing {\n  eqSlot as ==,\n  neqSlot as !=,\n  gteSlot as >=,\n  gtSlot as >,\n  lteSlot as <=,\n  ltSlot as <,\n  addSlot as +,\n  subSlot as -\n} for Slot global;\n"
      },
      "project/contracts/evm/aztec-interfaces/TransientSlot.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (utils/TransientSlot.sol)\n// This file was procedurally generated from scripts/generate/templates/TransientSlot.js.\n\npragma solidity ^0.8.24;\n\n/**\n * @dev Library for reading and writing value-types to specific transient storage slots.\n *\n * Transient slots are often used to store temporary values that are removed after the current transaction.\n * This library helps with reading and writing to such slots without the need for inline assembly.\n *\n *  * Example reading and writing values using transient storage:\n * ```solidity\n * contract Lock {\n *     using TransientSlot for *;\n *\n *     // Define the slot. Alternatively, use the SlotDerivation library to derive the slot.\n *     bytes32 internal constant _LOCK_SLOT = 0xf4678858b2b588224636b8522b729e7722d32fc491da849ed75b3fdf3c84f542;\n *\n *     modifier locked() {\n *         require(!_LOCK_SLOT.asBoolean().tload());\n *\n *         _LOCK_SLOT.asBoolean().tstore(true);\n *         _;\n *         _LOCK_SLOT.asBoolean().tstore(false);\n *     }\n * }\n * ```\n *\n * TIP: Consider using this library along with {SlotDerivation}.\n */\nlibrary TransientSlot {\n    /**\n     * @dev UDVT that represents a slot holding an address.\n     */\n    type AddressSlot is bytes32;\n\n    /**\n     * @dev Cast an arbitrary slot to a AddressSlot.\n     */\n    function asAddress(bytes32 slot) internal pure returns (AddressSlot) {\n        return AddressSlot.wrap(slot);\n    }\n\n    /**\n     * @dev UDVT that represents a slot holding a bool.\n     */\n    type BooleanSlot is bytes32;\n\n    /**\n     * @dev Cast an arbitrary slot to a BooleanSlot.\n     */\n    function asBoolean(bytes32 slot) internal pure returns (BooleanSlot) {\n        return BooleanSlot.wrap(slot);\n    }\n\n    /**\n     * @dev UDVT that represents a slot holding a bytes32.\n     */\n    type Bytes32Slot is bytes32;\n\n    /**\n     * @dev Cast an arbitrary slot to a Bytes32Slot.\n     */\n    function asBytes32(bytes32 slot) internal pure returns (Bytes32Slot) {\n        return Bytes32Slot.wrap(slot);\n    }\n\n    /**\n     * @dev UDVT that represents a slot holding a uint256.\n     */\n    type Uint256Slot is bytes32;\n\n    /**\n     * @dev Cast an arbitrary slot to a Uint256Slot.\n     */\n    function asUint256(bytes32 slot) internal pure returns (Uint256Slot) {\n        return Uint256Slot.wrap(slot);\n    }\n\n    /**\n     * @dev UDVT that represents a slot holding a int256.\n     */\n    type Int256Slot is bytes32;\n\n    /**\n     * @dev Cast an arbitrary slot to a Int256Slot.\n     */\n    function asInt256(bytes32 slot) internal pure returns (Int256Slot) {\n        return Int256Slot.wrap(slot);\n    }\n\n    /**\n     * @dev Load the value held at location `slot` in transient storage.\n     */\n    function tload(AddressSlot slot) internal view returns (address value) {\n        assembly (\"memory-safe\") {\n            value := tload(slot)\n        }\n    }\n\n    /**\n     * @dev Store `value` at location `slot` in transient storage.\n     */\n    function tstore(AddressSlot slot, address value) internal {\n        assembly (\"memory-safe\") {\n            tstore(slot, value)\n        }\n    }\n\n    /**\n     * @dev Load the value held at location `slot` in transient storage.\n     */\n    function tload(BooleanSlot slot) internal view returns (bool value) {\n        assembly (\"memory-safe\") {\n            value := tload(slot)\n        }\n    }\n\n    /**\n     * @dev Store `value` at location `slot` in transient storage.\n     */\n    function tstore(BooleanSlot slot, bool value) internal {\n        assembly (\"memory-safe\") {\n            tstore(slot, value)\n        }\n    }\n\n    /**\n     * @dev Load the value held at location `slot` in transient storage.\n     */\n    function tload(Bytes32Slot slot) internal view returns (bytes32 value) {\n        assembly (\"memory-safe\") {\n            value := tload(slot)\n        }\n    }\n\n    /**\n     * @dev Store `value` at location `slot` in transient storage.\n     */\n    function tstore(Bytes32Slot slot, bytes32 value) internal {\n        assembly (\"memory-safe\") {\n            tstore(slot, value)\n        }\n    }\n\n    /**\n     * @dev Load the value held at location `slot` in transient storage.\n     */\n    function tload(Uint256Slot slot) internal view returns (uint256 value) {\n        assembly (\"memory-safe\") {\n            value := tload(slot)\n        }\n    }\n\n    /**\n     * @dev Store `value` at location `slot` in transient storage.\n     */\n    function tstore(Uint256Slot slot, uint256 value) internal {\n        assembly (\"memory-safe\") {\n            tstore(slot, value)\n        }\n    }\n\n    /**\n     * @dev Load the value held at location `slot` in transient storage.\n     */\n    function tload(Int256Slot slot) internal view returns (int256 value) {\n        assembly (\"memory-safe\") {\n            value := tload(slot)\n        }\n    }\n\n    /**\n     * @dev Store `value` at location `slot` in transient storage.\n     */\n    function tstore(Int256Slot slot, int256 value) internal {\n        assembly (\"memory-safe\") {\n            tstore(slot, value)\n        }\n    }\n}\n"
      },
      "project/contracts/evm/aztec-interfaces/UserLib.sol": {
        "content": "// SPDX-License-Identifier: Apache-2.0\n// Copyright 2024 Aztec Labs.\npragma solidity >=0.8.27;\n\nimport {Timestamp} from \"./TimeLib.sol\";\nimport {DataStructures} from \"./GovernanceDataStructures.sol\";\nimport {Errors} from \"./GovernanceErrors.sol\";\n\nlibrary UserLib {\n    function add(DataStructures.User storage _self, uint256 _amount) internal {\n        if (_amount == 0) {\n            return;\n        }\n        if (_self.numCheckPoints == 0) {\n            _self.checkpoints[0] = DataStructures.CheckPoint({\n                time: Timestamp.wrap(block.timestamp),\n                power: _amount\n            });\n            _self.numCheckPoints += 1;\n        } else {\n            DataStructures.CheckPoint storage last = _self.checkpoints[\n                _self.numCheckPoints - 1\n            ];\n            if (last.time == Timestamp.wrap(block.timestamp)) {\n                last.power += _amount;\n            } else {\n                _self.checkpoints[_self.numCheckPoints] = DataStructures\n                    .CheckPoint({\n                        time: Timestamp.wrap(block.timestamp),\n                        power: last.power + _amount\n                    });\n                _self.numCheckPoints += 1;\n            }\n        }\n    }\n\n    function sub(DataStructures.User storage _self, uint256 _amount) internal {\n        if (_amount == 0) {\n            return;\n        }\n        require(\n            _self.numCheckPoints > 0,\n            Errors.Governance__NoCheckpointsFound()\n        );\n        DataStructures.CheckPoint storage last = _self.checkpoints[\n            _self.numCheckPoints - 1\n        ];\n        require(\n            last.power >= _amount,\n            Errors.Governance__InsufficientPower(\n                msg.sender,\n                last.power,\n                _amount\n            )\n        );\n        if (last.time == Timestamp.wrap(block.timestamp)) {\n            last.power -= _amount;\n        } else {\n            _self.checkpoints[_self.numCheckPoints] = DataStructures\n                .CheckPoint({\n                    time: Timestamp.wrap(block.timestamp),\n                    power: last.power - _amount\n                });\n            _self.numCheckPoints += 1;\n        }\n    }\n\n    function powerNow(\n        DataStructures.User storage _self\n    ) internal view returns (uint256) {\n        uint256 numCheckPoints = _self.numCheckPoints;\n        if (numCheckPoints == 0) {\n            return 0;\n        }\n        return _self.checkpoints[numCheckPoints - 1].power;\n    }\n\n    function powerAt(\n        DataStructures.User storage _self,\n        Timestamp _time\n    ) internal view returns (uint256) {\n        // If not in the past, the values are not stable.\n        // We disallow using it to avoid potential misuse.\n        require(\n            _time < Timestamp.wrap(block.timestamp),\n            Errors.Governance__UserLib__NotInPast()\n        );\n\n        uint256 numCheckPoints = _self.numCheckPoints;\n        if (numCheckPoints == 0) {\n            return 0;\n        }\n\n        if (_self.checkpoints[numCheckPoints - 1].time <= _time) {\n            return _self.checkpoints[numCheckPoints - 1].power;\n        }\n\n        if (_self.checkpoints[0].time > _time) {\n            return 0;\n        }\n\n        uint256 lower = 0;\n        uint256 upper = numCheckPoints - 1;\n        while (upper > lower) {\n            uint256 center = upper - (upper - lower) / 2; // ceil, avoiding overflow\n            DataStructures.CheckPoint memory cp = _self.checkpoints[center];\n            if (cp.time == _time) {\n                return cp.power;\n            } else if (cp.time < _time) {\n                lower = center;\n            } else {\n                upper = center - 1;\n            }\n        }\n        return _self.checkpoints[lower].power;\n    }\n}\n"
      },
      "project/contracts/evm/aztec-interfaces/validator-selection/ValidatorSelectionLib.sol": {
        "content": "// SPDX-License-Identifier: Apache-2.0\n// Copyright 2024 Aztec Labs.\npragma solidity >=0.8.27;\n\nimport {BlockHeaderValidationFlags} from \"../IRollup.sol\";\nimport {StakingStorage} from \"../IStaking.sol\";\nimport {EpochData, ValidatorSelectionStorage} from \"../IValidatorSelection.sol\";\nimport {SampleLib} from \"../crypto/SampleLib.sol\";\nimport {SignatureLib, Signature} from \"../crypto/SignatureLib.sol\";\nimport {Errors} from \"../CoreErrors.sol\";\nimport {Timestamp, Slot, Epoch, TimeLib} from \"../TimeLib.sol\";\nimport {MessageHashUtils} from \"@openzeppelin/contracts/utils/cryptography/MessageHashUtils.sol\";\nimport {EnumerableSet} from \"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\";\n\nlibrary ValidatorSelectionLib {\n    using EnumerableSet for EnumerableSet.AddressSet;\n    using MessageHashUtils for bytes32;\n    using SignatureLib for Signature;\n    using TimeLib for Timestamp;\n\n    bytes32 private constant VALIDATOR_SELECTION_STORAGE_POSITION =\n        keccak256(\"aztec.validator_selection.storage\");\n\n    function initialize(uint256 _targetCommitteeSize) internal {\n        ValidatorSelectionStorage storage store = getStorage();\n        store.targetCommitteeSize = _targetCommitteeSize;\n    }\n\n    /**\n     * @notice  Performs a setup of an epoch if needed. The setup will\n     *          - Sample the validator set for the epoch\n     *          - Set the seed for the epoch\n     *          - Update the last seed\n     *\n     * @dev     Since this is a reference optimising for simplicity, we store the actual validator set in the epoch structure.\n     *          This is very heavy on gas, so start crying because the gas here will melt the poles\n     *          https://i.giphy.com/U1aN4HTfJ2SmgB2BBK.webp\n     */\n    function setupEpoch(StakingStorage storage _stakingStore) internal {\n        Epoch epochNumber = Timestamp\n            .wrap(block.timestamp)\n            .epochFromTimestamp();\n        ValidatorSelectionStorage storage store = getStorage();\n        EpochData storage epoch = store.epochs[epochNumber];\n\n        if (epoch.sampleSeed == 0) {\n            epoch.sampleSeed = getSampleSeed(epochNumber);\n            epoch.nextSeed = store.lastSeed = computeNextSeed(epochNumber);\n            epoch.committee = sampleValidators(_stakingStore, epoch.sampleSeed);\n        }\n    }\n\n    /**\n     * @notice  Propose a pending block from the point-of-view of sequencer selection. Will:\n     *          - Setup the epoch if needed (if epoch committee is empty skips the rest)\n     *          - Validate that the proposer is the proposer of the slot\n     *          - Validate that the signatures for attestations are indeed from the validatorset\n     *          - Validate that the number of valid attestations is sufficient\n     *\n     * @dev     Cases where errors are thrown:\n     *          - If the epoch is not setup\n     *          - If the proposer is not the real proposer AND the proposer is not open\n     *          - If the number of valid attestations is insufficient\n     *\n     * @param _slot - The slot of the block\n     * @param _signatures - The signatures of the committee members\n     * @param _digest - The digest of the block\n     */\n    function verify(\n        StakingStorage storage _stakingStore,\n        Slot _slot,\n        Epoch _epochNumber,\n        Signature[] memory _signatures,\n        bytes32 _digest,\n        BlockHeaderValidationFlags memory _flags\n    ) internal {\n        // Same logic as we got in getProposerAt\n        // Done do avoid duplicate computing the committee\n        address[] memory committee = getCommitteeAt(\n            _stakingStore,\n            _epochNumber\n        );\n        address attester = committee.length == 0\n            ? address(0)\n            : committee[\n                computeProposerIndex(\n                    _epochNumber,\n                    _slot,\n                    getSampleSeed(_epochNumber),\n                    committee.length\n                )\n            ];\n        address proposer = _stakingStore.info[attester].proposer;\n\n        // @todo Consider getting rid of this option.\n        // If the proposer is open, we allow anyone to propose without needing any signatures\n        if (proposer == address(0)) {\n            return;\n        }\n\n        require(\n            proposer == msg.sender,\n            Errors.ValidatorSelection__InvalidProposer(proposer, msg.sender)\n        );\n\n        if (_flags.ignoreSignatures) {\n            return;\n        }\n\n        uint256 needed = (committee.length * 2) / 3 + 1;\n        require(\n            _signatures.length >= needed,\n            Errors.ValidatorSelection__InsufficientAttestationsProvided(\n                needed,\n                _signatures.length\n            )\n        );\n\n        // Validate the attestations\n        uint256 validAttestations = 0;\n\n        bytes32 digest = _digest.toEthSignedMessageHash();\n        for (uint256 i = 0; i < _signatures.length; i++) {\n            // To avoid stack too deep errors\n            Signature memory signature = _signatures[i];\n            if (signature.isEmpty) {\n                continue;\n            }\n\n            // The verification will throw if invalid\n            signature.verify(committee[i], digest);\n            validAttestations++;\n        }\n\n        require(\n            validAttestations >= needed,\n            Errors.ValidatorSelection__InsufficientAttestations(\n                needed,\n                validAttestations\n            )\n        );\n    }\n\n    function getProposerAt(\n        StakingStorage storage _stakingStore,\n        Slot _slot,\n        Epoch _epochNumber\n    ) internal returns (address) {\n        // @note this is deliberately \"bad\" for the simple reason of code reduction.\n        //       it does not need to actually return the full committee and then draw from it\n        //       it can just return the proposer directly, but then we duplicate the code\n        //       which we just don't have room for right now...\n        address[] memory committee = getCommitteeAt(\n            _stakingStore,\n            _epochNumber\n        );\n        if (committee.length == 0) {\n            return address(0);\n        }\n\n        address attester = committee[\n            computeProposerIndex(\n                _epochNumber,\n                _slot,\n                getSampleSeed(_epochNumber),\n                committee.length\n            )\n        ];\n\n        return _stakingStore.info[attester].proposer;\n    }\n\n    /**\n     * @notice  Samples a validator set for a specific epoch\n     *\n     * @dev     Only used internally, should never be called for anything but the \"next\" epoch\n     *          Allowing us to always use `lastSeed`.\n     *\n     * @return The validators for the given epoch\n     */\n    function sampleValidators(\n        StakingStorage storage _stakingStore,\n        uint256 _seed\n    ) internal returns (address[] memory) {\n        uint256 validatorSetSize = _stakingStore.attesters.length();\n        if (validatorSetSize == 0) {\n            return new address[](0);\n        }\n\n        ValidatorSelectionStorage storage store = getStorage();\n        uint256 targetCommitteeSize = store.targetCommitteeSize;\n\n        // If we have less validators than the target committee size, we just return the full set\n        if (validatorSetSize <= targetCommitteeSize) {\n            return _stakingStore.attesters.values();\n        }\n\n        uint256[] memory indices = SampleLib.computeCommittee(\n            targetCommitteeSize,\n            validatorSetSize,\n            _seed\n        );\n\n        address[] memory committee = new address[](targetCommitteeSize);\n        for (uint256 i = 0; i < targetCommitteeSize; i++) {\n            committee[i] = _stakingStore.attesters.at(indices[i]);\n        }\n        return committee;\n    }\n\n    function getCommitteeAt(\n        StakingStorage storage _stakingStore,\n        Epoch _epochNumber\n    ) internal returns (address[] memory) {\n        ValidatorSelectionStorage storage store = getStorage();\n        EpochData storage epoch = store.epochs[_epochNumber];\n\n        if (epoch.sampleSeed != 0) {\n            uint256 committeeSize = epoch.committee.length;\n            if (committeeSize == 0) {\n                return new address[](0);\n            }\n            return epoch.committee;\n        }\n\n        // Allow anyone if there is no validator set\n        if (_stakingStore.attesters.length() == 0) {\n            return new address[](0);\n        }\n\n        // Emulate a sampling of the validators\n        uint256 sampleSeed = getSampleSeed(_epochNumber);\n        return sampleValidators(_stakingStore, sampleSeed);\n    }\n\n    /**\n     * @notice  Get the sample seed for an epoch\n     *\n     * @dev     This should behave as walking past the line, but it does not currently do that.\n     *          If there are entire skips, e.g., 1, 2, 5 and we then go back and try executing\n     *          for 4 we will get an invalid value because we will read lastSeed which is from 5.\n     *\n     * @dev     The `_epoch` will never be 0 nor in the future\n     *\n     * @dev     The return value will be equal to keccak256(n, block.prevrandao) for n being the last epoch\n     *          setup.\n     *\n     * @return The sample seed for the epoch\n     */\n    function getSampleSeed(Epoch _epoch) internal view returns (uint256) {\n        if (Epoch.unwrap(_epoch) == 0) {\n            return type(uint256).max;\n        }\n        ValidatorSelectionStorage storage store = getStorage();\n        uint256 sampleSeed = store.epochs[_epoch].sampleSeed;\n        if (sampleSeed != 0) {\n            return sampleSeed;\n        }\n\n        sampleSeed = store.epochs[_epoch - Epoch.wrap(1)].nextSeed;\n        if (sampleSeed != 0) {\n            return sampleSeed;\n        }\n\n        return store.lastSeed;\n    }\n\n    function getStorage()\n        internal\n        pure\n        returns (ValidatorSelectionStorage storage storageStruct)\n    {\n        bytes32 position = VALIDATOR_SELECTION_STORAGE_POSITION;\n        assembly {\n            storageStruct.slot := position\n        }\n    }\n\n    /**\n     * @notice  Computes the nextSeed for an epoch\n     *\n     * @dev     We include the `_epoch` instead of using the randao directly to avoid issues with foundry testing\n     *          where randao == 0.\n     *\n     * @param _epoch - The epoch to compute the seed for\n     *\n     * @return The computed seed\n     */\n    function computeNextSeed(Epoch _epoch) private view returns (uint256) {\n        return uint256(keccak256(abi.encode(_epoch, block.prevrandao)));\n    }\n\n    /**\n     * @notice  Computes the index of the committee member that acts as proposer for a given slot\n     *\n     * @param _epoch - The epoch to compute the proposer index for\n     * @param _slot - The slot to compute the proposer index for\n     * @param _seed - The seed to use for the computation\n     * @param _size - The size of the committee\n     *\n     * @return The index of the proposer\n     */\n    function computeProposerIndex(\n        Epoch _epoch,\n        Slot _slot,\n        uint256 _seed,\n        uint256 _size\n    ) private pure returns (uint256) {\n        return uint256(keccak256(abi.encode(_epoch, _slot, _seed))) % _size;\n    }\n}\n"
      },
      "project/contracts/evm/aztec-interfaces/Vm.sol": {
        "content": "// Automatically @generated by scripts/vm.py. Do not modify manually.\n\n// SPDX-License-Identifier: MIT OR Apache-2.0\npragma solidity >=0.6.2 <0.9.0;\npragma experimental ABIEncoderV2;\n\n/// The `VmSafe` interface does not allow manipulation of the EVM state or other actions that may\n/// result in Script simulations differing from on-chain execution. It is recommended to only use\n/// these cheats in scripts.\ninterface VmSafe {\n    /// A modification applied to either `msg.sender` or `tx.origin`. Returned by `readCallers`.\n    enum CallerMode {\n        // No caller modification is currently active.\n        None,\n        // A one time broadcast triggered by a `vm.broadcast()` call is currently active.\n        Broadcast,\n        // A recurrent broadcast triggered by a `vm.startBroadcast()` call is currently active.\n        RecurrentBroadcast,\n        // A one time prank triggered by a `vm.prank()` call is currently active.\n        Prank,\n        // A recurrent prank triggered by a `vm.startPrank()` call is currently active.\n        RecurrentPrank\n    }\n\n    /// The kind of account access that occurred.\n    enum AccountAccessKind {\n        // The account was called.\n        Call,\n        // The account was called via delegatecall.\n        DelegateCall,\n        // The account was called via callcode.\n        CallCode,\n        // The account was called via staticcall.\n        StaticCall,\n        // The account was created.\n        Create,\n        // The account was selfdestructed.\n        SelfDestruct,\n        // Synthetic access indicating the current context has resumed after a previous sub-context (AccountAccess).\n        Resume,\n        // The account's balance was read.\n        Balance,\n        // The account's codesize was read.\n        Extcodesize,\n        // The account's codehash was read.\n        Extcodehash,\n        // The account's code was copied.\n        Extcodecopy\n    }\n\n    /// Forge execution contexts.\n    enum ForgeContext {\n        // Test group execution context (test, coverage or snapshot).\n        TestGroup,\n        // `forge test` execution context.\n        Test,\n        // `forge coverage` execution context.\n        Coverage,\n        // `forge snapshot` execution context.\n        Snapshot,\n        // Script group execution context (dry run, broadcast or resume).\n        ScriptGroup,\n        // `forge script` execution context.\n        ScriptDryRun,\n        // `forge script --broadcast` execution context.\n        ScriptBroadcast,\n        // `forge script --resume` execution context.\n        ScriptResume,\n        // Unknown `forge` execution context.\n        Unknown\n    }\n\n    /// The transaction type (`txType`) of the broadcast.\n    enum BroadcastTxType {\n        // Represents a CALL broadcast tx.\n        Call,\n        // Represents a CREATE broadcast tx.\n        Create,\n        // Represents a CREATE2 broadcast tx.\n        Create2\n    }\n\n    /// An Ethereum log. Returned by `getRecordedLogs`.\n    struct Log {\n        // The topics of the log, including the signature, if any.\n        bytes32[] topics;\n        // The raw data of the log.\n        bytes data;\n        // The address of the log's emitter.\n        address emitter;\n    }\n\n    /// An RPC URL and its alias. Returned by `rpcUrlStructs`.\n    struct Rpc {\n        // The alias of the RPC URL.\n        string key;\n        // The RPC URL.\n        string url;\n    }\n\n    /// An RPC log object. Returned by `eth_getLogs`.\n    struct EthGetLogs {\n        // The address of the log's emitter.\n        address emitter;\n        // The topics of the log, including the signature, if any.\n        bytes32[] topics;\n        // The raw data of the log.\n        bytes data;\n        // The block hash.\n        bytes32 blockHash;\n        // The block number.\n        uint64 blockNumber;\n        // The transaction hash.\n        bytes32 transactionHash;\n        // The transaction index in the block.\n        uint64 transactionIndex;\n        // The log index.\n        uint256 logIndex;\n        // Whether the log was removed.\n        bool removed;\n    }\n\n    /// A single entry in a directory listing. Returned by `readDir`.\n    struct DirEntry {\n        // The error message, if any.\n        string errorMessage;\n        // The path of the entry.\n        string path;\n        // The depth of the entry.\n        uint64 depth;\n        // Whether the entry is a directory.\n        bool isDir;\n        // Whether the entry is a symlink.\n        bool isSymlink;\n    }\n\n    /// Metadata information about a file.\n    /// This structure is returned from the `fsMetadata` function and represents known\n    /// metadata about a file such as its permissions, size, modification\n    /// times, etc.\n    struct FsMetadata {\n        // True if this metadata is for a directory.\n        bool isDir;\n        // True if this metadata is for a symlink.\n        bool isSymlink;\n        // The size of the file, in bytes, this metadata is for.\n        uint256 length;\n        // True if this metadata is for a readonly (unwritable) file.\n        bool readOnly;\n        // The last modification time listed in this metadata.\n        uint256 modified;\n        // The last access time of this metadata.\n        uint256 accessed;\n        // The creation time listed in this metadata.\n        uint256 created;\n    }\n\n    /// A wallet with a public and private key.\n    struct Wallet {\n        // The wallet's address.\n        address addr;\n        // The wallet's public key `X`.\n        uint256 publicKeyX;\n        // The wallet's public key `Y`.\n        uint256 publicKeyY;\n        // The wallet's private key.\n        uint256 privateKey;\n    }\n\n    /// The result of a `tryFfi` call.\n    struct FfiResult {\n        // The exit code of the call.\n        int32 exitCode;\n        // The optionally hex-decoded `stdout` data.\n        bytes stdout;\n        // The `stderr` data.\n        bytes stderr;\n    }\n\n    /// Information on the chain and fork.\n    struct ChainInfo {\n        // The fork identifier. Set to zero if no fork is active.\n        uint256 forkId;\n        // The chain ID of the current fork.\n        uint256 chainId;\n    }\n\n    /// The result of a `stopAndReturnStateDiff` call.\n    struct AccountAccess {\n        // The chain and fork the access occurred.\n        ChainInfo chainInfo;\n        // The kind of account access that determines what the account is.\n        // If kind is Call, DelegateCall, StaticCall or CallCode, then the account is the callee.\n        // If kind is Create, then the account is the newly created account.\n        // If kind is SelfDestruct, then the account is the selfdestruct recipient.\n        // If kind is a Resume, then account represents a account context that has resumed.\n        AccountAccessKind kind;\n        // The account that was accessed.\n        // It's either the account created, callee or a selfdestruct recipient for CREATE, CALL or SELFDESTRUCT.\n        address account;\n        // What accessed the account.\n        address accessor;\n        // If the account was initialized or empty prior to the access.\n        // An account is considered initialized if it has code, a\n        // non-zero nonce, or a non-zero balance.\n        bool initialized;\n        // The previous balance of the accessed account.\n        uint256 oldBalance;\n        // The potential new balance of the accessed account.\n        // That is, all balance changes are recorded here, even if reverts occurred.\n        uint256 newBalance;\n        // Code of the account deployed by CREATE.\n        bytes deployedCode;\n        // Value passed along with the account access\n        uint256 value;\n        // Input data provided to the CREATE or CALL\n        bytes data;\n        // If this access reverted in either the current or parent context.\n        bool reverted;\n        // An ordered list of storage accesses made during an account access operation.\n        StorageAccess[] storageAccesses;\n        // Call depth traversed during the recording of state differences\n        uint64 depth;\n    }\n\n    /// The storage accessed during an `AccountAccess`.\n    struct StorageAccess {\n        // The account whose storage was accessed.\n        address account;\n        // The slot that was accessed.\n        bytes32 slot;\n        // If the access was a write.\n        bool isWrite;\n        // The previous value of the slot.\n        bytes32 previousValue;\n        // The new value of the slot.\n        bytes32 newValue;\n        // If the access was reverted.\n        bool reverted;\n    }\n\n    /// Gas used. Returned by `lastCallGas`.\n    struct Gas {\n        // The gas limit of the call.\n        uint64 gasLimit;\n        // The total gas used.\n        uint64 gasTotalUsed;\n        // DEPRECATED: The amount of gas used for memory expansion. Ref: <https://github.com/foundry-rs/foundry/pull/7934#pullrequestreview-2069236939>\n        uint64 gasMemoryUsed;\n        // The amount of gas refunded.\n        int64 gasRefunded;\n        // The amount of gas remaining.\n        uint64 gasRemaining;\n    }\n\n    /// The result of the `stopDebugTraceRecording` call\n    struct DebugStep {\n        // The stack before executing the step of the run.\n        // stack\\[0\\] represents the top of the stack.\n        // and only stack data relevant to the opcode execution is contained.\n        uint256[] stack;\n        // The memory input data before executing the step of the run.\n        // only input data relevant to the opcode execution is contained.\n        // e.g. for MLOAD, it will have memory\\[offset:offset+32\\] copied here.\n        // the offset value can be get by the stack data.\n        bytes memoryInput;\n        // The opcode that was accessed.\n        uint8 opcode;\n        // The call depth of the step.\n        uint64 depth;\n        // Whether the call end up with out of gas error.\n        bool isOutOfGas;\n        // The contract address where the opcode is running\n        address contractAddr;\n    }\n\n    /// Represents a transaction's broadcast details.\n    struct BroadcastTxSummary {\n        // The hash of the transaction that was broadcasted\n        bytes32 txHash;\n        // Represent the type of transaction among CALL, CREATE, CREATE2\n        BroadcastTxType txType;\n        // The address of the contract that was called or created.\n        // This is address of the contract that is created if the txType is CREATE or CREATE2.\n        address contractAddress;\n        // The block number the transaction landed in.\n        uint64 blockNumber;\n        // Status of the transaction, retrieved from the transaction receipt.\n        bool success;\n    }\n\n    /// Holds a signed EIP-7702 authorization for an authority account to delegate to an implementation.\n    struct SignedDelegation {\n        // The y-parity of the recovered secp256k1 signature (0 or 1).\n        uint8 v;\n        // First 32 bytes of the signature.\n        bytes32 r;\n        // Second 32 bytes of the signature.\n        bytes32 s;\n        // The current nonce of the authority account at signing time.\n        // Used to ensure signature can't be replayed after account nonce changes.\n        uint64 nonce;\n        // Address of the contract implementation that will be delegated to.\n        // Gets encoded into delegation code: 0xef0100 || implementation.\n        address implementation;\n    }\n\n    /// Represents a \"potential\" revert reason from a single subsequent call when using `vm.assumeNoReverts`.\n    /// Reverts that match will result in a FOUNDRY::ASSUME rejection, whereas unmatched reverts will be surfaced\n    /// as normal.\n    struct PotentialRevert {\n        // The allowed origin of the revert opcode; address(0) allows reverts from any address\n        address reverter;\n        // When true, only matches on the beginning of the revert data, otherwise, matches on entire revert data\n        bool partialMatch;\n        // The data to use to match encountered reverts\n        bytes revertData;\n    }\n\n    /// An EIP-2930 access list item.\n    struct AccessListItem {\n        // The address to be added in access list.\n        address target;\n        // The storage keys to be added in access list.\n        bytes32[] storageKeys;\n    }\n\n    // ======== Crypto ========\n\n    /// Derives a private key from the name, labels the account with that name, and returns the wallet.\n    function createWallet(\n        string calldata walletLabel\n    ) external returns (Wallet memory wallet);\n\n    /// Generates a wallet from the private key and returns the wallet.\n    function createWallet(\n        uint256 privateKey\n    ) external returns (Wallet memory wallet);\n\n    /// Generates a wallet from the private key, labels the account with that name, and returns the wallet.\n    function createWallet(\n        uint256 privateKey,\n        string calldata walletLabel\n    ) external returns (Wallet memory wallet);\n\n    /// Derive a private key from a provided mnenomic string (or mnenomic file path)\n    /// at the derivation path `m/44'/60'/0'/0/{index}`.\n    function deriveKey(\n        string calldata mnemonic,\n        uint32 index\n    ) external pure returns (uint256 privateKey);\n\n    /// Derive a private key from a provided mnenomic string (or mnenomic file path)\n    /// at `{derivationPath}{index}`.\n    function deriveKey(\n        string calldata mnemonic,\n        string calldata derivationPath,\n        uint32 index\n    ) external pure returns (uint256 privateKey);\n\n    /// Derive a private key from a provided mnenomic string (or mnenomic file path) in the specified language\n    /// at the derivation path `m/44'/60'/0'/0/{index}`.\n    function deriveKey(\n        string calldata mnemonic,\n        uint32 index,\n        string calldata language\n    ) external pure returns (uint256 privateKey);\n\n    /// Derive a private key from a provided mnenomic string (or mnenomic file path) in the specified language\n    /// at `{derivationPath}{index}`.\n    function deriveKey(\n        string calldata mnemonic,\n        string calldata derivationPath,\n        uint32 index,\n        string calldata language\n    ) external pure returns (uint256 privateKey);\n\n    /// Derives secp256r1 public key from the provided `privateKey`.\n    function publicKeyP256(\n        uint256 privateKey\n    ) external pure returns (uint256 publicKeyX, uint256 publicKeyY);\n\n    /// Adds a private key to the local forge wallet and returns the address.\n    function rememberKey(uint256 privateKey) external returns (address keyAddr);\n\n    /// Derive a set number of wallets from a mnemonic at the derivation path `m/44'/60'/0'/0/{0..count}`.\n    /// The respective private keys are saved to the local forge wallet for later use and their addresses are returned.\n    function rememberKeys(\n        string calldata mnemonic,\n        string calldata derivationPath,\n        uint32 count\n    ) external returns (address[] memory keyAddrs);\n\n    /// Derive a set number of wallets from a mnemonic in the specified language at the derivation path `m/44'/60'/0'/0/{0..count}`.\n    /// The respective private keys are saved to the local forge wallet for later use and their addresses are returned.\n    function rememberKeys(\n        string calldata mnemonic,\n        string calldata derivationPath,\n        string calldata language,\n        uint32 count\n    ) external returns (address[] memory keyAddrs);\n\n    /// Signs data with a `Wallet`.\n    /// Returns a compact signature (`r`, `vs`) as per EIP-2098, where `vs` encodes both the\n    /// signature's `s` value, and the recovery id `v` in a single bytes32.\n    /// This format reduces the signature size from 65 to 64 bytes.\n    function signCompact(\n        Wallet calldata wallet,\n        bytes32 digest\n    ) external returns (bytes32 r, bytes32 vs);\n\n    /// Signs `digest` with `privateKey` using the secp256k1 curve.\n    /// Returns a compact signature (`r`, `vs`) as per EIP-2098, where `vs` encodes both the\n    /// signature's `s` value, and the recovery id `v` in a single bytes32.\n    /// This format reduces the signature size from 65 to 64 bytes.\n    function signCompact(\n        uint256 privateKey,\n        bytes32 digest\n    ) external pure returns (bytes32 r, bytes32 vs);\n\n    /// Signs `digest` with signer provided to script using the secp256k1 curve.\n    /// Returns a compact signature (`r`, `vs`) as per EIP-2098, where `vs` encodes both the\n    /// signature's `s` value, and the recovery id `v` in a single bytes32.\n    /// This format reduces the signature size from 65 to 64 bytes.\n    /// If `--sender` is provided, the signer with provided address is used, otherwise,\n    /// if exactly one signer is provided to the script, that signer is used.\n    /// Raises error if signer passed through `--sender` does not match any unlocked signers or\n    /// if `--sender` is not provided and not exactly one signer is passed to the script.\n    function signCompact(\n        bytes32 digest\n    ) external pure returns (bytes32 r, bytes32 vs);\n\n    /// Signs `digest` with signer provided to script using the secp256k1 curve.\n    /// Returns a compact signature (`r`, `vs`) as per EIP-2098, where `vs` encodes both the\n    /// signature's `s` value, and the recovery id `v` in a single bytes32.\n    /// This format reduces the signature size from 65 to 64 bytes.\n    /// Raises error if none of the signers passed into the script have provided address.\n    function signCompact(\n        address signer,\n        bytes32 digest\n    ) external pure returns (bytes32 r, bytes32 vs);\n\n    /// Signs `digest` with `privateKey` using the secp256r1 curve.\n    function signP256(\n        uint256 privateKey,\n        bytes32 digest\n    ) external pure returns (bytes32 r, bytes32 s);\n\n    /// Signs data with a `Wallet`.\n    function sign(\n        Wallet calldata wallet,\n        bytes32 digest\n    ) external returns (uint8 v, bytes32 r, bytes32 s);\n\n    /// Signs `digest` with `privateKey` using the secp256k1 curve.\n    function sign(\n        uint256 privateKey,\n        bytes32 digest\n    ) external pure returns (uint8 v, bytes32 r, bytes32 s);\n\n    /// Signs `digest` with signer provided to script using the secp256k1 curve.\n    /// If `--sender` is provided, the signer with provided address is used, otherwise,\n    /// if exactly one signer is provided to the script, that signer is used.\n    /// Raises error if signer passed through `--sender` does not match any unlocked signers or\n    /// if `--sender` is not provided and not exactly one signer is passed to the script.\n    function sign(\n        bytes32 digest\n    ) external pure returns (uint8 v, bytes32 r, bytes32 s);\n\n    /// Signs `digest` with signer provided to script using the secp256k1 curve.\n    /// Raises error if none of the signers passed into the script have provided address.\n    function sign(\n        address signer,\n        bytes32 digest\n    ) external pure returns (uint8 v, bytes32 r, bytes32 s);\n\n    // ======== Environment ========\n\n    /// Gets the environment variable `name` and parses it as `address`.\n    /// Reverts if the variable was not found or could not be parsed.\n    function envAddress(\n        string calldata name\n    ) external view returns (address value);\n\n    /// Gets the environment variable `name` and parses it as an array of `address`, delimited by `delim`.\n    /// Reverts if the variable was not found or could not be parsed.\n    function envAddress(\n        string calldata name,\n        string calldata delim\n    ) external view returns (address[] memory value);\n\n    /// Gets the environment variable `name` and parses it as `bool`.\n    /// Reverts if the variable was not found or could not be parsed.\n    function envBool(string calldata name) external view returns (bool value);\n\n    /// Gets the environment variable `name` and parses it as an array of `bool`, delimited by `delim`.\n    /// Reverts if the variable was not found or could not be parsed.\n    function envBool(\n        string calldata name,\n        string calldata delim\n    ) external view returns (bool[] memory value);\n\n    /// Gets the environment variable `name` and parses it as `bytes32`.\n    /// Reverts if the variable was not found or could not be parsed.\n    function envBytes32(\n        string calldata name\n    ) external view returns (bytes32 value);\n\n    /// Gets the environment variable `name` and parses it as an array of `bytes32`, delimited by `delim`.\n    /// Reverts if the variable was not found or could not be parsed.\n    function envBytes32(\n        string calldata name,\n        string calldata delim\n    ) external view returns (bytes32[] memory value);\n\n    /// Gets the environment variable `name` and parses it as `bytes`.\n    /// Reverts if the variable was not found or could not be parsed.\n    function envBytes(\n        string calldata name\n    ) external view returns (bytes memory value);\n\n    /// Gets the environment variable `name` and parses it as an array of `bytes`, delimited by `delim`.\n    /// Reverts if the variable was not found or could not be parsed.\n    function envBytes(\n        string calldata name,\n        string calldata delim\n    ) external view returns (bytes[] memory value);\n\n    /// Gets the environment variable `name` and returns true if it exists, else returns false.\n    function envExists(\n        string calldata name\n    ) external view returns (bool result);\n\n    /// Gets the environment variable `name` and parses it as `int256`.\n    /// Reverts if the variable was not found or could not be parsed.\n    function envInt(string calldata name) external view returns (int256 value);\n\n    /// Gets the environment variable `name` and parses it as an array of `int256`, delimited by `delim`.\n    /// Reverts if the variable was not found or could not be parsed.\n    function envInt(\n        string calldata name,\n        string calldata delim\n    ) external view returns (int256[] memory value);\n\n    /// Gets the environment variable `name` and parses it as `bool`.\n    /// Reverts if the variable could not be parsed.\n    /// Returns `defaultValue` if the variable was not found.\n    function envOr(\n        string calldata name,\n        bool defaultValue\n    ) external view returns (bool value);\n\n    /// Gets the environment variable `name` and parses it as `uint256`.\n    /// Reverts if the variable could not be parsed.\n    /// Returns `defaultValue` if the variable was not found.\n    function envOr(\n        string calldata name,\n        uint256 defaultValue\n    ) external view returns (uint256 value);\n\n    /// Gets the environment variable `name` and parses it as an array of `address`, delimited by `delim`.\n    /// Reverts if the variable could not be parsed.\n    /// Returns `defaultValue` if the variable was not found.\n    function envOr(\n        string calldata name,\n        string calldata delim,\n        address[] calldata defaultValue\n    ) external view returns (address[] memory value);\n\n    /// Gets the environment variable `name` and parses it as an array of `bytes32`, delimited by `delim`.\n    /// Reverts if the variable could not be parsed.\n    /// Returns `defaultValue` if the variable was not found.\n    function envOr(\n        string calldata name,\n        string calldata delim,\n        bytes32[] calldata defaultValue\n    ) external view returns (bytes32[] memory value);\n\n    /// Gets the environment variable `name` and parses it as an array of `string`, delimited by `delim`.\n    /// Reverts if the variable could not be parsed.\n    /// Returns `defaultValue` if the variable was not found.\n    function envOr(\n        string calldata name,\n        string calldata delim,\n        string[] calldata defaultValue\n    ) external view returns (string[] memory value);\n\n    /// Gets the environment variable `name` and parses it as an array of `bytes`, delimited by `delim`.\n    /// Reverts if the variable could not be parsed.\n    /// Returns `defaultValue` if the variable was not found.\n    function envOr(\n        string calldata name,\n        string calldata delim,\n        bytes[] calldata defaultValue\n    ) external view returns (bytes[] memory value);\n\n    /// Gets the environment variable `name` and parses it as `int256`.\n    /// Reverts if the variable could not be parsed.\n    /// Returns `defaultValue` if the variable was not found.\n    function envOr(\n        string calldata name,\n        int256 defaultValue\n    ) external view returns (int256 value);\n\n    /// Gets the environment variable `name` and parses it as `address`.\n    /// Reverts if the variable could not be parsed.\n    /// Returns `defaultValue` if the variable was not found.\n    function envOr(\n        string calldata name,\n        address defaultValue\n    ) external view returns (address value);\n\n    /// Gets the environment variable `name` and parses it as `bytes32`.\n    /// Reverts if the variable could not be parsed.\n    /// Returns `defaultValue` if the variable was not found.\n    function envOr(\n        string calldata name,\n        bytes32 defaultValue\n    ) external view returns (bytes32 value);\n\n    /// Gets the environment variable `name` and parses it as `string`.\n    /// Reverts if the variable could not be parsed.\n    /// Returns `defaultValue` if the variable was not found.\n    function envOr(\n        string calldata name,\n        string calldata defaultValue\n    ) external view returns (string memory value);\n\n    /// Gets the environment variable `name` and parses it as `bytes`.\n    /// Reverts if the variable could not be parsed.\n    /// Returns `defaultValue` if the variable was not found.\n    function envOr(\n        string calldata name,\n        bytes calldata defaultValue\n    ) external view returns (bytes memory value);\n\n    /// Gets the environment variable `name` and parses it as an array of `bool`, delimited by `delim`.\n    /// Reverts if the variable could not be parsed.\n    /// Returns `defaultValue` if the variable was not found.\n    function envOr(\n        string calldata name,\n        string calldata delim,\n        bool[] calldata defaultValue\n    ) external view returns (bool[] memory value);\n\n    /// Gets the environment variable `name` and parses it as an array of `uint256`, delimited by `delim`.\n    /// Reverts if the variable could not be parsed.\n    /// Returns `defaultValue` if the variable was not found.\n    function envOr(\n        string calldata name,\n        string calldata delim,\n        uint256[] calldata defaultValue\n    ) external view returns (uint256[] memory value);\n\n    /// Gets the environment variable `name` and parses it as an array of `int256`, delimited by `delim`.\n    /// Reverts if the variable could not be parsed.\n    /// Returns `defaultValue` if the variable was not found.\n    function envOr(\n        string calldata name,\n        string calldata delim,\n        int256[] calldata defaultValue\n    ) external view returns (int256[] memory value);\n\n    /// Gets the environment variable `name` and parses it as `string`.\n    /// Reverts if the variable was not found or could not be parsed.\n    function envString(\n        string calldata name\n    ) external view returns (string memory value);\n\n    /// Gets the environment variable `name` and parses it as an array of `string`, delimited by `delim`.\n    /// Reverts if the variable was not found or could not be parsed.\n    function envString(\n        string calldata name,\n        string calldata delim\n    ) external view returns (string[] memory value);\n\n    /// Gets the environment variable `name` and parses it as `uint256`.\n    /// Reverts if the variable was not found or could not be parsed.\n    function envUint(\n        string calldata name\n    ) external view returns (uint256 value);\n\n    /// Gets the environment variable `name` and parses it as an array of `uint256`, delimited by `delim`.\n    /// Reverts if the variable was not found or could not be parsed.\n    function envUint(\n        string calldata name,\n        string calldata delim\n    ) external view returns (uint256[] memory value);\n\n    /// Returns true if `forge` command was executed in given context.\n    function isContext(\n        ForgeContext context\n    ) external view returns (bool result);\n\n    /// Sets environment variables.\n    function setEnv(string calldata name, string calldata value) external;\n\n    // ======== EVM ========\n\n    /// Gets all accessed reads and write slot from a `vm.record` session, for a given address.\n    function accesses(\n        address target\n    )\n        external\n        returns (bytes32[] memory readSlots, bytes32[] memory writeSlots);\n\n    /// Gets the address for a given private key.\n    function addr(uint256 privateKey) external pure returns (address keyAddr);\n\n    /// Gets all the logs according to specified filter.\n    function eth_getLogs(\n        uint256 fromBlock,\n        uint256 toBlock,\n        address target,\n        bytes32[] calldata topics\n    ) external returns (EthGetLogs[] memory logs);\n\n    /// Gets the current `block.blobbasefee`.\n    /// You should use this instead of `block.blobbasefee` if you use `vm.blobBaseFee`, as `block.blobbasefee` is assumed to be constant across a transaction,\n    /// and as a result will get optimized out by the compiler.\n    /// See https://github.com/foundry-rs/foundry/issues/6180\n    function getBlobBaseFee() external view returns (uint256 blobBaseFee);\n\n    /// Gets the current `block.number`.\n    /// You should use this instead of `block.number` if you use `vm.roll`, as `block.number` is assumed to be constant across a transaction,\n    /// and as a result will get optimized out by the compiler.\n    /// See https://github.com/foundry-rs/foundry/issues/6180\n    function getBlockNumber() external view returns (uint256 height);\n\n    /// Gets the current `block.timestamp`.\n    /// You should use this instead of `block.timestamp` if you use `vm.warp`, as `block.timestamp` is assumed to be constant across a transaction,\n    /// and as a result will get optimized out by the compiler.\n    /// See https://github.com/foundry-rs/foundry/issues/6180\n    function getBlockTimestamp() external view returns (uint256 timestamp);\n\n    /// Gets the map key and parent of a mapping at a given slot, for a given address.\n    function getMappingKeyAndParentOf(\n        address target,\n        bytes32 elementSlot\n    ) external returns (bool found, bytes32 key, bytes32 parent);\n\n    /// Gets the number of elements in the mapping at the given slot, for a given address.\n    function getMappingLength(\n        address target,\n        bytes32 mappingSlot\n    ) external returns (uint256 length);\n\n    /// Gets the elements at index idx of the mapping at the given slot, for a given address. The\n    /// index must be less than the length of the mapping (i.e. the number of keys in the mapping).\n    function getMappingSlotAt(\n        address target,\n        bytes32 mappingSlot,\n        uint256 idx\n    ) external returns (bytes32 value);\n\n    /// Gets the nonce of an account.\n    function getNonce(address account) external view returns (uint64 nonce);\n\n    /// Get the nonce of a `Wallet`.\n    function getNonce(Wallet calldata wallet) external returns (uint64 nonce);\n\n    /// Gets all the recorded logs.\n    function getRecordedLogs() external returns (Log[] memory logs);\n\n    /// Returns state diffs from current `vm.startStateDiffRecording` session.\n    function getStateDiff() external view returns (string memory diff);\n\n    /// Returns state diffs from current `vm.startStateDiffRecording` session, in json format.\n    function getStateDiffJson() external view returns (string memory diff);\n\n    /// Gets the gas used in the last call from the callee perspective.\n    function lastCallGas() external view returns (Gas memory gas);\n\n    /// Loads a storage slot from an address.\n    function load(\n        address target,\n        bytes32 slot\n    ) external view returns (bytes32 data);\n\n    /// Pauses gas metering (i.e. gas usage is not counted). Noop if already paused.\n    function pauseGasMetering() external;\n\n    /// Records all storage reads and writes.\n    function record() external;\n\n    /// Record all the transaction logs.\n    function recordLogs() external;\n\n    /// Reset gas metering (i.e. gas usage is set to gas limit).\n    function resetGasMetering() external;\n\n    /// Resumes gas metering (i.e. gas usage is counted again). Noop if already on.\n    function resumeGasMetering() external;\n\n    /// Performs an Ethereum JSON-RPC request to the current fork URL.\n    function rpc(\n        string calldata method,\n        string calldata params\n    ) external returns (bytes memory data);\n\n    /// Performs an Ethereum JSON-RPC request to the given endpoint.\n    function rpc(\n        string calldata urlOrAlias,\n        string calldata method,\n        string calldata params\n    ) external returns (bytes memory data);\n\n    /// Records the debug trace during the run.\n    function startDebugTraceRecording() external;\n\n    /// Starts recording all map SSTOREs for later retrieval.\n    function startMappingRecording() external;\n\n    /// Record all account accesses as part of CREATE, CALL or SELFDESTRUCT opcodes in order,\n    /// along with the context of the calls\n    function startStateDiffRecording() external;\n\n    /// Stop debug trace recording and returns the recorded debug trace.\n    function stopAndReturnDebugTraceRecording()\n        external\n        returns (DebugStep[] memory step);\n\n    /// Returns an ordered array of all account accesses from a `vm.startStateDiffRecording` session.\n    function stopAndReturnStateDiff()\n        external\n        returns (AccountAccess[] memory accountAccesses);\n\n    /// Stops recording all map SSTOREs for later retrieval and clears the recorded data.\n    function stopMappingRecording() external;\n\n    // ======== Filesystem ========\n\n    /// Closes file for reading, resetting the offset and allowing to read it from beginning with readLine.\n    /// `path` is relative to the project root.\n    function closeFile(string calldata path) external;\n\n    /// Copies the contents of one file to another. This function will **overwrite** the contents of `to`.\n    /// On success, the total number of bytes copied is returned and it is equal to the length of the `to` file as reported by `metadata`.\n    /// Both `from` and `to` are relative to the project root.\n    function copyFile(\n        string calldata from,\n        string calldata to\n    ) external returns (uint64 copied);\n\n    /// Creates a new, empty directory at the provided path.\n    /// This cheatcode will revert in the following situations, but is not limited to just these cases:\n    /// - User lacks permissions to modify `path`.\n    /// - A parent of the given path doesn't exist and `recursive` is false.\n    /// - `path` already exists and `recursive` is false.\n    /// `path` is relative to the project root.\n    function createDir(string calldata path, bool recursive) external;\n\n    /// Deploys a contract from an artifact file. Takes in the relative path to the json file or the path to the\n    /// artifact in the form of <path>:<contract>:<version> where <contract> and <version> parts are optional.\n    function deployCode(\n        string calldata artifactPath\n    ) external returns (address deployedAddress);\n\n    /// Deploys a contract from an artifact file. Takes in the relative path to the json file or the path to the\n    /// artifact in the form of <path>:<contract>:<version> where <contract> and <version> parts are optional.\n    /// Additionally accepts abi-encoded constructor arguments.\n    function deployCode(\n        string calldata artifactPath,\n        bytes calldata constructorArgs\n    ) external returns (address deployedAddress);\n\n    /// Deploys a contract from an artifact file. Takes in the relative path to the json file or the path to the\n    /// artifact in the form of <path>:<contract>:<version> where <contract> and <version> parts are optional.\n    /// Additionally accepts `msg.value`.\n    function deployCode(\n        string calldata artifactPath,\n        uint256 value\n    ) external returns (address deployedAddress);\n\n    /// Deploys a contract from an artifact file. Takes in the relative path to the json file or the path to the\n    /// artifact in the form of <path>:<contract>:<version> where <contract> and <version> parts are optional.\n    /// Additionally accepts abi-encoded constructor arguments and `msg.value`.\n    function deployCode(\n        string calldata artifactPath,\n        bytes calldata constructorArgs,\n        uint256 value\n    ) external returns (address deployedAddress);\n\n    /// Deploys a contract from an artifact file, using the CREATE2 salt. Takes in the relative path to the json file or the path to the\n    /// artifact in the form of <path>:<contract>:<version> where <contract> and <version> parts are optional.\n    function deployCode(\n        string calldata artifactPath,\n        bytes32 salt\n    ) external returns (address deployedAddress);\n\n    /// Deploys a contract from an artifact file, using the CREATE2 salt. Takes in the relative path to the json file or the path to the\n    /// artifact in the form of <path>:<contract>:<version> where <contract> and <version> parts are optional.\n    /// Additionally accepts abi-encoded constructor arguments.\n    function deployCode(\n        string calldata artifactPath,\n        bytes calldata constructorArgs,\n        bytes32 salt\n    ) external returns (address deployedAddress);\n\n    /// Deploys a contract from an artifact file, using the CREATE2 salt. Takes in the relative path to the json file or the path to the\n    /// artifact in the form of <path>:<contract>:<version> where <contract> and <version> parts are optional.\n    /// Additionally accepts `msg.value`.\n    function deployCode(\n        string calldata artifactPath,\n        uint256 value,\n        bytes32 salt\n    ) external returns (address deployedAddress);\n\n    /// Deploys a contract from an artifact file, using the CREATE2 salt. Takes in the relative path to the json file or the path to the\n    /// artifact in the form of <path>:<contract>:<version> where <contract> and <version> parts are optional.\n    /// Additionally accepts abi-encoded constructor arguments and `msg.value`.\n    function deployCode(\n        string calldata artifactPath,\n        bytes calldata constructorArgs,\n        uint256 value,\n        bytes32 salt\n    ) external returns (address deployedAddress);\n\n    /// Returns true if the given path points to an existing entity, else returns false.\n    function exists(string calldata path) external view returns (bool result);\n\n    /// Performs a foreign function call via the terminal.\n    function ffi(\n        string[] calldata commandInput\n    ) external returns (bytes memory result);\n\n    /// Given a path, query the file system to get information about a file, directory, etc.\n    function fsMetadata(\n        string calldata path\n    ) external view returns (FsMetadata memory metadata);\n\n    /// Gets the artifact path from code (aka. creation code).\n    function getArtifactPathByCode(\n        bytes calldata code\n    ) external view returns (string memory path);\n\n    /// Gets the artifact path from deployed code (aka. runtime code).\n    function getArtifactPathByDeployedCode(\n        bytes calldata deployedCode\n    ) external view returns (string memory path);\n\n    /// Returns the most recent broadcast for the given contract on `chainId` matching `txType`.\n    /// For example:\n    /// The most recent deployment can be fetched by passing `txType` as `CREATE` or `CREATE2`.\n    /// The most recent call can be fetched by passing `txType` as `CALL`.\n    function getBroadcast(\n        string calldata contractName,\n        uint64 chainId,\n        BroadcastTxType txType\n    ) external view returns (BroadcastTxSummary memory);\n\n    /// Returns all broadcasts for the given contract on `chainId` with the specified `txType`.\n    /// Sorted such that the most recent broadcast is the first element, and the oldest is the last. i.e descending order of BroadcastTxSummary.blockNumber.\n    function getBroadcasts(\n        string calldata contractName,\n        uint64 chainId,\n        BroadcastTxType txType\n    ) external view returns (BroadcastTxSummary[] memory);\n\n    /// Returns all broadcasts for the given contract on `chainId`.\n    /// Sorted such that the most recent broadcast is the first element, and the oldest is the last. i.e descending order of BroadcastTxSummary.blockNumber.\n    function getBroadcasts(\n        string calldata contractName,\n        uint64 chainId\n    ) external view returns (BroadcastTxSummary[] memory);\n\n    /// Gets the creation bytecode from an artifact file. Takes in the relative path to the json file or the path to the\n    /// artifact in the form of <path>:<contract>:<version> where <contract> and <version> parts are optional.\n    function getCode(\n        string calldata artifactPath\n    ) external view returns (bytes memory creationBytecode);\n\n    /// Gets the deployed bytecode from an artifact file. Takes in the relative path to the json file or the path to the\n    /// artifact in the form of <path>:<contract>:<version> where <contract> and <version> parts are optional.\n    function getDeployedCode(\n        string calldata artifactPath\n    ) external view returns (bytes memory runtimeBytecode);\n\n    /// Returns the most recent deployment for the current `chainId`.\n    function getDeployment(\n        string calldata contractName\n    ) external view returns (address deployedAddress);\n\n    /// Returns the most recent deployment for the given contract on `chainId`\n    function getDeployment(\n        string calldata contractName,\n        uint64 chainId\n    ) external view returns (address deployedAddress);\n\n    /// Returns all deployments for the given contract on `chainId`\n    /// Sorted in descending order of deployment time i.e descending order of BroadcastTxSummary.blockNumber.\n    /// The most recent deployment is the first element, and the oldest is the last.\n    function getDeployments(\n        string calldata contractName,\n        uint64 chainId\n    ) external view returns (address[] memory deployedAddresses);\n\n    /// Returns true if the path exists on disk and is pointing at a directory, else returns false.\n    function isDir(string calldata path) external view returns (bool result);\n\n    /// Returns true if the path exists on disk and is pointing at a regular file, else returns false.\n    function isFile(string calldata path) external view returns (bool result);\n\n    /// Get the path of the current project root.\n    function projectRoot() external view returns (string memory path);\n\n    /// Prompts the user for a string value in the terminal.\n    function prompt(\n        string calldata promptText\n    ) external returns (string memory input);\n\n    /// Prompts the user for an address in the terminal.\n    function promptAddress(\n        string calldata promptText\n    ) external returns (address);\n\n    /// Prompts the user for a hidden string value in the terminal.\n    function promptSecret(\n        string calldata promptText\n    ) external returns (string memory input);\n\n    /// Prompts the user for hidden uint256 in the terminal (usually pk).\n    function promptSecretUint(\n        string calldata promptText\n    ) external returns (uint256);\n\n    /// Prompts the user for uint256 in the terminal.\n    function promptUint(string calldata promptText) external returns (uint256);\n\n    /// Reads the directory at the given path recursively, up to `maxDepth`.\n    /// `maxDepth` defaults to 1, meaning only the direct children of the given directory will be returned.\n    /// Follows symbolic links if `followLinks` is true.\n    function readDir(\n        string calldata path\n    ) external view returns (DirEntry[] memory entries);\n\n    /// See `readDir(string)`.\n    function readDir(\n        string calldata path,\n        uint64 maxDepth\n    ) external view returns (DirEntry[] memory entries);\n\n    /// See `readDir(string)`.\n    function readDir(\n        string calldata path,\n        uint64 maxDepth,\n        bool followLinks\n    ) external view returns (DirEntry[] memory entries);\n\n    /// Reads the entire content of file to string. `path` is relative to the project root.\n    function readFile(\n        string calldata path\n    ) external view returns (string memory data);\n\n    /// Reads the entire content of file as binary. `path` is relative to the project root.\n    function readFileBinary(\n        string calldata path\n    ) external view returns (bytes memory data);\n\n    /// Reads next line of file to string.\n    function readLine(\n        string calldata path\n    ) external view returns (string memory line);\n\n    /// Reads a symbolic link, returning the path that the link points to.\n    /// This cheatcode will revert in the following situations, but is not limited to just these cases:\n    /// - `path` is not a symbolic link.\n    /// - `path` does not exist.\n    function readLink(\n        string calldata linkPath\n    ) external view returns (string memory targetPath);\n\n    /// Removes a directory at the provided path.\n    /// This cheatcode will revert in the following situations, but is not limited to just these cases:\n    /// - `path` doesn't exist.\n    /// - `path` isn't a directory.\n    /// - User lacks permissions to modify `path`.\n    /// - The directory is not empty and `recursive` is false.\n    /// `path` is relative to the project root.\n    function removeDir(string calldata path, bool recursive) external;\n\n    /// Removes a file from the filesystem.\n    /// This cheatcode will revert in the following situations, but is not limited to just these cases:\n    /// - `path` points to a directory.\n    /// - The file doesn't exist.\n    /// - The user lacks permissions to remove the file.\n    /// `path` is relative to the project root.\n    function removeFile(string calldata path) external;\n\n    /// Performs a foreign function call via terminal and returns the exit code, stdout, and stderr.\n    function tryFfi(\n        string[] calldata commandInput\n    ) external returns (FfiResult memory result);\n\n    /// Returns the time since unix epoch in milliseconds.\n    function unixTime() external view returns (uint256 milliseconds);\n\n    /// Writes data to file, creating a file if it does not exist, and entirely replacing its contents if it does.\n    /// `path` is relative to the project root.\n    function writeFile(string calldata path, string calldata data) external;\n\n    /// Writes binary data to a file, creating a file if it does not exist, and entirely replacing its contents if it does.\n    /// `path` is relative to the project root.\n    function writeFileBinary(\n        string calldata path,\n        bytes calldata data\n    ) external;\n\n    /// Writes line to file, creating a file if it does not exist.\n    /// `path` is relative to the project root.\n    function writeLine(string calldata path, string calldata data) external;\n\n    // ======== JSON ========\n\n    /// Checks if `key` exists in a JSON object.\n    function keyExistsJson(\n        string calldata json,\n        string calldata key\n    ) external view returns (bool);\n\n    /// Parses a string of JSON data at `key` and coerces it to `address`.\n    function parseJsonAddress(\n        string calldata json,\n        string calldata key\n    ) external pure returns (address);\n\n    /// Parses a string of JSON data at `key` and coerces it to `address[]`.\n    function parseJsonAddressArray(\n        string calldata json,\n        string calldata key\n    ) external pure returns (address[] memory);\n\n    /// Parses a string of JSON data at `key` and coerces it to `bool`.\n    function parseJsonBool(\n        string calldata json,\n        string calldata key\n    ) external pure returns (bool);\n\n    /// Parses a string of JSON data at `key` and coerces it to `bool[]`.\n    function parseJsonBoolArray(\n        string calldata json,\n        string calldata key\n    ) external pure returns (bool[] memory);\n\n    /// Parses a string of JSON data at `key` and coerces it to `bytes`.\n    function parseJsonBytes(\n        string calldata json,\n        string calldata key\n    ) external pure returns (bytes memory);\n\n    /// Parses a string of JSON data at `key` and coerces it to `bytes32`.\n    function parseJsonBytes32(\n        string calldata json,\n        string calldata key\n    ) external pure returns (bytes32);\n\n    /// Parses a string of JSON data at `key` and coerces it to `bytes32[]`.\n    function parseJsonBytes32Array(\n        string calldata json,\n        string calldata key\n    ) external pure returns (bytes32[] memory);\n\n    /// Parses a string of JSON data at `key` and coerces it to `bytes[]`.\n    function parseJsonBytesArray(\n        string calldata json,\n        string calldata key\n    ) external pure returns (bytes[] memory);\n\n    /// Parses a string of JSON data at `key` and coerces it to `int256`.\n    function parseJsonInt(\n        string calldata json,\n        string calldata key\n    ) external pure returns (int256);\n\n    /// Parses a string of JSON data at `key` and coerces it to `int256[]`.\n    function parseJsonIntArray(\n        string calldata json,\n        string calldata key\n    ) external pure returns (int256[] memory);\n\n    /// Returns an array of all the keys in a JSON object.\n    function parseJsonKeys(\n        string calldata json,\n        string calldata key\n    ) external pure returns (string[] memory keys);\n\n    /// Parses a string of JSON data at `key` and coerces it to `string`.\n    function parseJsonString(\n        string calldata json,\n        string calldata key\n    ) external pure returns (string memory);\n\n    /// Parses a string of JSON data at `key` and coerces it to `string[]`.\n    function parseJsonStringArray(\n        string calldata json,\n        string calldata key\n    ) external pure returns (string[] memory);\n\n    /// Parses a string of JSON data at `key` and coerces it to type array corresponding to `typeDescription`.\n    function parseJsonTypeArray(\n        string calldata json,\n        string calldata key,\n        string calldata typeDescription\n    ) external pure returns (bytes memory);\n\n    /// Parses a string of JSON data and coerces it to type corresponding to `typeDescription`.\n    function parseJsonType(\n        string calldata json,\n        string calldata typeDescription\n    ) external pure returns (bytes memory);\n\n    /// Parses a string of JSON data at `key` and coerces it to type corresponding to `typeDescription`.\n    function parseJsonType(\n        string calldata json,\n        string calldata key,\n        string calldata typeDescription\n    ) external pure returns (bytes memory);\n\n    /// Parses a string of JSON data at `key` and coerces it to `uint256`.\n    function parseJsonUint(\n        string calldata json,\n        string calldata key\n    ) external pure returns (uint256);\n\n    /// Parses a string of JSON data at `key` and coerces it to `uint256[]`.\n    function parseJsonUintArray(\n        string calldata json,\n        string calldata key\n    ) external pure returns (uint256[] memory);\n\n    /// ABI-encodes a JSON object.\n    function parseJson(\n        string calldata json\n    ) external pure returns (bytes memory abiEncodedData);\n\n    /// ABI-encodes a JSON object at `key`.\n    function parseJson(\n        string calldata json,\n        string calldata key\n    ) external pure returns (bytes memory abiEncodedData);\n\n    /// See `serializeJson`.\n    function serializeAddress(\n        string calldata objectKey,\n        string calldata valueKey,\n        address value\n    ) external returns (string memory json);\n\n    /// See `serializeJson`.\n    function serializeAddress(\n        string calldata objectKey,\n        string calldata valueKey,\n        address[] calldata values\n    ) external returns (string memory json);\n\n    /// See `serializeJson`.\n    function serializeBool(\n        string calldata objectKey,\n        string calldata valueKey,\n        bool value\n    ) external returns (string memory json);\n\n    /// See `serializeJson`.\n    function serializeBool(\n        string calldata objectKey,\n        string calldata valueKey,\n        bool[] calldata values\n    ) external returns (string memory json);\n\n    /// See `serializeJson`.\n    function serializeBytes32(\n        string calldata objectKey,\n        string calldata valueKey,\n        bytes32 value\n    ) external returns (string memory json);\n\n    /// See `serializeJson`.\n    function serializeBytes32(\n        string calldata objectKey,\n        string calldata valueKey,\n        bytes32[] calldata values\n    ) external returns (string memory json);\n\n    /// See `serializeJson`.\n    function serializeBytes(\n        string calldata objectKey,\n        string calldata valueKey,\n        bytes calldata value\n    ) external returns (string memory json);\n\n    /// See `serializeJson`.\n    function serializeBytes(\n        string calldata objectKey,\n        string calldata valueKey,\n        bytes[] calldata values\n    ) external returns (string memory json);\n\n    /// See `serializeJson`.\n    function serializeInt(\n        string calldata objectKey,\n        string calldata valueKey,\n        int256 value\n    ) external returns (string memory json);\n\n    /// See `serializeJson`.\n    function serializeInt(\n        string calldata objectKey,\n        string calldata valueKey,\n        int256[] calldata values\n    ) external returns (string memory json);\n\n    /// Serializes a key and value to a JSON object stored in-memory that can be later written to a file.\n    /// Returns the stringified version of the specific JSON file up to that moment.\n    function serializeJson(\n        string calldata objectKey,\n        string calldata value\n    ) external returns (string memory json);\n\n    /// See `serializeJson`.\n    function serializeJsonType(\n        string calldata typeDescription,\n        bytes calldata value\n    ) external pure returns (string memory json);\n\n    /// See `serializeJson`.\n    function serializeJsonType(\n        string calldata objectKey,\n        string calldata valueKey,\n        string calldata typeDescription,\n        bytes calldata value\n    ) external returns (string memory json);\n\n    /// See `serializeJson`.\n    function serializeString(\n        string calldata objectKey,\n        string calldata valueKey,\n        string calldata value\n    ) external returns (string memory json);\n\n    /// See `serializeJson`.\n    function serializeString(\n        string calldata objectKey,\n        string calldata valueKey,\n        string[] calldata values\n    ) external returns (string memory json);\n\n    /// See `serializeJson`.\n    function serializeUintToHex(\n        string calldata objectKey,\n        string calldata valueKey,\n        uint256 value\n    ) external returns (string memory json);\n\n    /// See `serializeJson`.\n    function serializeUint(\n        string calldata objectKey,\n        string calldata valueKey,\n        uint256 value\n    ) external returns (string memory json);\n\n    /// See `serializeJson`.\n    function serializeUint(\n        string calldata objectKey,\n        string calldata valueKey,\n        uint256[] calldata values\n    ) external returns (string memory json);\n\n    /// Write a serialized JSON object to a file. If the file exists, it will be overwritten.\n    function writeJson(string calldata json, string calldata path) external;\n\n    /// Write a serialized JSON object to an **existing** JSON file, replacing a value with key = <value_key.>\n    /// This is useful to replace a specific value of a JSON file, without having to parse the entire thing.\n    function writeJson(\n        string calldata json,\n        string calldata path,\n        string calldata valueKey\n    ) external;\n\n    /// Checks if `key` exists in a JSON object\n    /// `keyExists` is being deprecated in favor of `keyExistsJson`. It will be removed in future versions.\n    function keyExists(\n        string calldata json,\n        string calldata key\n    ) external view returns (bool);\n\n    // ======== Scripting ========\n\n    /// Designate the next call as an EIP-7702 transaction\n    function attachDelegation(\n        SignedDelegation calldata signedDelegation\n    ) external;\n\n    /// Takes a signed transaction and broadcasts it to the network.\n    function broadcastRawTransaction(bytes calldata data) external;\n\n    /// Has the next call (at this call depth only) create transactions that can later be signed and sent onchain.\n    /// Broadcasting address is determined by checking the following in order:\n    /// 1. If `--sender` argument was provided, that address is used.\n    /// 2. If exactly one signer (e.g. private key, hw wallet, keystore) is set when `forge broadcast` is invoked, that signer is used.\n    /// 3. Otherwise, default foundry sender (1804c8AB1F12E6bbf3894d4083f33e07309d1f38) is used.\n    function broadcast() external;\n\n    /// Has the next call (at this call depth only) create a transaction with the address provided\n    /// as the sender that can later be signed and sent onchain.\n    function broadcast(address signer) external;\n\n    /// Has the next call (at this call depth only) create a transaction with the private key\n    /// provided as the sender that can later be signed and sent onchain.\n    function broadcast(uint256 privateKey) external;\n\n    /// Returns addresses of available unlocked wallets in the script environment.\n    function getWallets() external returns (address[] memory wallets);\n\n    /// Sign an EIP-7702 authorization and designate the next call as an EIP-7702 transaction\n    function signAndAttachDelegation(\n        address implementation,\n        uint256 privateKey\n    ) external returns (SignedDelegation memory signedDelegation);\n\n    /// Sign an EIP-7702 authorization and designate the next call as an EIP-7702 transaction for specific nonce\n    function signAndAttachDelegation(\n        address implementation,\n        uint256 privateKey,\n        uint64 nonce\n    ) external returns (SignedDelegation memory signedDelegation);\n\n    /// Sign an EIP-7702 authorization for delegation\n    function signDelegation(\n        address implementation,\n        uint256 privateKey\n    ) external returns (SignedDelegation memory signedDelegation);\n\n    /// Sign an EIP-7702 authorization for delegation for specific nonce\n    function signDelegation(\n        address implementation,\n        uint256 privateKey,\n        uint64 nonce\n    ) external returns (SignedDelegation memory signedDelegation);\n\n    /// Has all subsequent calls (at this call depth only) create transactions that can later be signed and sent onchain.\n    /// Broadcasting address is determined by checking the following in order:\n    /// 1. If `--sender` argument was provided, that address is used.\n    /// 2. If exactly one signer (e.g. private key, hw wallet, keystore) is set when `forge broadcast` is invoked, that signer is used.\n    /// 3. Otherwise, default foundry sender (1804c8AB1F12E6bbf3894d4083f33e07309d1f38) is used.\n    function startBroadcast() external;\n\n    /// Has all subsequent calls (at this call depth only) create transactions with the address\n    /// provided that can later be signed and sent onchain.\n    function startBroadcast(address signer) external;\n\n    /// Has all subsequent calls (at this call depth only) create transactions with the private key\n    /// provided that can later be signed and sent onchain.\n    function startBroadcast(uint256 privateKey) external;\n\n    /// Stops collecting onchain transactions.\n    function stopBroadcast() external;\n\n    // ======== String ========\n\n    /// Returns true if `search` is found in `subject`, false otherwise.\n    function contains(\n        string calldata subject,\n        string calldata search\n    ) external returns (bool result);\n\n    /// Returns the index of the first occurrence of a `key` in an `input` string.\n    /// Returns `NOT_FOUND` (i.e. `type(uint256).max`) if the `key` is not found.\n    /// Returns 0 in case of an empty `key`.\n    function indexOf(\n        string calldata input,\n        string calldata key\n    ) external pure returns (uint256);\n\n    /// Parses the given `string` into an `address`.\n    function parseAddress(\n        string calldata stringifiedValue\n    ) external pure returns (address parsedValue);\n\n    /// Parses the given `string` into a `bool`.\n    function parseBool(\n        string calldata stringifiedValue\n    ) external pure returns (bool parsedValue);\n\n    /// Parses the given `string` into `bytes`.\n    function parseBytes(\n        string calldata stringifiedValue\n    ) external pure returns (bytes memory parsedValue);\n\n    /// Parses the given `string` into a `bytes32`.\n    function parseBytes32(\n        string calldata stringifiedValue\n    ) external pure returns (bytes32 parsedValue);\n\n    /// Parses the given `string` into a `int256`.\n    function parseInt(\n        string calldata stringifiedValue\n    ) external pure returns (int256 parsedValue);\n\n    /// Parses the given `string` into a `uint256`.\n    function parseUint(\n        string calldata stringifiedValue\n    ) external pure returns (uint256 parsedValue);\n\n    /// Replaces occurrences of `from` in the given `string` with `to`.\n    function replace(\n        string calldata input,\n        string calldata from,\n        string calldata to\n    ) external pure returns (string memory output);\n\n    /// Splits the given `string` into an array of strings divided by the `delimiter`.\n    function split(\n        string calldata input,\n        string calldata delimiter\n    ) external pure returns (string[] memory outputs);\n\n    /// Converts the given `string` value to Lowercase.\n    function toLowercase(\n        string calldata input\n    ) external pure returns (string memory output);\n\n    /// Converts the given value to a `string`.\n    function toString(\n        address value\n    ) external pure returns (string memory stringifiedValue);\n\n    /// Converts the given value to a `string`.\n    function toString(\n        bytes calldata value\n    ) external pure returns (string memory stringifiedValue);\n\n    /// Converts the given value to a `string`.\n    function toString(\n        bytes32 value\n    ) external pure returns (string memory stringifiedValue);\n\n    /// Converts the given value to a `string`.\n    function toString(\n        bool value\n    ) external pure returns (string memory stringifiedValue);\n\n    /// Converts the given value to a `string`.\n    function toString(\n        uint256 value\n    ) external pure returns (string memory stringifiedValue);\n\n    /// Converts the given value to a `string`.\n    function toString(\n        int256 value\n    ) external pure returns (string memory stringifiedValue);\n\n    /// Converts the given `string` value to Uppercase.\n    function toUppercase(\n        string calldata input\n    ) external pure returns (string memory output);\n\n    /// Trims leading and trailing whitespace from the given `string` value.\n    function trim(\n        string calldata input\n    ) external pure returns (string memory output);\n\n    // ======== Testing ========\n\n    /// Compares two `uint256` values. Expects difference to be less than or equal to `maxDelta`.\n    /// Formats values with decimals in failure message.\n    function assertApproxEqAbsDecimal(\n        uint256 left,\n        uint256 right,\n        uint256 maxDelta,\n        uint256 decimals\n    ) external pure;\n\n    /// Compares two `uint256` values. Expects difference to be less than or equal to `maxDelta`.\n    /// Formats values with decimals in failure message. Includes error message into revert string on failure.\n    function assertApproxEqAbsDecimal(\n        uint256 left,\n        uint256 right,\n        uint256 maxDelta,\n        uint256 decimals,\n        string calldata error\n    ) external pure;\n\n    /// Compares two `int256` values. Expects difference to be less than or equal to `maxDelta`.\n    /// Formats values with decimals in failure message.\n    function assertApproxEqAbsDecimal(\n        int256 left,\n        int256 right,\n        uint256 maxDelta,\n        uint256 decimals\n    ) external pure;\n\n    /// Compares two `int256` values. Expects difference to be less than or equal to `maxDelta`.\n    /// Formats values with decimals in failure message. Includes error message into revert string on failure.\n    function assertApproxEqAbsDecimal(\n        int256 left,\n        int256 right,\n        uint256 maxDelta,\n        uint256 decimals,\n        string calldata error\n    ) external pure;\n\n    /// Compares two `uint256` values. Expects difference to be less than or equal to `maxDelta`.\n    function assertApproxEqAbs(\n        uint256 left,\n        uint256 right,\n        uint256 maxDelta\n    ) external pure;\n\n    /// Compares two `uint256` values. Expects difference to be less than or equal to `maxDelta`.\n    /// Includes error message into revert string on failure.\n    function assertApproxEqAbs(\n        uint256 left,\n        uint256 right,\n        uint256 maxDelta,\n        string calldata error\n    ) external pure;\n\n    /// Compares two `int256` values. Expects difference to be less than or equal to `maxDelta`.\n    function assertApproxEqAbs(\n        int256 left,\n        int256 right,\n        uint256 maxDelta\n    ) external pure;\n\n    /// Compares two `int256` values. Expects difference to be less than or equal to `maxDelta`.\n    /// Includes error message into revert string on failure.\n    function assertApproxEqAbs(\n        int256 left,\n        int256 right,\n        uint256 maxDelta,\n        string calldata error\n    ) external pure;\n\n    /// Compares two `uint256` values. Expects relative difference in percents to be less than or equal to `maxPercentDelta`.\n    /// `maxPercentDelta` is an 18 decimal fixed point number, where 1e18 == 100%\n    /// Formats values with decimals in failure message.\n    function assertApproxEqRelDecimal(\n        uint256 left,\n        uint256 right,\n        uint256 maxPercentDelta,\n        uint256 decimals\n    ) external pure;\n\n    /// Compares two `uint256` values. Expects relative difference in percents to be less than or equal to `maxPercentDelta`.\n    /// `maxPercentDelta` is an 18 decimal fixed point number, where 1e18 == 100%\n    /// Formats values with decimals in failure message. Includes error message into revert string on failure.\n    function assertApproxEqRelDecimal(\n        uint256 left,\n        uint256 right,\n        uint256 maxPercentDelta,\n        uint256 decimals,\n        string calldata error\n    ) external pure;\n\n    /// Compares two `int256` values. Expects relative difference in percents to be less than or equal to `maxPercentDelta`.\n    /// `maxPercentDelta` is an 18 decimal fixed point number, where 1e18 == 100%\n    /// Formats values with decimals in failure message.\n    function assertApproxEqRelDecimal(\n        int256 left,\n        int256 right,\n        uint256 maxPercentDelta,\n        uint256 decimals\n    ) external pure;\n\n    /// Compares two `int256` values. Expects relative difference in percents to be less than or equal to `maxPercentDelta`.\n    /// `maxPercentDelta` is an 18 decimal fixed point number, where 1e18 == 100%\n    /// Formats values with decimals in failure message. Includes error message into revert string on failure.\n    function assertApproxEqRelDecimal(\n        int256 left,\n        int256 right,\n        uint256 maxPercentDelta,\n        uint256 decimals,\n        string calldata error\n    ) external pure;\n\n    /// Compares two `uint256` values. Expects relative difference in percents to be less than or equal to `maxPercentDelta`.\n    /// `maxPercentDelta` is an 18 decimal fixed point number, where 1e18 == 100%\n    function assertApproxEqRel(\n        uint256 left,\n        uint256 right,\n        uint256 maxPercentDelta\n    ) external pure;\n\n    /// Compares two `uint256` values. Expects relative difference in percents to be less than or equal to `maxPercentDelta`.\n    /// `maxPercentDelta` is an 18 decimal fixed point number, where 1e18 == 100%\n    /// Includes error message into revert string on failure.\n    function assertApproxEqRel(\n        uint256 left,\n        uint256 right,\n        uint256 maxPercentDelta,\n        string calldata error\n    ) external pure;\n\n    /// Compares two `int256` values. Expects relative difference in percents to be less than or equal to `maxPercentDelta`.\n    /// `maxPercentDelta` is an 18 decimal fixed point number, where 1e18 == 100%\n    function assertApproxEqRel(\n        int256 left,\n        int256 right,\n        uint256 maxPercentDelta\n    ) external pure;\n\n    /// Compares two `int256` values. Expects relative difference in percents to be less than or equal to `maxPercentDelta`.\n    /// `maxPercentDelta` is an 18 decimal fixed point number, where 1e18 == 100%\n    /// Includes error message into revert string on failure.\n    function assertApproxEqRel(\n        int256 left,\n        int256 right,\n        uint256 maxPercentDelta,\n        string calldata error\n    ) external pure;\n\n    /// Asserts that two `uint256` values are equal, formatting them with decimals in failure message.\n    function assertEqDecimal(\n        uint256 left,\n        uint256 right,\n        uint256 decimals\n    ) external pure;\n\n    /// Asserts that two `uint256` values are equal, formatting them with decimals in failure message.\n    /// Includes error message into revert string on failure.\n    function assertEqDecimal(\n        uint256 left,\n        uint256 right,\n        uint256 decimals,\n        string calldata error\n    ) external pure;\n\n    /// Asserts that two `int256` values are equal, formatting them with decimals in failure message.\n    function assertEqDecimal(\n        int256 left,\n        int256 right,\n        uint256 decimals\n    ) external pure;\n\n    /// Asserts that two `int256` values are equal, formatting them with decimals in failure message.\n    /// Includes error message into revert string on failure.\n    function assertEqDecimal(\n        int256 left,\n        int256 right,\n        uint256 decimals,\n        string calldata error\n    ) external pure;\n\n    /// Asserts that two `bool` values are equal.\n    function assertEq(bool left, bool right) external pure;\n\n    /// Asserts that two `bool` values are equal and includes error message into revert string on failure.\n    function assertEq(\n        bool left,\n        bool right,\n        string calldata error\n    ) external pure;\n\n    /// Asserts that two `string` values are equal.\n    function assertEq(\n        string calldata left,\n        string calldata right\n    ) external pure;\n\n    /// Asserts that two `string` values are equal and includes error message into revert string on failure.\n    function assertEq(\n        string calldata left,\n        string calldata right,\n        string calldata error\n    ) external pure;\n\n    /// Asserts that two `bytes` values are equal.\n    function assertEq(bytes calldata left, bytes calldata right) external pure;\n\n    /// Asserts that two `bytes` values are equal and includes error message into revert string on failure.\n    function assertEq(\n        bytes calldata left,\n        bytes calldata right,\n        string calldata error\n    ) external pure;\n\n    /// Asserts that two arrays of `bool` values are equal.\n    function assertEq(\n        bool[] calldata left,\n        bool[] calldata right\n    ) external pure;\n\n    /// Asserts that two arrays of `bool` values are equal and includes error message into revert string on failure.\n    function assertEq(\n        bool[] calldata left,\n        bool[] calldata right,\n        string calldata error\n    ) external pure;\n\n    /// Asserts that two arrays of `uint256 values are equal.\n    function assertEq(\n        uint256[] calldata left,\n        uint256[] calldata right\n    ) external pure;\n\n    /// Asserts that two arrays of `uint256` values are equal and includes error message into revert string on failure.\n    function assertEq(\n        uint256[] calldata left,\n        uint256[] calldata right,\n        string calldata error\n    ) external pure;\n\n    /// Asserts that two arrays of `int256` values are equal.\n    function assertEq(\n        int256[] calldata left,\n        int256[] calldata right\n    ) external pure;\n\n    /// Asserts that two arrays of `int256` values are equal and includes error message into revert string on failure.\n    function assertEq(\n        int256[] calldata left,\n        int256[] calldata right,\n        string calldata error\n    ) external pure;\n\n    /// Asserts that two `uint256` values are equal.\n    function assertEq(uint256 left, uint256 right) external pure;\n\n    /// Asserts that two arrays of `address` values are equal.\n    function assertEq(\n        address[] calldata left,\n        address[] calldata right\n    ) external pure;\n\n    /// Asserts that two arrays of `address` values are equal and includes error message into revert string on failure.\n    function assertEq(\n        address[] calldata left,\n        address[] calldata right,\n        string calldata error\n    ) external pure;\n\n    /// Asserts that two arrays of `bytes32` values are equal.\n    function assertEq(\n        bytes32[] calldata left,\n        bytes32[] calldata right\n    ) external pure;\n\n    /// Asserts that two arrays of `bytes32` values are equal and includes error message into revert string on failure.\n    function assertEq(\n        bytes32[] calldata left,\n        bytes32[] calldata right,\n        string calldata error\n    ) external pure;\n\n    /// Asserts that two arrays of `string` values are equal.\n    function assertEq(\n        string[] calldata left,\n        string[] calldata right\n    ) external pure;\n\n    /// Asserts that two arrays of `string` values are equal and includes error message into revert string on failure.\n    function assertEq(\n        string[] calldata left,\n        string[] calldata right,\n        string calldata error\n    ) external pure;\n\n    /// Asserts that two arrays of `bytes` values are equal.\n    function assertEq(\n        bytes[] calldata left,\n        bytes[] calldata right\n    ) external pure;\n\n    /// Asserts that two arrays of `bytes` values are equal and includes error message into revert string on failure.\n    function assertEq(\n        bytes[] calldata left,\n        bytes[] calldata right,\n        string calldata error\n    ) external pure;\n\n    /// Asserts that two `uint256` values are equal and includes error message into revert string on failure.\n    function assertEq(\n        uint256 left,\n        uint256 right,\n        string calldata error\n    ) external pure;\n\n    /// Asserts that two `int256` values are equal.\n    function assertEq(int256 left, int256 right) external pure;\n\n    /// Asserts that two `int256` values are equal and includes error message into revert string on failure.\n    function assertEq(\n        int256 left,\n        int256 right,\n        string calldata error\n    ) external pure;\n\n    /// Asserts that two `address` values are equal.\n    function assertEq(address left, address right) external pure;\n\n    /// Asserts that two `address` values are equal and includes error message into revert string on failure.\n    function assertEq(\n        address left,\n        address right,\n        string calldata error\n    ) external pure;\n\n    /// Asserts that two `bytes32` values are equal.\n    function assertEq(bytes32 left, bytes32 right) external pure;\n\n    /// Asserts that two `bytes32` values are equal and includes error message into revert string on failure.\n    function assertEq(\n        bytes32 left,\n        bytes32 right,\n        string calldata error\n    ) external pure;\n\n    /// Asserts that the given condition is false.\n    function assertFalse(bool condition) external pure;\n\n    /// Asserts that the given condition is false and includes error message into revert string on failure.\n    function assertFalse(bool condition, string calldata error) external pure;\n\n    /// Compares two `uint256` values. Expects first value to be greater than or equal to second.\n    /// Formats values with decimals in failure message.\n    function assertGeDecimal(\n        uint256 left,\n        uint256 right,\n        uint256 decimals\n    ) external pure;\n\n    /// Compares two `uint256` values. Expects first value to be greater than or equal to second.\n    /// Formats values with decimals in failure message. Includes error message into revert string on failure.\n    function assertGeDecimal(\n        uint256 left,\n        uint256 right,\n        uint256 decimals,\n        string calldata error\n    ) external pure;\n\n    /// Compares two `int256` values. Expects first value to be greater than or equal to second.\n    /// Formats values with decimals in failure message.\n    function assertGeDecimal(\n        int256 left,\n        int256 right,\n        uint256 decimals\n    ) external pure;\n\n    /// Compares two `int256` values. Expects first value to be greater than or equal to second.\n    /// Formats values with decimals in failure message. Includes error message into revert string on failure.\n    function assertGeDecimal(\n        int256 left,\n        int256 right,\n        uint256 decimals,\n        string calldata error\n    ) external pure;\n\n    /// Compares two `uint256` values. Expects first value to be greater than or equal to second.\n    function assertGe(uint256 left, uint256 right) external pure;\n\n    /// Compares two `uint256` values. Expects first value to be greater than or equal to second.\n    /// Includes error message into revert string on failure.\n    function assertGe(\n        uint256 left,\n        uint256 right,\n        string calldata error\n    ) external pure;\n\n    /// Compares two `int256` values. Expects first value to be greater than or equal to second.\n    function assertGe(int256 left, int256 right) external pure;\n\n    /// Compares two `int256` values. Expects first value to be greater than or equal to second.\n    /// Includes error message into revert string on failure.\n    function assertGe(\n        int256 left,\n        int256 right,\n        string calldata error\n    ) external pure;\n\n    /// Compares two `uint256` values. Expects first value to be greater than second.\n    /// Formats values with decimals in failure message.\n    function assertGtDecimal(\n        uint256 left,\n        uint256 right,\n        uint256 decimals\n    ) external pure;\n\n    /// Compares two `uint256` values. Expects first value to be greater than second.\n    /// Formats values with decimals in failure message. Includes error message into revert string on failure.\n    function assertGtDecimal(\n        uint256 left,\n        uint256 right,\n        uint256 decimals,\n        string calldata error\n    ) external pure;\n\n    /// Compares two `int256` values. Expects first value to be greater than second.\n    /// Formats values with decimals in failure message.\n    function assertGtDecimal(\n        int256 left,\n        int256 right,\n        uint256 decimals\n    ) external pure;\n\n    /// Compares two `int256` values. Expects first value to be greater than second.\n    /// Formats values with decimals in failure message. Includes error message into revert string on failure.\n    function assertGtDecimal(\n        int256 left,\n        int256 right,\n        uint256 decimals,\n        string calldata error\n    ) external pure;\n\n    /// Compares two `uint256` values. Expects first value to be greater than second.\n    function assertGt(uint256 left, uint256 right) external pure;\n\n    /// Compares two `uint256` values. Expects first value to be greater than second.\n    /// Includes error message into revert string on failure.\n    function assertGt(\n        uint256 left,\n        uint256 right,\n        string calldata error\n    ) external pure;\n\n    /// Compares two `int256` values. Expects first value to be greater than second.\n    function assertGt(int256 left, int256 right) external pure;\n\n    /// Compares two `int256` values. Expects first value to be greater than second.\n    /// Includes error message into revert string on failure.\n    function assertGt(\n        int256 left,\n        int256 right,\n        string calldata error\n    ) external pure;\n\n    /// Compares two `uint256` values. Expects first value to be less than or equal to second.\n    /// Formats values with decimals in failure message.\n    function assertLeDecimal(\n        uint256 left,\n        uint256 right,\n        uint256 decimals\n    ) external pure;\n\n    /// Compares two `uint256` values. Expects first value to be less than or equal to second.\n    /// Formats values with decimals in failure message. Includes error message into revert string on failure.\n    function assertLeDecimal(\n        uint256 left,\n        uint256 right,\n        uint256 decimals,\n        string calldata error\n    ) external pure;\n\n    /// Compares two `int256` values. Expects first value to be less than or equal to second.\n    /// Formats values with decimals in failure message.\n    function assertLeDecimal(\n        int256 left,\n        int256 right,\n        uint256 decimals\n    ) external pure;\n\n    /// Compares two `int256` values. Expects first value to be less than or equal to second.\n    /// Formats values with decimals in failure message. Includes error message into revert string on failure.\n    function assertLeDecimal(\n        int256 left,\n        int256 right,\n        uint256 decimals,\n        string calldata error\n    ) external pure;\n\n    /// Compares two `uint256` values. Expects first value to be less than or equal to second.\n    function assertLe(uint256 left, uint256 right) external pure;\n\n    /// Compares two `uint256` values. Expects first value to be less than or equal to second.\n    /// Includes error message into revert string on failure.\n    function assertLe(\n        uint256 left,\n        uint256 right,\n        string calldata error\n    ) external pure;\n\n    /// Compares two `int256` values. Expects first value to be less than or equal to second.\n    function assertLe(int256 left, int256 right) external pure;\n\n    /// Compares two `int256` values. Expects first value to be less than or equal to second.\n    /// Includes error message into revert string on failure.\n    function assertLe(\n        int256 left,\n        int256 right,\n        string calldata error\n    ) external pure;\n\n    /// Compares two `uint256` values. Expects first value to be less than second.\n    /// Formats values with decimals in failure message.\n    function assertLtDecimal(\n        uint256 left,\n        uint256 right,\n        uint256 decimals\n    ) external pure;\n\n    /// Compares two `uint256` values. Expects first value to be less than second.\n    /// Formats values with decimals in failure message. Includes error message into revert string on failure.\n    function assertLtDecimal(\n        uint256 left,\n        uint256 right,\n        uint256 decimals,\n        string calldata error\n    ) external pure;\n\n    /// Compares two `int256` values. Expects first value to be less than second.\n    /// Formats values with decimals in failure message.\n    function assertLtDecimal(\n        int256 left,\n        int256 right,\n        uint256 decimals\n    ) external pure;\n\n    /// Compares two `int256` values. Expects first value to be less than second.\n    /// Formats values with decimals in failure message. Includes error message into revert string on failure.\n    function assertLtDecimal(\n        int256 left,\n        int256 right,\n        uint256 decimals,\n        string calldata error\n    ) external pure;\n\n    /// Compares two `uint256` values. Expects first value to be less than second.\n    function assertLt(uint256 left, uint256 right) external pure;\n\n    /// Compares two `uint256` values. Expects first value to be less than second.\n    /// Includes error message into revert string on failure.\n    function assertLt(\n        uint256 left,\n        uint256 right,\n        string calldata error\n    ) external pure;\n\n    /// Compares two `int256` values. Expects first value to be less than second.\n    function assertLt(int256 left, int256 right) external pure;\n\n    /// Compares two `int256` values. Expects first value to be less than second.\n    /// Includes error message into revert string on failure.\n    function assertLt(\n        int256 left,\n        int256 right,\n        string calldata error\n    ) external pure;\n\n    /// Asserts that two `uint256` values are not equal, formatting them with decimals in failure message.\n    function assertNotEqDecimal(\n        uint256 left,\n        uint256 right,\n        uint256 decimals\n    ) external pure;\n\n    /// Asserts that two `uint256` values are not equal, formatting them with decimals in failure message.\n    /// Includes error message into revert string on failure.\n    function assertNotEqDecimal(\n        uint256 left,\n        uint256 right,\n        uint256 decimals,\n        string calldata error\n    ) external pure;\n\n    /// Asserts that two `int256` values are not equal, formatting them with decimals in failure message.\n    function assertNotEqDecimal(\n        int256 left,\n        int256 right,\n        uint256 decimals\n    ) external pure;\n\n    /// Asserts that two `int256` values are not equal, formatting them with decimals in failure message.\n    /// Includes error message into revert string on failure.\n    function assertNotEqDecimal(\n        int256 left,\n        int256 right,\n        uint256 decimals,\n        string calldata error\n    ) external pure;\n\n    /// Asserts that two `bool` values are not equal.\n    function assertNotEq(bool left, bool right) external pure;\n\n    /// Asserts that two `bool` values are not equal and includes error message into revert string on failure.\n    function assertNotEq(\n        bool left,\n        bool right,\n        string calldata error\n    ) external pure;\n\n    /// Asserts that two `string` values are not equal.\n    function assertNotEq(\n        string calldata left,\n        string calldata right\n    ) external pure;\n\n    /// Asserts that two `string` values are not equal and includes error message into revert string on failure.\n    function assertNotEq(\n        string calldata left,\n        string calldata right,\n        string calldata error\n    ) external pure;\n\n    /// Asserts that two `bytes` values are not equal.\n    function assertNotEq(\n        bytes calldata left,\n        bytes calldata right\n    ) external pure;\n\n    /// Asserts that two `bytes` values are not equal and includes error message into revert string on failure.\n    function assertNotEq(\n        bytes calldata left,\n        bytes calldata right,\n        string calldata error\n    ) external pure;\n\n    /// Asserts that two arrays of `bool` values are not equal.\n    function assertNotEq(\n        bool[] calldata left,\n        bool[] calldata right\n    ) external pure;\n\n    /// Asserts that two arrays of `bool` values are not equal and includes error message into revert string on failure.\n    function assertNotEq(\n        bool[] calldata left,\n        bool[] calldata right,\n        string calldata error\n    ) external pure;\n\n    /// Asserts that two arrays of `uint256` values are not equal.\n    function assertNotEq(\n        uint256[] calldata left,\n        uint256[] calldata right\n    ) external pure;\n\n    /// Asserts that two arrays of `uint256` values are not equal and includes error message into revert string on failure.\n    function assertNotEq(\n        uint256[] calldata left,\n        uint256[] calldata right,\n        string calldata error\n    ) external pure;\n\n    /// Asserts that two arrays of `int256` values are not equal.\n    function assertNotEq(\n        int256[] calldata left,\n        int256[] calldata right\n    ) external pure;\n\n    /// Asserts that two arrays of `int256` values are not equal and includes error message into revert string on failure.\n    function assertNotEq(\n        int256[] calldata left,\n        int256[] calldata right,\n        string calldata error\n    ) external pure;\n\n    /// Asserts that two `uint256` values are not equal.\n    function assertNotEq(uint256 left, uint256 right) external pure;\n\n    /// Asserts that two arrays of `address` values are not equal.\n    function assertNotEq(\n        address[] calldata left,\n        address[] calldata right\n    ) external pure;\n\n    /// Asserts that two arrays of `address` values are not equal and includes error message into revert string on failure.\n    function assertNotEq(\n        address[] calldata left,\n        address[] calldata right,\n        string calldata error\n    ) external pure;\n\n    /// Asserts that two arrays of `bytes32` values are not equal.\n    function assertNotEq(\n        bytes32[] calldata left,\n        bytes32[] calldata right\n    ) external pure;\n\n    /// Asserts that two arrays of `bytes32` values are not equal and includes error message into revert string on failure.\n    function assertNotEq(\n        bytes32[] calldata left,\n        bytes32[] calldata right,\n        string calldata error\n    ) external pure;\n\n    /// Asserts that two arrays of `string` values are not equal.\n    function assertNotEq(\n        string[] calldata left,\n        string[] calldata right\n    ) external pure;\n\n    /// Asserts that two arrays of `string` values are not equal and includes error message into revert string on failure.\n    function assertNotEq(\n        string[] calldata left,\n        string[] calldata right,\n        string calldata error\n    ) external pure;\n\n    /// Asserts that two arrays of `bytes` values are not equal.\n    function assertNotEq(\n        bytes[] calldata left,\n        bytes[] calldata right\n    ) external pure;\n\n    /// Asserts that two arrays of `bytes` values are not equal and includes error message into revert string on failure.\n    function assertNotEq(\n        bytes[] calldata left,\n        bytes[] calldata right,\n        string calldata error\n    ) external pure;\n\n    /// Asserts that two `uint256` values are not equal and includes error message into revert string on failure.\n    function assertNotEq(\n        uint256 left,\n        uint256 right,\n        string calldata error\n    ) external pure;\n\n    /// Asserts that two `int256` values are not equal.\n    function assertNotEq(int256 left, int256 right) external pure;\n\n    /// Asserts that two `int256` values are not equal and includes error message into revert string on failure.\n    function assertNotEq(\n        int256 left,\n        int256 right,\n        string calldata error\n    ) external pure;\n\n    /// Asserts that two `address` values are not equal.\n    function assertNotEq(address left, address right) external pure;\n\n    /// Asserts that two `address` values are not equal and includes error message into revert string on failure.\n    function assertNotEq(\n        address left,\n        address right,\n        string calldata error\n    ) external pure;\n\n    /// Asserts that two `bytes32` values are not equal.\n    function assertNotEq(bytes32 left, bytes32 right) external pure;\n\n    /// Asserts that two `bytes32` values are not equal and includes error message into revert string on failure.\n    function assertNotEq(\n        bytes32 left,\n        bytes32 right,\n        string calldata error\n    ) external pure;\n\n    /// Asserts that the given condition is true.\n    function assertTrue(bool condition) external pure;\n\n    /// Asserts that the given condition is true and includes error message into revert string on failure.\n    function assertTrue(bool condition, string calldata error) external pure;\n\n    /// If the condition is false, discard this run's fuzz inputs and generate new ones.\n    function assume(bool condition) external pure;\n\n    /// Discard this run's fuzz inputs and generate new ones if next call reverted.\n    function assumeNoRevert() external pure;\n\n    /// Discard this run's fuzz inputs and generate new ones if next call reverts with the potential revert parameters.\n    function assumeNoRevert(\n        PotentialRevert calldata potentialRevert\n    ) external pure;\n\n    /// Discard this run's fuzz inputs and generate new ones if next call reverts with the any of the potential revert parameters.\n    function assumeNoRevert(\n        PotentialRevert[] calldata potentialReverts\n    ) external pure;\n\n    /// Writes a breakpoint to jump to in the debugger.\n    function breakpoint(string calldata char) external pure;\n\n    /// Writes a conditional breakpoint to jump to in the debugger.\n    function breakpoint(string calldata char, bool value) external pure;\n\n    /// Returns true if the current Foundry version is greater than or equal to the given version.\n    /// The given version string must be in the format `major.minor.patch`.\n    /// This is equivalent to `foundryVersionCmp(version) >= 0`.\n    function foundryVersionAtLeast(\n        string calldata version\n    ) external view returns (bool);\n\n    /// Compares the current Foundry version with the given version string.\n    /// The given version string must be in the format `major.minor.patch`.\n    /// Returns:\n    /// -1 if current Foundry version is less than the given version\n    /// 0 if current Foundry version equals the given version\n    /// 1 if current Foundry version is greater than the given version\n    /// This result can then be used with a comparison operator against `0`.\n    /// For example, to check if the current Foundry version is greater than or equal to `1.0.0`:\n    /// `if (foundryVersionCmp(\"1.0.0\") >= 0) { ... }`\n    function foundryVersionCmp(\n        string calldata version\n    ) external view returns (int256);\n\n    /// Returns the Foundry version.\n    /// Format: <cargo_version>-<tag>+<git_sha_short>.<unix_build_timestamp>.<profile>\n    /// Sample output: 0.3.0-nightly+3cb96bde9b.1737036656.debug\n    /// Note: Build timestamps may vary slightly across platforms due to separate CI jobs.\n    /// For reliable version comparisons, use UNIX format (e.g., >= 1700000000)\n    /// to compare timestamps while ignoring minor time differences.\n    function getFoundryVersion() external view returns (string memory version);\n\n    /// Returns the RPC url for the given alias.\n    function rpcUrl(\n        string calldata rpcAlias\n    ) external view returns (string memory json);\n\n    /// Returns all rpc urls and their aliases as structs.\n    function rpcUrlStructs() external view returns (Rpc[] memory urls);\n\n    /// Returns all rpc urls and their aliases `[alias, url][]`.\n    function rpcUrls() external view returns (string[2][] memory urls);\n\n    /// Suspends execution of the main thread for `duration` milliseconds.\n    function sleep(uint256 duration) external;\n\n    // ======== Toml ========\n\n    /// Checks if `key` exists in a TOML table.\n    function keyExistsToml(\n        string calldata toml,\n        string calldata key\n    ) external view returns (bool);\n\n    /// Parses a string of TOML data at `key` and coerces it to `address`.\n    function parseTomlAddress(\n        string calldata toml,\n        string calldata key\n    ) external pure returns (address);\n\n    /// Parses a string of TOML data at `key` and coerces it to `address[]`.\n    function parseTomlAddressArray(\n        string calldata toml,\n        string calldata key\n    ) external pure returns (address[] memory);\n\n    /// Parses a string of TOML data at `key` and coerces it to `bool`.\n    function parseTomlBool(\n        string calldata toml,\n        string calldata key\n    ) external pure returns (bool);\n\n    /// Parses a string of TOML data at `key` and coerces it to `bool[]`.\n    function parseTomlBoolArray(\n        string calldata toml,\n        string calldata key\n    ) external pure returns (bool[] memory);\n\n    /// Parses a string of TOML data at `key` and coerces it to `bytes`.\n    function parseTomlBytes(\n        string calldata toml,\n        string calldata key\n    ) external pure returns (bytes memory);\n\n    /// Parses a string of TOML data at `key` and coerces it to `bytes32`.\n    function parseTomlBytes32(\n        string calldata toml,\n        string calldata key\n    ) external pure returns (bytes32);\n\n    /// Parses a string of TOML data at `key` and coerces it to `bytes32[]`.\n    function parseTomlBytes32Array(\n        string calldata toml,\n        string calldata key\n    ) external pure returns (bytes32[] memory);\n\n    /// Parses a string of TOML data at `key` and coerces it to `bytes[]`.\n    function parseTomlBytesArray(\n        string calldata toml,\n        string calldata key\n    ) external pure returns (bytes[] memory);\n\n    /// Parses a string of TOML data at `key` and coerces it to `int256`.\n    function parseTomlInt(\n        string calldata toml,\n        string calldata key\n    ) external pure returns (int256);\n\n    /// Parses a string of TOML data at `key` and coerces it to `int256[]`.\n    function parseTomlIntArray(\n        string calldata toml,\n        string calldata key\n    ) external pure returns (int256[] memory);\n\n    /// Returns an array of all the keys in a TOML table.\n    function parseTomlKeys(\n        string calldata toml,\n        string calldata key\n    ) external pure returns (string[] memory keys);\n\n    /// Parses a string of TOML data at `key` and coerces it to `string`.\n    function parseTomlString(\n        string calldata toml,\n        string calldata key\n    ) external pure returns (string memory);\n\n    /// Parses a string of TOML data at `key` and coerces it to `string[]`.\n    function parseTomlStringArray(\n        string calldata toml,\n        string calldata key\n    ) external pure returns (string[] memory);\n\n    /// Parses a string of TOML data at `key` and coerces it to type array corresponding to `typeDescription`.\n    function parseTomlTypeArray(\n        string calldata toml,\n        string calldata key,\n        string calldata typeDescription\n    ) external pure returns (bytes memory);\n\n    /// Parses a string of TOML data and coerces it to type corresponding to `typeDescription`.\n    function parseTomlType(\n        string calldata toml,\n        string calldata typeDescription\n    ) external pure returns (bytes memory);\n\n    /// Parses a string of TOML data at `key` and coerces it to type corresponding to `typeDescription`.\n    function parseTomlType(\n        string calldata toml,\n        string calldata key,\n        string calldata typeDescription\n    ) external pure returns (bytes memory);\n\n    /// Parses a string of TOML data at `key` and coerces it to `uint256`.\n    function parseTomlUint(\n        string calldata toml,\n        string calldata key\n    ) external pure returns (uint256);\n\n    /// Parses a string of TOML data at `key` and coerces it to `uint256[]`.\n    function parseTomlUintArray(\n        string calldata toml,\n        string calldata key\n    ) external pure returns (uint256[] memory);\n\n    /// ABI-encodes a TOML table.\n    function parseToml(\n        string calldata toml\n    ) external pure returns (bytes memory abiEncodedData);\n\n    /// ABI-encodes a TOML table at `key`.\n    function parseToml(\n        string calldata toml,\n        string calldata key\n    ) external pure returns (bytes memory abiEncodedData);\n\n    /// Takes serialized JSON, converts to TOML and write a serialized TOML to a file.\n    function writeToml(string calldata json, string calldata path) external;\n\n    /// Takes serialized JSON, converts to TOML and write a serialized TOML table to an **existing** TOML file, replacing a value with key = <value_key.>\n    /// This is useful to replace a specific value of a TOML file, without having to parse the entire thing.\n    function writeToml(\n        string calldata json,\n        string calldata path,\n        string calldata valueKey\n    ) external;\n\n    // ======== Utilities ========\n\n    /// Compute the address of a contract created with CREATE2 using the given CREATE2 deployer.\n    function computeCreate2Address(\n        bytes32 salt,\n        bytes32 initCodeHash,\n        address deployer\n    ) external pure returns (address);\n\n    /// Compute the address of a contract created with CREATE2 using the default CREATE2 deployer.\n    function computeCreate2Address(\n        bytes32 salt,\n        bytes32 initCodeHash\n    ) external pure returns (address);\n\n    /// Compute the address a contract will be deployed at for a given deployer address and nonce.\n    function computeCreateAddress(\n        address deployer,\n        uint256 nonce\n    ) external pure returns (address);\n\n    /// Utility cheatcode to copy storage of `from` contract to another `to` contract.\n    function copyStorage(address from, address to) external;\n\n    /// Returns ENS namehash for provided string.\n    function ensNamehash(string calldata name) external pure returns (bytes32);\n\n    /// Gets the label for the specified address.\n    function getLabel(\n        address account\n    ) external view returns (string memory currentLabel);\n\n    /// Labels an address in call traces.\n    function label(address account, string calldata newLabel) external;\n\n    /// Pauses collection of call traces. Useful in cases when you want to skip tracing of\n    /// complex calls which are not useful for debugging.\n    function pauseTracing() external view;\n\n    /// Returns a random `address`.\n    function randomAddress() external returns (address);\n\n    /// Returns a random `bool`.\n    function randomBool() external view returns (bool);\n\n    /// Returns a random byte array value of the given length.\n    function randomBytes(uint256 len) external view returns (bytes memory);\n\n    /// Returns a random fixed-size byte array of length 4.\n    function randomBytes4() external view returns (bytes4);\n\n    /// Returns a random fixed-size byte array of length 8.\n    function randomBytes8() external view returns (bytes8);\n\n    /// Returns a random `int256` value.\n    function randomInt() external view returns (int256);\n\n    /// Returns a random `int256` value of given bits.\n    function randomInt(uint256 bits) external view returns (int256);\n\n    /// Returns a random uint256 value.\n    function randomUint() external returns (uint256);\n\n    /// Returns random uint256 value between the provided range (=min..=max).\n    function randomUint(uint256 min, uint256 max) external returns (uint256);\n\n    /// Returns a random `uint256` value of given bits.\n    function randomUint(uint256 bits) external view returns (uint256);\n\n    /// Unpauses collection of call traces.\n    function resumeTracing() external view;\n\n    /// Utility cheatcode to set arbitrary storage for given target address.\n    function setArbitraryStorage(address target) external;\n\n    /// Utility cheatcode to set arbitrary storage for given target address and overwrite\n    /// any storage slots that have been previously set.\n    function setArbitraryStorage(address target, bool overwrite) external;\n\n    /// Randomly shuffles an array.\n    function shuffle(\n        uint256[] calldata array\n    ) external returns (uint256[] memory);\n\n    /// Sorts an array in ascending order.\n    function sort(uint256[] calldata array) external returns (uint256[] memory);\n\n    /// Encodes a `bytes` value to a base64url string.\n    function toBase64URL(\n        bytes calldata data\n    ) external pure returns (string memory);\n\n    /// Encodes a `string` value to a base64url string.\n    function toBase64URL(\n        string calldata data\n    ) external pure returns (string memory);\n\n    /// Encodes a `bytes` value to a base64 string.\n    function toBase64(\n        bytes calldata data\n    ) external pure returns (string memory);\n\n    /// Encodes a `string` value to a base64 string.\n    function toBase64(\n        string calldata data\n    ) external pure returns (string memory);\n}\n\n/// The `Vm` interface does allow manipulation of the EVM state. These are all intended to be used\n/// in tests, but it is not recommended to use these cheats in scripts.\ninterface Vm is VmSafe {\n    // ======== EVM ========\n\n    /// Utility cheatcode to set an EIP-2930 access list for all subsequent transactions.\n    function accessList(AccessListItem[] calldata access) external;\n\n    /// Returns the identifier of the currently active fork. Reverts if no fork is currently active.\n    function activeFork() external view returns (uint256 forkId);\n\n    /// In forking mode, explicitly grant the given address cheatcode access.\n    function allowCheatcodes(address account) external;\n\n    /// Sets `block.blobbasefee`\n    function blobBaseFee(uint256 newBlobBaseFee) external;\n\n    /// Sets the blobhashes in the transaction.\n    /// Not available on EVM versions before Cancun.\n    /// If used on unsupported EVM versions it will revert.\n    function blobhashes(bytes32[] calldata hashes) external;\n\n    /// Sets `block.chainid`.\n    function chainId(uint256 newChainId) external;\n\n    /// Clears all mocked calls.\n    function clearMockedCalls() external;\n\n    /// Clones a source account code, state, balance and nonce to a target account and updates in-memory EVM state.\n    function cloneAccount(address source, address target) external;\n\n    /// Sets `block.coinbase`.\n    function coinbase(address newCoinbase) external;\n\n    /// Marks the slots of an account and the account address as cold.\n    function cool(address target) external;\n\n    /// Utility cheatcode to mark specific storage slot as cold, simulating no prior read.\n    function coolSlot(address target, bytes32 slot) external;\n\n    /// Creates a new fork with the given endpoint and the _latest_ block and returns the identifier of the fork.\n    function createFork(\n        string calldata urlOrAlias\n    ) external returns (uint256 forkId);\n\n    /// Creates a new fork with the given endpoint and block and returns the identifier of the fork.\n    function createFork(\n        string calldata urlOrAlias,\n        uint256 blockNumber\n    ) external returns (uint256 forkId);\n\n    /// Creates a new fork with the given endpoint and at the block the given transaction was mined in,\n    /// replays all transaction mined in the block before the transaction, and returns the identifier of the fork.\n    function createFork(\n        string calldata urlOrAlias,\n        bytes32 txHash\n    ) external returns (uint256 forkId);\n\n    /// Creates and also selects a new fork with the given endpoint and the latest block and returns the identifier of the fork.\n    function createSelectFork(\n        string calldata urlOrAlias\n    ) external returns (uint256 forkId);\n\n    /// Creates and also selects a new fork with the given endpoint and block and returns the identifier of the fork.\n    function createSelectFork(\n        string calldata urlOrAlias,\n        uint256 blockNumber\n    ) external returns (uint256 forkId);\n\n    /// Creates and also selects new fork with the given endpoint and at the block the given transaction was mined in,\n    /// replays all transaction mined in the block before the transaction, returns the identifier of the fork.\n    function createSelectFork(\n        string calldata urlOrAlias,\n        bytes32 txHash\n    ) external returns (uint256 forkId);\n\n    /// Sets an address' balance.\n    function deal(address account, uint256 newBalance) external;\n\n    /// Removes the snapshot with the given ID created by `snapshot`.\n    /// Takes the snapshot ID to delete.\n    /// Returns `true` if the snapshot was successfully deleted.\n    /// Returns `false` if the snapshot does not exist.\n    function deleteStateSnapshot(\n        uint256 snapshotId\n    ) external returns (bool success);\n\n    /// Removes _all_ snapshots previously created by `snapshot`.\n    function deleteStateSnapshots() external;\n\n    /// Sets `block.difficulty`.\n    /// Not available on EVM versions from Paris onwards. Use `prevrandao` instead.\n    /// Reverts if used on unsupported EVM versions.\n    function difficulty(uint256 newDifficulty) external;\n\n    /// Dump a genesis JSON file's `allocs` to disk.\n    function dumpState(string calldata pathToStateJson) external;\n\n    /// Sets an address' code.\n    function etch(address target, bytes calldata newRuntimeBytecode) external;\n\n    /// Sets `block.basefee`.\n    function fee(uint256 newBasefee) external;\n\n    /// Gets the blockhashes from the current transaction.\n    /// Not available on EVM versions before Cancun.\n    /// If used on unsupported EVM versions it will revert.\n    function getBlobhashes() external view returns (bytes32[] memory hashes);\n\n    /// Returns true if the account is marked as persistent.\n    function isPersistent(\n        address account\n    ) external view returns (bool persistent);\n\n    /// Load a genesis JSON file's `allocs` into the in-memory EVM state.\n    function loadAllocs(string calldata pathToAllocsJson) external;\n\n    /// Marks that the account(s) should use persistent storage across fork swaps in a multifork setup\n    /// Meaning, changes made to the state of this account will be kept when switching forks.\n    function makePersistent(address account) external;\n\n    /// See `makePersistent(address)`.\n    function makePersistent(address account0, address account1) external;\n\n    /// See `makePersistent(address)`.\n    function makePersistent(\n        address account0,\n        address account1,\n        address account2\n    ) external;\n\n    /// See `makePersistent(address)`.\n    function makePersistent(address[] calldata accounts) external;\n\n    /// Reverts a call to an address with specified revert data.\n    function mockCallRevert(\n        address callee,\n        bytes calldata data,\n        bytes calldata revertData\n    ) external;\n\n    /// Reverts a call to an address with a specific `msg.value`, with specified revert data.\n    function mockCallRevert(\n        address callee,\n        uint256 msgValue,\n        bytes calldata data,\n        bytes calldata revertData\n    ) external;\n\n    /// Reverts a call to an address with specified revert data.\n    /// Overload to pass the function selector directly `token.approve.selector` instead of `abi.encodeWithSelector(token.approve.selector)`.\n    function mockCallRevert(\n        address callee,\n        bytes4 data,\n        bytes calldata revertData\n    ) external;\n\n    /// Reverts a call to an address with a specific `msg.value`, with specified revert data.\n    /// Overload to pass the function selector directly `token.approve.selector` instead of `abi.encodeWithSelector(token.approve.selector)`.\n    function mockCallRevert(\n        address callee,\n        uint256 msgValue,\n        bytes4 data,\n        bytes calldata revertData\n    ) external;\n\n    /// Mocks a call to an address, returning specified data.\n    /// Calldata can either be strict or a partial match, e.g. if you only\n    /// pass a Solidity selector to the expected calldata, then the entire Solidity\n    /// function will be mocked.\n    function mockCall(\n        address callee,\n        bytes calldata data,\n        bytes calldata returnData\n    ) external;\n\n    /// Mocks a call to an address with a specific `msg.value`, returning specified data.\n    /// Calldata match takes precedence over `msg.value` in case of ambiguity.\n    function mockCall(\n        address callee,\n        uint256 msgValue,\n        bytes calldata data,\n        bytes calldata returnData\n    ) external;\n\n    /// Mocks a call to an address, returning specified data.\n    /// Calldata can either be strict or a partial match, e.g. if you only\n    /// pass a Solidity selector to the expected calldata, then the entire Solidity\n    /// function will be mocked.\n    /// Overload to pass the function selector directly `token.approve.selector` instead of `abi.encodeWithSelector(token.approve.selector)`.\n    function mockCall(\n        address callee,\n        bytes4 data,\n        bytes calldata returnData\n    ) external;\n\n    /// Mocks a call to an address with a specific `msg.value`, returning specified data.\n    /// Calldata match takes precedence over `msg.value` in case of ambiguity.\n    /// Overload to pass the function selector directly `token.approve.selector` instead of `abi.encodeWithSelector(token.approve.selector)`.\n    function mockCall(\n        address callee,\n        uint256 msgValue,\n        bytes4 data,\n        bytes calldata returnData\n    ) external;\n\n    /// Mocks multiple calls to an address, returning specified data for each call.\n    function mockCalls(\n        address callee,\n        bytes calldata data,\n        bytes[] calldata returnData\n    ) external;\n\n    /// Mocks multiple calls to an address with a specific `msg.value`, returning specified data for each call.\n    function mockCalls(\n        address callee,\n        uint256 msgValue,\n        bytes calldata data,\n        bytes[] calldata returnData\n    ) external;\n\n    /// Whenever a call is made to `callee` with calldata `data`, this cheatcode instead calls\n    /// `target` with the same calldata. This functionality is similar to a delegate call made to\n    /// `target` contract from `callee`.\n    /// Can be used to substitute a call to a function with another implementation that captures\n    /// the primary logic of the original function but is easier to reason about.\n    /// If calldata is not a strict match then partial match by selector is attempted.\n    function mockFunction(\n        address callee,\n        address target,\n        bytes calldata data\n    ) external;\n\n    /// Utility cheatcode to remove any EIP-2930 access list set by `accessList` cheatcode.\n    function noAccessList() external;\n\n    /// Sets the *next* call's `msg.sender` to be the input address.\n    function prank(address msgSender) external;\n\n    /// Sets the *next* call's `msg.sender` to be the input address, and the `tx.origin` to be the second input.\n    function prank(address msgSender, address txOrigin) external;\n\n    /// Sets the *next* delegate call's `msg.sender` to be the input address.\n    function prank(address msgSender, bool delegateCall) external;\n\n    /// Sets the *next* delegate call's `msg.sender` to be the input address, and the `tx.origin` to be the second input.\n    function prank(\n        address msgSender,\n        address txOrigin,\n        bool delegateCall\n    ) external;\n\n    /// Sets `block.prevrandao`.\n    /// Not available on EVM versions before Paris. Use `difficulty` instead.\n    /// If used on unsupported EVM versions it will revert.\n    function prevrandao(bytes32 newPrevrandao) external;\n\n    /// Sets `block.prevrandao`.\n    /// Not available on EVM versions before Paris. Use `difficulty` instead.\n    /// If used on unsupported EVM versions it will revert.\n    function prevrandao(uint256 newPrevrandao) external;\n\n    /// Reads the current `msg.sender` and `tx.origin` from state and reports if there is any active caller modification.\n    function readCallers()\n        external\n        returns (CallerMode callerMode, address msgSender, address txOrigin);\n\n    /// Resets the nonce of an account to 0 for EOAs and 1 for contract accounts.\n    function resetNonce(address account) external;\n\n    /// Revert the state of the EVM to a previous snapshot\n    /// Takes the snapshot ID to revert to.\n    /// Returns `true` if the snapshot was successfully reverted.\n    /// Returns `false` if the snapshot does not exist.\n    /// **Note:** This does not automatically delete the snapshot. To delete the snapshot use `deleteStateSnapshot`.\n    function revertToState(uint256 snapshotId) external returns (bool success);\n\n    /// Revert the state of the EVM to a previous snapshot and automatically deletes the snapshots\n    /// Takes the snapshot ID to revert to.\n    /// Returns `true` if the snapshot was successfully reverted and deleted.\n    /// Returns `false` if the snapshot does not exist.\n    function revertToStateAndDelete(\n        uint256 snapshotId\n    ) external returns (bool success);\n\n    /// Revokes persistent status from the address, previously added via `makePersistent`.\n    function revokePersistent(address account) external;\n\n    /// See `revokePersistent(address)`.\n    function revokePersistent(address[] calldata accounts) external;\n\n    /// Sets `block.height`.\n    function roll(uint256 newHeight) external;\n\n    /// Updates the currently active fork to given block number\n    /// This is similar to `roll` but for the currently active fork.\n    function rollFork(uint256 blockNumber) external;\n\n    /// Updates the currently active fork to given transaction. This will `rollFork` with the number\n    /// of the block the transaction was mined in and replays all transaction mined before it in the block.\n    function rollFork(bytes32 txHash) external;\n\n    /// Updates the given fork to given block number.\n    function rollFork(uint256 forkId, uint256 blockNumber) external;\n\n    /// Updates the given fork to block number of the given transaction and replays all transaction mined before it in the block.\n    function rollFork(uint256 forkId, bytes32 txHash) external;\n\n    /// Takes a fork identifier created by `createFork` and sets the corresponding forked state as active.\n    function selectFork(uint256 forkId) external;\n\n    /// Set blockhash for the current block.\n    /// It only sets the blockhash for blocks where `block.number - 256 <= number < block.number`.\n    function setBlockhash(uint256 blockNumber, bytes32 blockHash) external;\n\n    /// Sets the nonce of an account. Must be higher than the current nonce of the account.\n    function setNonce(address account, uint64 newNonce) external;\n\n    /// Sets the nonce of an account to an arbitrary value.\n    function setNonceUnsafe(address account, uint64 newNonce) external;\n\n    /// Snapshot capture the gas usage of the last call by name from the callee perspective.\n    function snapshotGasLastCall(\n        string calldata name\n    ) external returns (uint256 gasUsed);\n\n    /// Snapshot capture the gas usage of the last call by name in a group from the callee perspective.\n    function snapshotGasLastCall(\n        string calldata group,\n        string calldata name\n    ) external returns (uint256 gasUsed);\n\n    /// Snapshot the current state of the evm.\n    /// Returns the ID of the snapshot that was created.\n    /// To revert a snapshot use `revertToState`.\n    function snapshotState() external returns (uint256 snapshotId);\n\n    /// Snapshot capture an arbitrary numerical value by name.\n    /// The group name is derived from the contract name.\n    function snapshotValue(string calldata name, uint256 value) external;\n\n    /// Snapshot capture an arbitrary numerical value by name in a group.\n    function snapshotValue(\n        string calldata group,\n        string calldata name,\n        uint256 value\n    ) external;\n\n    /// Sets all subsequent calls' `msg.sender` to be the input address until `stopPrank` is called.\n    function startPrank(address msgSender) external;\n\n    /// Sets all subsequent calls' `msg.sender` to be the input address until `stopPrank` is called, and the `tx.origin` to be the second input.\n    function startPrank(address msgSender, address txOrigin) external;\n\n    /// Sets all subsequent delegate calls' `msg.sender` to be the input address until `stopPrank` is called.\n    function startPrank(address msgSender, bool delegateCall) external;\n\n    /// Sets all subsequent delegate calls' `msg.sender` to be the input address until `stopPrank` is called, and the `tx.origin` to be the second input.\n    function startPrank(\n        address msgSender,\n        address txOrigin,\n        bool delegateCall\n    ) external;\n\n    /// Start a snapshot capture of the current gas usage by name.\n    /// The group name is derived from the contract name.\n    function startSnapshotGas(string calldata name) external;\n\n    /// Start a snapshot capture of the current gas usage by name in a group.\n    function startSnapshotGas(\n        string calldata group,\n        string calldata name\n    ) external;\n\n    /// Resets subsequent calls' `msg.sender` to be `address(this)`.\n    function stopPrank() external;\n\n    /// Stop the snapshot capture of the current gas by latest snapshot name, capturing the gas used since the start.\n    function stopSnapshotGas() external returns (uint256 gasUsed);\n\n    /// Stop the snapshot capture of the current gas usage by name, capturing the gas used since the start.\n    /// The group name is derived from the contract name.\n    function stopSnapshotGas(\n        string calldata name\n    ) external returns (uint256 gasUsed);\n\n    /// Stop the snapshot capture of the current gas usage by name in a group, capturing the gas used since the start.\n    function stopSnapshotGas(\n        string calldata group,\n        string calldata name\n    ) external returns (uint256 gasUsed);\n\n    /// Stores a value to an address' storage slot.\n    function store(address target, bytes32 slot, bytes32 value) external;\n\n    /// Fetches the given transaction from the active fork and executes it on the current state.\n    function transact(bytes32 txHash) external;\n\n    /// Fetches the given transaction from the given fork and executes it on the current state.\n    function transact(uint256 forkId, bytes32 txHash) external;\n\n    /// Sets `tx.gasprice`.\n    function txGasPrice(uint256 newGasPrice) external;\n\n    /// Utility cheatcode to mark specific storage slot as warm, simulating a prior read.\n    function warmSlot(address target, bytes32 slot) external;\n\n    /// Sets `block.timestamp`.\n    function warp(uint256 newTimestamp) external;\n\n    /// `deleteSnapshot` is being deprecated in favor of `deleteStateSnapshot`. It will be removed in future versions.\n    function deleteSnapshot(uint256 snapshotId) external returns (bool success);\n\n    /// `deleteSnapshots` is being deprecated in favor of `deleteStateSnapshots`. It will be removed in future versions.\n    function deleteSnapshots() external;\n\n    /// `revertToAndDelete` is being deprecated in favor of `revertToStateAndDelete`. It will be removed in future versions.\n    function revertToAndDelete(\n        uint256 snapshotId\n    ) external returns (bool success);\n\n    /// `revertTo` is being deprecated in favor of `revertToState`. It will be removed in future versions.\n    function revertTo(uint256 snapshotId) external returns (bool success);\n\n    /// `snapshot` is being deprecated in favor of `snapshotState`. It will be removed in future versions.\n    function snapshot() external returns (uint256 snapshotId);\n\n    // ======== Testing ========\n\n    /// Expect a call to an address with the specified `msg.value` and calldata, and a *minimum* amount of gas.\n    function expectCallMinGas(\n        address callee,\n        uint256 msgValue,\n        uint64 minGas,\n        bytes calldata data\n    ) external;\n\n    /// Expect given number of calls to an address with the specified `msg.value` and calldata, and a *minimum* amount of gas.\n    function expectCallMinGas(\n        address callee,\n        uint256 msgValue,\n        uint64 minGas,\n        bytes calldata data,\n        uint64 count\n    ) external;\n\n    /// Expects a call to an address with the specified calldata.\n    /// Calldata can either be a strict or a partial match.\n    function expectCall(address callee, bytes calldata data) external;\n\n    /// Expects given number of calls to an address with the specified calldata.\n    function expectCall(\n        address callee,\n        bytes calldata data,\n        uint64 count\n    ) external;\n\n    /// Expects a call to an address with the specified `msg.value` and calldata.\n    function expectCall(\n        address callee,\n        uint256 msgValue,\n        bytes calldata data\n    ) external;\n\n    /// Expects given number of calls to an address with the specified `msg.value` and calldata.\n    function expectCall(\n        address callee,\n        uint256 msgValue,\n        bytes calldata data,\n        uint64 count\n    ) external;\n\n    /// Expect a call to an address with the specified `msg.value`, gas, and calldata.\n    function expectCall(\n        address callee,\n        uint256 msgValue,\n        uint64 gas,\n        bytes calldata data\n    ) external;\n\n    /// Expects given number of calls to an address with the specified `msg.value`, gas, and calldata.\n    function expectCall(\n        address callee,\n        uint256 msgValue,\n        uint64 gas,\n        bytes calldata data,\n        uint64 count\n    ) external;\n\n    /// Expects the deployment of the specified bytecode by the specified address using the CREATE opcode\n    function expectCreate(bytes calldata bytecode, address deployer) external;\n\n    /// Expects the deployment of the specified bytecode by the specified address using the CREATE2 opcode\n    function expectCreate2(bytes calldata bytecode, address deployer) external;\n\n    /// Prepare an expected anonymous log with (bool checkTopic1, bool checkTopic2, bool checkTopic3, bool checkData.).\n    /// Call this function, then emit an anonymous event, then call a function. Internally after the call, we check if\n    /// logs were emitted in the expected order with the expected topics and data (as specified by the booleans).\n    function expectEmitAnonymous(\n        bool checkTopic0,\n        bool checkTopic1,\n        bool checkTopic2,\n        bool checkTopic3,\n        bool checkData\n    ) external;\n\n    /// Same as the previous method, but also checks supplied address against emitting contract.\n    function expectEmitAnonymous(\n        bool checkTopic0,\n        bool checkTopic1,\n        bool checkTopic2,\n        bool checkTopic3,\n        bool checkData,\n        address emitter\n    ) external;\n\n    /// Prepare an expected anonymous log with all topic and data checks enabled.\n    /// Call this function, then emit an anonymous event, then call a function. Internally after the call, we check if\n    /// logs were emitted in the expected order with the expected topics and data.\n    function expectEmitAnonymous() external;\n\n    /// Same as the previous method, but also checks supplied address against emitting contract.\n    function expectEmitAnonymous(address emitter) external;\n\n    /// Prepare an expected log with (bool checkTopic1, bool checkTopic2, bool checkTopic3, bool checkData.).\n    /// Call this function, then emit an event, then call a function. Internally after the call, we check if\n    /// logs were emitted in the expected order with the expected topics and data (as specified by the booleans).\n    function expectEmit(\n        bool checkTopic1,\n        bool checkTopic2,\n        bool checkTopic3,\n        bool checkData\n    ) external;\n\n    /// Same as the previous method, but also checks supplied address against emitting contract.\n    function expectEmit(\n        bool checkTopic1,\n        bool checkTopic2,\n        bool checkTopic3,\n        bool checkData,\n        address emitter\n    ) external;\n\n    /// Prepare an expected log with all topic and data checks enabled.\n    /// Call this function, then emit an event, then call a function. Internally after the call, we check if\n    /// logs were emitted in the expected order with the expected topics and data.\n    function expectEmit() external;\n\n    /// Same as the previous method, but also checks supplied address against emitting contract.\n    function expectEmit(address emitter) external;\n\n    /// Expect a given number of logs with the provided topics.\n    function expectEmit(\n        bool checkTopic1,\n        bool checkTopic2,\n        bool checkTopic3,\n        bool checkData,\n        uint64 count\n    ) external;\n\n    /// Expect a given number of logs from a specific emitter with the provided topics.\n    function expectEmit(\n        bool checkTopic1,\n        bool checkTopic2,\n        bool checkTopic3,\n        bool checkData,\n        address emitter,\n        uint64 count\n    ) external;\n\n    /// Expect a given number of logs with all topic and data checks enabled.\n    function expectEmit(uint64 count) external;\n\n    /// Expect a given number of logs from a specific emitter with all topic and data checks enabled.\n    function expectEmit(address emitter, uint64 count) external;\n\n    /// Expects an error on next call that starts with the revert data.\n    function expectPartialRevert(bytes4 revertData) external;\n\n    /// Expects an error on next call to reverter address, that starts with the revert data.\n    function expectPartialRevert(bytes4 revertData, address reverter) external;\n\n    /// Expects an error on next call with any revert data.\n    function expectRevert() external;\n\n    /// Expects an error on next call that exactly matches the revert data.\n    function expectRevert(bytes4 revertData) external;\n\n    /// Expects a `count` number of reverts from the upcoming calls from the reverter address that match the revert data.\n    function expectRevert(\n        bytes4 revertData,\n        address reverter,\n        uint64 count\n    ) external;\n\n    /// Expects a `count` number of reverts from the upcoming calls from the reverter address that exactly match the revert data.\n    function expectRevert(\n        bytes calldata revertData,\n        address reverter,\n        uint64 count\n    ) external;\n\n    /// Expects an error on next call that exactly matches the revert data.\n    function expectRevert(bytes calldata revertData) external;\n\n    /// Expects an error with any revert data on next call to reverter address.\n    function expectRevert(address reverter) external;\n\n    /// Expects an error from reverter address on next call, with any revert data.\n    function expectRevert(bytes4 revertData, address reverter) external;\n\n    /// Expects an error from reverter address on next call, that exactly matches the revert data.\n    function expectRevert(bytes calldata revertData, address reverter) external;\n\n    /// Expects a `count` number of reverts from the upcoming calls with any revert data or reverter.\n    function expectRevert(uint64 count) external;\n\n    /// Expects a `count` number of reverts from the upcoming calls that match the revert data.\n    function expectRevert(bytes4 revertData, uint64 count) external;\n\n    /// Expects a `count` number of reverts from the upcoming calls that exactly match the revert data.\n    function expectRevert(bytes calldata revertData, uint64 count) external;\n\n    /// Expects a `count` number of reverts from the upcoming calls from the reverter address.\n    function expectRevert(address reverter, uint64 count) external;\n\n    /// Only allows memory writes to offsets [0x00, 0x60) ∪ [min, max) in the current subcontext. If any other\n    /// memory is written to, the test will fail. Can be called multiple times to add more ranges to the set.\n    function expectSafeMemory(uint64 min, uint64 max) external;\n\n    /// Only allows memory writes to offsets [0x00, 0x60) ∪ [min, max) in the next created subcontext.\n    /// If any other memory is written to, the test will fail. Can be called multiple times to add more ranges\n    /// to the set.\n    function expectSafeMemoryCall(uint64 min, uint64 max) external;\n\n    /// Marks a test as skipped. Must be called at the top level of a test.\n    function skip(bool skipTest) external;\n\n    /// Marks a test as skipped with a reason. Must be called at the top level of a test.\n    function skip(bool skipTest, string calldata reason) external;\n\n    /// Stops all safe memory expectation in the current subcontext.\n    function stopExpectSafeMemory() external;\n}\n"
      },
      "project/contracts/evm/GigaBridge.sol": {
        "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.29;\n\nimport {IGigaBridge} from \"./interfaces/IGigaBridge.sol\";\nimport {IGigaRootProvider, ILocalRootRecipient, ILocalRootProvider, IGigaRootRecipient} from \"./interfaces/IRootMessengers.sol\";\nimport {PoseidonT3} from \"poseidon-solidity/PoseidonT3.sol\";\nimport {LazyIMT, LazyIMTData} from \"@zk-kit/lazy-imt.sol/LazyIMT.sol\";\n\ncontract GigaBridge is IGigaBridge, ILocalRootRecipient, IGigaRootProvider  {\n    // get gigaRootFrom destination chain. look up at which block that got created at with: ConstructedNewGigaRoot(gigaRoot)\n    // get all leaves of giga tree by scanning for all indexes with ReceivedNewLocalRoot. Start at the block number found above ^\n    // get allIndexes you need by looking at amountOfLocalRoots\n    // work ur way down until you found all indexes.\n\n    uint256 public gigaRoot; // keep this here pls so it's alway at slot 0 for L1SLOAD on scroll\n\n    LazyIMTData public rootTreeData; // does this need to be public? yes? maybe we can sync clients faster somehow?\n    uint8 public maxTreeDepth;\n\n    mapping(address => uint40) private localRootProvidersIndexes; // getters are public btw\n    mapping(address => uint256) public localRootBlockNumbers; // current blocknumber per root. History is in events. We need this to check that incoming roots are not older than current\n    uint256 public amountOfLocalRoots;\n\n    event SentGigaRoot(uint256 indexed gigaRoot);\n\n    /**\n     * @notice Initialize the root bridge\n     * @param _gigaRootRecipients - the L1 contracts that can receive roots from corresponding locals\n     */\n    constructor(address[] memory _gigaRootRecipients, uint8 _maxTreeDepth) {\n        maxTreeDepth = _maxTreeDepth;\n        // init doesn't add any leaves. But the leaves are all 0 by default!\n        LazyIMT.init(rootTreeData, _maxTreeDepth);\n\n        // for each L1LocalRootProvider...\n        for (uint40 i = 0; i < _gigaRootRecipients.length; i++) {\n            _setLocalRootProvidersIndex(_gigaRootRecipients[i], i);\n            LazyIMT.insert(rootTreeData,0); // TODO this is kind of expensive way to get around the error from `lazyIMT.update`: `leaf must exist`\n        }\n        amountOfLocalRoots = _gigaRootRecipients.length; \n\n        // other wise gigaRoot can be 0. Which i cant see how that would be a issue but it scares so we do this to be safe\n        gigaRoot = LazyIMT.root(rootTreeData, maxTreeDepth);\n    }\n\n    function _setLocalRootProvidersIndex(address _localRootProvider, uint40 index) private {\n        localRootProvidersIndexes[_localRootProvider] = index + 1; //+1 because a mapping defaults to 0. so those don't exist!\n    }\n\n    function getLocalRootProvidersIndex(address _localRootProvider) public view returns(uint40) {\n        return localRootProvidersIndexes[_localRootProvider] - 1; //-1 because a mapping defaults to 0. so those don't exist!\n    }\n\n    function isLocalRootProviders(address _localRootProvider) public view returns(bool) {\n        return localRootProvidersIndexes[_localRootProvider] > 0;\n    }\n\n    /**\n     * @notice updates the current gigaRoot by querying for updates from the supplied\n     * list of local root providers.  You can pull updates from a subset of local root providers for gas saving (don't have to update to all local root providers).\n     */\n    function updateGigaRoot(address[] memory _localRootProvider) external {\n        // for each localRootProviders\n        for (uint40 i = 0; i < _localRootProvider.length; i++) {\n            address localRootProvider = _localRootProvider[i];\n\n            // get the index of this localRootProvider (used in updatedLocalRootBlockNumbers and rootTreeData)\n            uint40 localRootIndex = getLocalRootProvidersIndex(localRootProvider);\n\n            // make sure this bridgeAdapterAddress was initialized\n            require(\n                isLocalRootProviders(localRootProvider),\n                \"Address is not a registered root bridge address\"\n            );\n\n            // get the most recent l2 root and the l2 block number it came from from this bridge\n            (uint256 newLocalRoot, uint256 localRootBlockNumber) = ILocalRootProvider(localRootProvider).getLocalRootAndBlock();\n\n            require(localRootBlockNumber >= localRootBlockNumbers[localRootProvider], \"localRoot has to be newer or the same\"); \n            localRootBlockNumbers[localRootProvider] = localRootBlockNumber;\n\n            LazyIMT.update(rootTreeData, newLocalRoot, localRootIndex);\n            //TODO can we emit 33 events?\n            emit ReceivedNewLocalRoot(\n                newLocalRoot,\n                localRootIndex,\n                localRootBlockNumber\n            );\n        }\n        // compute new giga root\n        uint256 newGigaRoot = LazyIMT.root(rootTreeData, maxTreeDepth);\n        emit ConstructedNewGigaRoot(newGigaRoot);\n\n        // set new gigaRoot in contract\n        gigaRoot = newGigaRoot;\n    }   \n\n    // TODO this is very convenient to initiated all bridging txs at once but the problem is that every bridge is different\n    // so the might require different parameter handed to them by a eoa like scrolls bridge needs a extra gaslimit\n    // so we should pull from the gigaRoot from the L1Adapter instead\n\n    // Made this a second function because the addresses that want the gigaRoot\n    // might be different from the addresses that are updating their localRoot.\n    // since most of the time everyone wants the latest gigaRoot but not everyone has a localRoot that is new\n    // Sends the most recent gigaRoot to an array of localRootProviders\n    function sendGigaRoot(address[] memory _gigaRootRecipients, uint256[] memory _amounts) public payable {\n        uint256 _gigaRoot = gigaRoot;\n        emit SentGigaRoot(_gigaRoot);\n        for (uint256 i = 0; i < _gigaRootRecipients.length; i++) {\n            address gigaRootRecipient = _gigaRootRecipients[i];\n\n            // send the most recent gigaRoot to this LocalRootProvider address. \n            // They provide local roots but also like something back. A gigaRoot :0!!!\n           IGigaRootRecipient(gigaRootRecipient).receiveGigaRoot{value: _amounts[i]}(_gigaRoot);\n        }\n    }\n\n\n    // above function is more efficient most of the time. This is here to support the IGigaRootProvider \n    // and IGigaRootProvider doesn't do the for loop because L2 adapters only have one recipient (L2Warptoad).\n    function sendGigaRoot(address _gigaRootRecipient) public payable{\n        uint256 _gigaRoot = gigaRoot;\n        emit SentGigaRoot(_gigaRoot);\n        IGigaRootRecipient(_gigaRootRecipient).receiveGigaRoot{value: msg.value}(_gigaRoot);\n    }\n\n    // // for scroll who needs eth to make the bridge tx\n    // // this is kinda getting messy. Next version of gigaBridge should instead only receive leafValues and have a public getter for gigaRoot (history)\n    // // then the adapters can handle all these whacky different bridge apis. \n    // // for loops are also bad in gigaBridge, since it forces gigaBridge to know what the bridge api is like before hand. Instead we should just do multi-call or whatever\n    // function sendGigaRootPayable(address _gigaRootRecipient) public payable {\n    //     IGigaRootRecipient(_gigaRootRecipient).receiveGigaRoot{value: msg.value}(gigaRoot);\n    // }\n}\n"
      },
      "project/contracts/evm/interfaces/IGigaBridge.sol": {
        "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.29;\n\n// TODO public state vars?\ninterface IGigaBridge {\n    event ConstructedNewGigaRoot(\n        uint256 indexed newGigaRoot\n    ); \n    \n    event ReceivedNewLocalRoot(\n        uint256 indexed newLocalRoot,\n        uint40 indexed localRootIndex, \n        uint256 localRootBlockNumber\n    );\n\n    function getLocalRootProvidersIndex(address _localRootProvider) external view returns(uint40);\n\n    function isLocalRootProviders(address _localRootProvider) external view returns(bool);\n\n    function updateGigaRoot(address[] memory _localRootProvider) external;\n\n    // Made this a second function because the addresses that want the gigaRoot\n    // might be different from the addresses that are updating their localRoot.\n    // since most of the time everyone wants the latest gigaRoot but not everyone has a localRoot that is new\n    // Sends the most recent gigaRoot to an array of localRootProviders\n    function sendGigaRoot(address[] memory _gigaRootRecipients, uint256[] memory _amounts) payable external;\n\n}"
      },
      "project/contracts/evm/interfaces/IL1BridgeAdapter.sol": {
        "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.29;\n\ninterface IL1BridgeAdapter {\n\n    // gigaRoot is emitted as a bytes32 here because thats how it's recovered on the\n    //  L2 side of this rootBridgeAdapter.  Key and index are also used to\n    // retrieve this newGigaRoot on L2\n    event ReceivedNewL2Root(uint256 indexed newL2Root, uint256 l2Block);\n\n    // /**\n    //  * @notice adds an L2 message which can only be consumed publicly on L1\n    //  * @param _newGigaRoot - The new gigaRoot to send to L2 as a message\n    //  */\n    // function receiveGigaRoot(\n    //     uint256 _newGigaRoot\n    // ) external;\n\n    // function getLocalRootAndBlock() view external returns (uint256, uint256);\n}\n"
      },
      "project/contracts/evm/interfaces/IL2BridgeAdapter.sol": {
        "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.29;\n\ninterface IL2BridgeAdapter {\n    //TODO\n    \n    // gigaRoot is emitted as a bytes32 here because thats how it's recovered on the\n    //  L2 side of this rootBridgeAdapter.  Key and index are also used to\n    // retrieve this newGigaRoot on L2\n    //event ReceivedNewL2Root(uint256 newL2Root, uint256 l2Block);\n\n}"
      },
      "project/contracts/evm/interfaces/IRootMessengers.sol": {
        "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.29;\n\ninterface IGigaRootProvider {\n    function sendGigaRoot(address _gigaRootRecipient) external payable;\n    function gigaRoot() external returns(uint256);\n}\n\ninterface IGigaRootRecipient {\n    function receiveGigaRoot(uint256 _gigaRoot) payable external;\n    //function receiveGigaRoot(uint256 _gigaRoot, uint256 _gasLimit) payable external;\n}\n\n\ninterface ILocalRootProvider {\n    function getLocalRootAndBlock() external returns (uint256, uint256);\n}\n\ninterface ILocalRootRecipient {\n    //only gigaBridge does this\n    //function updateGigaRoot(address[] memory _localRootProvider) external;\n}\n"
      },
      "project/contracts/evm/interfaces/IWarpToadCore.sol": {
        "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.29;\n\n\ninterface IWarpToadCore {\n    event Burn(uint256 indexed commitment, uint256 amount, uint256 index);\n    function initialize(address _gigaRootProvider, address _l1BridgeAdapter) external;\n    function isValidGigaRoot(uint256 _gigaRoot) external view returns (bool);\n    function burn(uint256 _preCommitment, uint256 _amount) external;\n\n    // our tree is lazy so we \n    function storeLocalRootInHistory() external returns(uint256);\n\n    function _formatPublicInputs(        \n        uint256 _nullifier,\n        uint256 _chainId,\n        uint256 _amount,\n        uint256 _gigaRoot,\n        uint256 _localRoot,\n        uint256 _feeFactor,\n        uint256 _priorityFee,\n        uint256 _maxFee,\n        address _relayer,\n        address _recipient\n    ) external pure returns (bytes32[] memory);\n\n\n    // TODO relayer support\n    function mint(\n        uint256 _nullifier,\n        uint256 _amount,\n        uint256 _gigaRoot,\n        uint256 _localRoot,\n        uint256 _feeFactor,\n        uint256 _priorityFee,\n        uint256 _maxFee,\n        address _relayer,\n        address _recipient,\n        bytes memory _poof\n    ) external;\n\n    function localRoot() external view returns (uint256);\n    function isValidLocalRoot(uint256 _localRoot) external view returns (bool);\n\n    // gigaRootProvider can call directly since are on the L1 already and don't need adapter\n    // IGigaRootRecipient and ILocalRootProvider\n//     function receiveGigaRoot(uint256 _gigaRoot) external;\n//     function getLocalRootAndBlock() external returns (uint256, uint256);\n}"
      },
      "project/contracts/evm/test/ERC206Dec.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.3.0) (token/ERC20/ERC20.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {IERC20Metadata} from \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport {Context} from \"@openzeppelin/contracts/utils/Context.sol\";\nimport {IERC20Errors} from \"@openzeppelin/contracts/interfaces/draft-IERC6093.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.openzeppelin.com/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * The default value of {decimals} is 18. To change this, you should override\n * this function so it returns a different value.\n *\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\n * instead returning `false` on failure. This behavior is nonetheless\n * conventional and does not conflict with the expectations of ERC-20\n * applications.\n */\nabstract contract ERC20 is Context, IERC20, IERC20Metadata, IERC20Errors {\n    mapping(address account => uint256) private _balances;\n\n    mapping(address account => mapping(address spender => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}.\n     *\n     * Both values are immutable: they can only be set once during construction.\n     */\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the default value returned by this function, unless\n     * it's overridden.\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual returns (uint8) {\n        return 6;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view virtual returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - the caller must have a balance of at least `value`.\n     */\n    function transfer(address to, uint256 value) public virtual returns (bool) {\n        address owner = _msgSender();\n        _transfer(owner, to, value);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * NOTE: If `value` is the maximum `uint256`, the allowance is not updated on\n     * `transferFrom`. This is semantically equivalent to an infinite approval.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 value) public virtual returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, value);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Skips emitting an {Approval} event indicating an allowance update. This is not\n     * required by the ERC. See {xref-ERC20-_approve-address-address-uint256-bool-}[_approve].\n     *\n     * NOTE: Does not update the allowance if the current allowance\n     * is the maximum `uint256`.\n     *\n     * Requirements:\n     *\n     * - `from` and `to` cannot be the zero address.\n     * - `from` must have a balance of at least `value`.\n     * - the caller must have allowance for ``from``'s tokens of at least\n     * `value`.\n     */\n    function transferFrom(address from, address to, uint256 value) public virtual returns (bool) {\n        address spender = _msgSender();\n        _spendAllowance(from, spender, value);\n        _transfer(from, to, value);\n        return true;\n    }\n\n    /**\n     * @dev Moves a `value` amount of tokens from `from` to `to`.\n     *\n     * This internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * NOTE: This function is not virtual, {_update} should be overridden instead.\n     */\n    function _transfer(address from, address to, uint256 value) internal {\n        if (from == address(0)) {\n            revert ERC20InvalidSender(address(0));\n        }\n        if (to == address(0)) {\n            revert ERC20InvalidReceiver(address(0));\n        }\n        _update(from, to, value);\n    }\n\n    /**\n     * @dev Transfers a `value` amount of tokens from `from` to `to`, or alternatively mints (or burns) if `from`\n     * (or `to`) is the zero address. All customizations to transfers, mints, and burns should be done by overriding\n     * this function.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _update(address from, address to, uint256 value) internal virtual {\n        if (from == address(0)) {\n            // Overflow check required: The rest of the code assumes that totalSupply never overflows\n            _totalSupply += value;\n        } else {\n            uint256 fromBalance = _balances[from];\n            if (fromBalance < value) {\n                revert ERC20InsufficientBalance(from, fromBalance, value);\n            }\n            unchecked {\n                // Overflow not possible: value <= fromBalance <= totalSupply.\n                _balances[from] = fromBalance - value;\n            }\n        }\n\n        if (to == address(0)) {\n            unchecked {\n                // Overflow not possible: value <= totalSupply or value <= fromBalance <= totalSupply.\n                _totalSupply -= value;\n            }\n        } else {\n            unchecked {\n                // Overflow not possible: balance + value is at most totalSupply, which we know fits into a uint256.\n                _balances[to] += value;\n            }\n        }\n\n        emit Transfer(from, to, value);\n    }\n\n    /**\n     * @dev Creates a `value` amount of tokens and assigns them to `account`, by transferring it from address(0).\n     * Relies on the `_update` mechanism\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * NOTE: This function is not virtual, {_update} should be overridden instead.\n     */\n    function _mint(address account, uint256 value) internal {\n        if (account == address(0)) {\n            revert ERC20InvalidReceiver(address(0));\n        }\n        _update(address(0), account, value);\n    }\n\n    /**\n     * @dev Destroys a `value` amount of tokens from `account`, lowering the total supply.\n     * Relies on the `_update` mechanism.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * NOTE: This function is not virtual, {_update} should be overridden instead\n     */\n    function _burn(address account, uint256 value) internal {\n        if (account == address(0)) {\n            revert ERC20InvalidSender(address(0));\n        }\n        _update(account, address(0), value);\n    }\n\n    /**\n     * @dev Sets `value` as the allowance of `spender` over the `owner`'s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     *\n     * Overrides to this logic should be done to the variant with an additional `bool emitEvent` argument.\n     */\n    function _approve(address owner, address spender, uint256 value) internal {\n        _approve(owner, spender, value, true);\n    }\n\n    /**\n     * @dev Variant of {_approve} with an optional flag to enable or disable the {Approval} event.\n     *\n     * By default (when calling {_approve}) the flag is set to true. On the other hand, approval changes made by\n     * `_spendAllowance` during the `transferFrom` operation set the flag to false. This saves gas by not emitting any\n     * `Approval` event during `transferFrom` operations.\n     *\n     * Anyone who wishes to continue emitting `Approval` events on the`transferFrom` operation can force the flag to\n     * true using the following override:\n     *\n     * ```solidity\n     * function _approve(address owner, address spender, uint256 value, bool) internal virtual override {\n     *     super._approve(owner, spender, value, true);\n     * }\n     * ```\n     *\n     * Requirements are the same as {_approve}.\n     */\n    function _approve(address owner, address spender, uint256 value, bool emitEvent) internal virtual {\n        if (owner == address(0)) {\n            revert ERC20InvalidApprover(address(0));\n        }\n        if (spender == address(0)) {\n            revert ERC20InvalidSpender(address(0));\n        }\n        _allowances[owner][spender] = value;\n        if (emitEvent) {\n            emit Approval(owner, spender, value);\n        }\n    }\n\n    /**\n     * @dev Updates `owner`'s allowance for `spender` based on spent `value`.\n     *\n     * Does not update the allowance value in case of infinite allowance.\n     * Revert if not enough allowance is available.\n     *\n     * Does not emit an {Approval} event.\n     */\n    function _spendAllowance(address owner, address spender, uint256 value) internal virtual {\n        uint256 currentAllowance = allowance(owner, spender);\n        if (currentAllowance < type(uint256).max) {\n            if (currentAllowance < value) {\n                revert ERC20InsufficientAllowance(spender, currentAllowance, value);\n            }\n            unchecked {\n                _approve(owner, spender, currentAllowance - value, false);\n            }\n        }\n    }\n}\n"
      },
      "project/contracts/evm/test/USDcoin.sol": {
        "content": "// SPDX-License-Identifier: MIT \n\npragma solidity ^0.8.29;\n\nimport {ERC20} from \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\n\ncontract USDcoin is ERC20 {\n    constructor() ERC20(\"USD Coin\", \"USDC\") {}\n\n    function getFreeShit(uint256 _amount) public {\n        _mint( msg.sender, _amount);\n    }\n\n    function decimals() public view virtual override returns (uint8) {\n        return 6;\n    }\n}\n"
      },
      "project/contracts/evm/warptoad/L1WarpToad.sol": {
        "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.29;\n\nimport {WarpToadCore} from \"./WarpToadCore.sol\";\nimport {ERC20} from \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\ncontract L1WarpToad is WarpToadCore {\n    constructor(uint8 _maxTreeDepth, address _withdrawVerifier, address _nativeToken, string memory name, string memory symbol) \n    ERC20(name, symbol) \n    WarpToadCore(_maxTreeDepth, _withdrawVerifier, _nativeToken)  {\n    }\n\n    function wrap(uint256 _amount) public {\n        IERC20(nativeToken).transferFrom(msg.sender, address(this), _amount);\n        _mint(msg.sender, _amount);\n        // TODO event?\n    }\n\n    function unwrap(uint256 _amount) public {\n        IERC20(nativeToken).transfer(msg.sender, _amount);\n        _burn(address(this), _amount);\n        // TODO event?\n    }\n}"
      },
      "project/contracts/evm/warptoad/L2WarpToad.sol": {
        "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.29;\n\nimport {WarpToadCore} from \"./WarpToadCore.sol\";\nimport {ERC20} from \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\n\ncontract L2WarpToad is WarpToadCore {\n    //@joss do what ever to the structure or naming or things if u feel like it\n    constructor(\n        uint8 _maxTreeDepth,\n        address _withdrawVerifier,\n        address _nativeToken,\n        string memory name,\n        string memory symbol\n    ) ERC20(name, symbol) WarpToadCore(_maxTreeDepth, _withdrawVerifier, _nativeToken) {}\n\n    function bridgeRoot() public view {\n        localRoot(); // <- returns the localRoot!\n        //TODO interact with the gigaBridge\n    }\n}\n"
      },
      "project/contracts/evm/warptoad/WarpToadCore.sol": {
        "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.29;\n\nimport {PoseidonT3} from \"poseidon-solidity/PoseidonT3.sol\";\n//import {LazyIMT, LazyIMTData} from \"@zk-kit/lazy-imt.sol/LazyIMT.sol\";\nimport {LazyIMT, LazyIMTData}from \"../../LazyIMT.sol\";\nimport {ERC20} from \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {IWarpToadCore} from \"../interfaces/IWarpToadCore.sol\";\nimport {ILocalRootProvider, IGigaRootRecipient} from \"../interfaces/IRootMessengers.sol\";\n\n// tutorial https://github.com/privacy-scaling-explorations/zk-kit.solidity/blob/main/packages/lean-imt/contracts/test/LazyIMTTest.sol\n// noir equivalent (normal merkle tree): https://github.com/privacy-scaling-explorations/zk-kit.noir/tree/main/packages/merkle-trees\n// ts/js: https://github.com/privacy-scaling-explorations/zk-kit/tree/main/packages/lean-imt\n\ninterface IVerifier {\n    function verify(\n        bytes calldata _proof,\n        bytes32[] calldata _publicInputs\n    ) external view returns (bool);\n}\n\nabstract contract WarpToadCore is ERC20, IWarpToadCore,ILocalRootProvider, IGigaRootRecipient {\n    modifier onlyGigaRootProvider() {\n        require(msg.sender == gigaRootProvider, \"Not gigaRootProvider\");\n        _; // what is that?\n    }\n\n    modifier onlyDeployer() {\n        require(msg.sender == deployer, \"Not the deployer\");\n        _; // what is that?\n    }\n    \n    address deployer;\n\n    LazyIMTData public commitTreeData; // does this need to be public?\n    uint8 public maxTreeDepth;\n\n    uint256 public cachedLocalRoot;\n    uint256 public gigaRoot;\n    mapping(uint256 => bool) public gigaRootHistory; // TODO limit the history so we override slots is more efficient and is easier for clients to implement contract interactions\n    mapping(uint256 => bool) public localRootHistory; \n\n    address public l1BridgeAdapter;  // just here so we can look it up in frontend (l1BridgeAdapter is the address that maps to leaves(localRoots) in the gigaTree)\n    address public gigaRootProvider; // only contract that is allowed to provide giga roots\n    address public withdrawVerifier;\n\n    uint256 public lastLeafIndex;\n\n    address public nativeToken;\n\n    constructor(uint8 _maxTreeDepth, address _withdrawVerifier, address _nativeToken) {\n        maxTreeDepth = _maxTreeDepth;\n        // maxBurns = 2 ** _maxTreeDepth; // circuit cant go above this number\n\n        withdrawVerifier = _withdrawVerifier;\n        LazyIMT.init(commitTreeData, _maxTreeDepth);\n        nativeToken = _nativeToken;\n        deployer = msg.sender;\n\n        // other wise cachedLocalRoot can be 0. Which i cant see how that would be a issue but it scares so we do this to be safe\n        storeLocalRootInHistory();\n    }\n\n    // needs initialize because the gigaBridge sets its localRootProvider (inc L1WarpToad) in the constructor\n    // \n    function initialize(address _gigaRootProvider, address _l1BridgeAdapter) public onlyDeployer() {\n        require(gigaRootProvider == address(0), \"gigaRootProvider is already set\");\n        require(l1BridgeAdapter == address(0), \"l1BridgeAdapter is already set\");\n        gigaRootProvider = _gigaRootProvider;\n        l1BridgeAdapter = _l1BridgeAdapter;\n    }\n\n    function decimals() public view virtual override returns (uint8) {\n        return 6;\n    }\n\n    function isValidGigaRoot(uint256 _gigaRoot) public view returns (bool) {\n        return gigaRootHistory[_gigaRoot];\n    }\n\n    function burn(uint256 _preCommitment, uint256 _amount) public {\n        //require(totalBurns < maxBurns, \"Tree wil exceed the maxTreeDepth\");\n\n        _burn(msg.sender, _amount);\n\n        uint256 _commitment = PoseidonT3.hash([_preCommitment, _amount]);\n        LazyIMT.insert(commitTreeData, _commitment);\n        emit Burn(_commitment, _amount, lastLeafIndex);\n        lastLeafIndex++;\n    }\n\n    // our tree is lazy so we \n    function storeLocalRootInHistory() public returns(uint256) {\n        uint256 root = localRoot();\n        cachedLocalRoot = root;\n        localRootHistory[root] = true;\n        return root;\n    }\n\n    function _formatPublicInputs(        \n        uint256 _nullifier,\n        uint256 _chainId,\n        uint256 _amount,\n        uint256 _gigaRoot,\n        uint256 _localRoot,\n        uint256 _feeFactor,\n        uint256 _priorityFee,\n        uint256 _maxFee,\n        address _relayer,\n        address _recipient\n    ) public pure returns (bytes32[] memory) {\n        bytes32[] memory publicInputs = new bytes32[](10);\n        // TODO is this expensive gas wise?\n        uint256[8] memory uintInputs = [_nullifier,_chainId,_amount,_gigaRoot,_localRoot,_feeFactor,_priorityFee,_maxFee];\n        address[2] memory addressInputs = [_relayer, _recipient];\n        \n        for (uint i = 0; i < uintInputs.length; i++) {\n            publicInputs[i] = bytes32(uintInputs[i]);\n        }\n        uint256 indexAfterUints = uintInputs.length; \n        for (uint i = 0; i < 2; i++) {\n            publicInputs[indexAfterUints + i] = bytes32(uint256(uint160(bytes20(addressInputs[i])))); // silly ah solidity way to get left padded 32bytes hopefully the compiler doesn't make it look silly\n        }\n        return publicInputs;\n    }\n\n    // TODO relayer support\n    function mint(\n        uint256 _nullifier,\n        uint256 _amount,\n        uint256 _gigaRoot,\n        uint256 _localRoot,\n        uint256 _feeFactor,\n        uint256 _priorityFee,\n        uint256 _maxFee,\n        address _relayer,\n        address _recipient,\n        bytes memory _poof\n    ) public {\n        require(isValidGigaRoot(_gigaRoot), \"_gigaRoot unknown\");\n        require(isValidLocalRoot(_localRoot), \"_localRoot unknown\"); \n        \n        bytes32[] memory _publicInputs = _formatPublicInputs(_nullifier, block.chainid, _amount, _gigaRoot, _localRoot, _feeFactor, _priorityFee, _maxFee, _relayer, _recipient);\n        require(IVerifier(withdrawVerifier).verify(_poof, _publicInputs), \"invalid proof\"); \n\n        // fee logic       \n        if (_feeFactor != 0 ) { // \n            uint256 _relayerFee = _feeFactor * (block.basefee + _priorityFee); // TODO double check precision. Prob only breaks if the wrpToad token price is super high or gas cost super low\n            require(_relayerFee <= _maxFee, \"_relayerFee is larger than _maxFee\");\n            // for compatibility with permissionless relaying\n            if (_relayer == address(1)){\n                _relayer = msg.sender;\n            }\n            _mint(_relayer, _relayerFee);\n            _mint(_recipient, _amount - _relayerFee);\n        } else {\n            // its self relayed or relayer is just nice :D\n            _mint(_recipient, _amount);\n        }\n    }\n\n    function localRoot() public view returns (uint256) {\n        return LazyIMT.root(commitTreeData, maxTreeDepth);\n    }\n\n    function isValidLocalRoot(uint256 _localRoot) public view returns (bool) {\n        return localRootHistory[_localRoot];\n    }\n\n    // gigaRootProvider can call directly since are on the L1 already and dont need adapter\n    function receiveGigaRoot(uint256 _gigaRoot) public payable onlyGigaRootProvider() {\n        gigaRootHistory[_gigaRoot] = true;\n        gigaRoot = _gigaRoot;\n    }\n\n\n    function getLocalRootAndBlock() external returns (uint256, uint256) {\n        storeLocalRootInHistory();\n        return (cachedLocalRoot, block.number);\n    }\n\n    function getFreeShit(uint256 _amount) public {\n        _mint( msg.sender, _amount);\n    }\n\n\n}"
      },
      "project/contracts/evm/WithdrawVerifier.sol": {
        "content": "// Verification Key Hash: 7f2da3d34d24f1e31c920da329b0eecba70393f3f88517b60a4f793e90c0fcfa\n// SPDX-License-Identifier: Apache-2.0\n// Copyright 2022 Aztec\npragma solidity >=0.8.4;\n\nlibrary UltraVerificationKey {\n    function verificationKeyHash() internal pure returns(bytes32) {\n        return 0x7f2da3d34d24f1e31c920da329b0eecba70393f3f88517b60a4f793e90c0fcfa;\n    }\n\n    function loadVerificationKey(uint256 _vk, uint256 _omegaInverseLoc) internal pure {\n        assembly {\n            mstore(add(_vk, 0x00), 0x0000000000000000000000000000000000000000000000000000000000020000) // vk.circuit_size\n            mstore(add(_vk, 0x20), 0x000000000000000000000000000000000000000000000000000000000000000a) // vk.num_inputs\n            mstore(add(_vk, 0x40), 0x1bf82deba7d74902c3708cc6e70e61f30512eca95655210e276e5858ce8f58e5) // vk.work_root\n            mstore(add(_vk, 0x60), 0x30643640b9f82f90e83b698e5ea6179c7c05542e859533b48b9953a2f5360801) // vk.domain_inverse\n            mstore(add(_vk, 0x80), 0x224398064ac73079d2063eb89723088fdb17d72c80819518507c5130ed73497d) // vk.Q1.x\n            mstore(add(_vk, 0xa0), 0x20692b45447cf667c06dd7026555bb8b984b357f1e9d859d40a5eb2f2afd29cd) // vk.Q1.y\n            mstore(add(_vk, 0xc0), 0x110e574ad518fec0ff8686237da003fa1d2778fe2b2269f07693b6a3d016eaed) // vk.Q2.x\n            mstore(add(_vk, 0xe0), 0x0b57ebe3670547f2d5c2d6e0966c15367b0dfbf4affc6c46188e4ed8ca3f3f5f) // vk.Q2.y\n            mstore(add(_vk, 0x100), 0x0fa5b05d8dc66ba1c69154ef477a17fd1fc0b6e9fa3cf400c4392d0db5485e3f) // vk.Q3.x\n            mstore(add(_vk, 0x120), 0x234498289d0d4ea8b2fbd91719b40c707c5f7812ef8a6753b7f91635de237499) // vk.Q3.y\n            mstore(add(_vk, 0x140), 0x1e085456554baddac806a11926697ee380fe0a34aec83d8678c2cb53c4bc5e64) // vk.Q4.x\n            mstore(add(_vk, 0x160), 0x0714403a04f407f2811aab9225cdb61c1046338d17c2f822df111b355646d15f) // vk.Q4.y\n            mstore(add(_vk, 0x180), 0x2c6d0d3b373838a055c43a8c44477f39d9922a30a204974a3f504e89d1580fba) // vk.Q_M.x\n            mstore(add(_vk, 0x1a0), 0x016c11e5cf82f000bb4ac81e2f327503b6aa493709b5e3c3f503b4e9f945bd66) // vk.Q_M.y\n            mstore(add(_vk, 0x1c0), 0x0a1b706c78f89fa93140e0313b194588534a6eef04dbe311debc1f620165ee72) // vk.Q_C.x\n            mstore(add(_vk, 0x1e0), 0x0e583faba118f0861f3484ee80649bcfcdca50ea78e8cd7ecc47c127d7d3dee0) // vk.Q_C.y\n            mstore(add(_vk, 0x200), 0x2d5d0195343a6fb8e835009ed84e3b54812269a2c37e1b00495fbccbda46cd6b) // vk.Q_ARITHMETIC.x\n            mstore(add(_vk, 0x220), 0x032c382adcea9774955083290d44ff71f0b49293feda9ef7dba4653d5fc4e224) // vk.Q_ARITHMETIC.y\n            mstore(add(_vk, 0x240), 0x13f5be390eebd9841b1771f496dcb3f73c554579369c9e8ffb4a66fbdf59b440) // vk.QSORT.x\n            mstore(add(_vk, 0x260), 0x1b01a321a08f6b5961b672ef1a12c1ec8891ef47e3c8ac8e3c057dee1dc535d7) // vk.QSORT.y\n            mstore(add(_vk, 0x280), 0x1414af76247139fa9e8fef8b393a3e03227ee3a6fedb1e55f5db82cb2352782a) // vk.Q_ELLIPTIC.x\n            mstore(add(_vk, 0x2a0), 0x2c7895a68d2fab5b2bce4d7703daebf9011e63d675bc6898c7f06087d6d83d99) // vk.Q_ELLIPTIC.y\n            mstore(add(_vk, 0x2c0), 0x1fd912d00da77afb70848e4442324157606f77f54ebc05d1a1a5fc2030836b13) // vk.Q_AUX.x\n            mstore(add(_vk, 0x2e0), 0x1b1c85cc22723d352d37c86cfd66d45e809a813b99a452fe452c7ae975de2286) // vk.Q_AUX.y\n            mstore(add(_vk, 0x300), 0x01a576cf9fe65a281f5d7f36c0dfdf9ef159e82171ea18a8e9dbf166473d2e6a) // vk.SIGMA1.x\n            mstore(add(_vk, 0x320), 0x082992100774c0c21660591fb4298b940cc5f3cac2a71f98ef6a75a727ec7610) // vk.SIGMA1.y\n            mstore(add(_vk, 0x340), 0x0241ce4bbc892645a82972fa22e18d7eb7257ae523b2b2843d12a160ffe45ed6) // vk.SIGMA2.x\n            mstore(add(_vk, 0x360), 0x2c9f960423e9e9709fe18aae682c506fac77e853c3b4bb61c958fa3100bbd905) // vk.SIGMA2.y\n            mstore(add(_vk, 0x380), 0x1e903e4c962ccf537b73c14adb522f1cbaddbdd177694f1b9d735e5d52f087e4) // vk.SIGMA3.x\n            mstore(add(_vk, 0x3a0), 0x03dbc75f48265ab15926b712c14f003695e7372626d97fce241e6332b9c62c74) // vk.SIGMA3.y\n            mstore(add(_vk, 0x3c0), 0x0c1cd0f6f3e8b0cf173e15001f7fb4dad89ffeb04289564f8cd38d624dc778cb) // vk.SIGMA4.x\n            mstore(add(_vk, 0x3e0), 0x0737f4ba15bcebcf7498f4d2d4433fff1bb5b1c9d78e923eb12c722aaae5eb49) // vk.SIGMA4.y\n            mstore(add(_vk, 0x400), 0x28faa42b5c13a5e9927d13e54a2ed806854cd23c6662b320439aa3168beffe03) // vk.TABLE1.x\n            mstore(add(_vk, 0x420), 0x1e5c18afa66b4c0d19473e0536e64f678c1b094d1b2eff1d7f499dc289efc084) // vk.TABLE1.y\n            mstore(add(_vk, 0x440), 0x10a001251e9f3a9f283ff8f6bd14cba9c706f3c5040ec8ef10ff44988441251c) // vk.TABLE2.x\n            mstore(add(_vk, 0x460), 0x12138fab93fce066ddb2f9be4eff97b0fe128a2a2c079f749b8452698cace8bf) // vk.TABLE2.y\n            mstore(add(_vk, 0x480), 0x133738f359ce2e0f909a0b76a78c602e66e39c41d99f65bfea25f47998283ccd) // vk.TABLE3.x\n            mstore(add(_vk, 0x4a0), 0x2dd03593caea05125f520c0d02a3bbbdc5519822ba0e0b00984c5a9281143a81) // vk.TABLE3.y\n            mstore(add(_vk, 0x4c0), 0x09ec9b0aca4e9671903e0577f2a4efd36f7a58af0a5102f5a42e1b8061f62421) // vk.TABLE4.x\n            mstore(add(_vk, 0x4e0), 0x15affeadf66c8428f4f44d2ebe66e9dc0f04215bef81efbbee166d3f4544feab) // vk.TABLE4.y\n            mstore(add(_vk, 0x500), 0x1a3cbf0dc620735762652e441d934293dfc7618d57318323d278ba6d587f66b3) // vk.TABLE_TYPE.x\n            mstore(add(_vk, 0x520), 0x1822f3b9fc82ef44022c41324e3dd28e888c696c8f95e0e5dcaf80a1167a57b9) // vk.TABLE_TYPE.y\n            mstore(add(_vk, 0x540), 0x186902d1cbff9a789686f0816fff8bdee315c253a195d38535b84066596d97b7) // vk.ID1.x\n            mstore(add(_vk, 0x560), 0x15aaaa70327c049b89d04a0aa09ac9579387e31fa640d5d451541b0ae32da4f8) // vk.ID1.y\n            mstore(add(_vk, 0x580), 0x0d948a9b7426031448328a12029aac36a5789c8a142de9b142e0d5f20921c0dc) // vk.ID2.x\n            mstore(add(_vk, 0x5a0), 0x1c64483af4d4942418908850f4485027ed8b00b6ee2df579010e1221a1183877) // vk.ID2.y\n            mstore(add(_vk, 0x5c0), 0x280536150d25e57150ee4f84b994d060ec93aaa5983f941a6b63f1a5fa6d8196) // vk.ID3.x\n            mstore(add(_vk, 0x5e0), 0x29cab82d8f78aa4e9e9e1d1d46c240e6ecb814ddf1c1b72696f5d3925675321c) // vk.ID3.y\n            mstore(add(_vk, 0x600), 0x2b0e7dfccc7afae4c8cd98dc983e449685a6814ab097a57e972110b3e4ec16cd) // vk.ID4.x\n            mstore(add(_vk, 0x620), 0x243333c19baca94cc919f476bdc63fcfd4b2046ad8e296b3fbf4f44eeae703c9) // vk.ID4.y\n            mstore(add(_vk, 0x640), 0x00) // vk.contains_pairing_point_accumulator\n            mstore(add(_vk, 0x660), 0) // vk.pairing_point_accumulator_public_input_indices\n            mstore(add(_vk, 0x680), 0x260e01b251f6f1c7e7ff4e580791dee8ea51d87a358e038b4efe30fac09383c1) // vk.g2_x.X.c1 \n            mstore(add(_vk, 0x6a0), 0x0118c4d5b837bcc2bc89b5b398b5974e9f5944073b32078b7e231fec938883b0) // vk.g2_x.X.c0 \n            mstore(add(_vk, 0x6c0), 0x04fc6369f7110fe3d25156c1bb9a72859cf2a04641f99ba4ee413c80da6a5fe4) // vk.g2_x.Y.c1 \n            mstore(add(_vk, 0x6e0), 0x22febda3c0c0632a56475b4214e5615e11e6dd3f96e6cea2854a87d4dacc5e55) // vk.g2_x.Y.c0 \n            mstore(_omegaInverseLoc, 0x244cf010c43ca87237d8b00bf9dd50c4c01c7f086bd4e8c920e75251d96f0d22) // vk.work_root_inverse\n        }\n    }\n}\n\n/**\n * @title Ultra Plonk proof verification contract\n * @dev Top level Plonk proof verification contract, which allows Plonk proof to be verified\n */\nabstract contract BaseUltraVerifier {\n    // VERIFICATION KEY MEMORY LOCATIONS\n    uint256 internal constant N_LOC = 0x380;\n    uint256 internal constant NUM_INPUTS_LOC = 0x3a0;\n    uint256 internal constant OMEGA_LOC = 0x3c0;\n    uint256 internal constant DOMAIN_INVERSE_LOC = 0x3e0;\n    uint256 internal constant Q1_X_LOC = 0x400;\n    uint256 internal constant Q1_Y_LOC = 0x420;\n    uint256 internal constant Q2_X_LOC = 0x440;\n    uint256 internal constant Q2_Y_LOC = 0x460;\n    uint256 internal constant Q3_X_LOC = 0x480;\n    uint256 internal constant Q3_Y_LOC = 0x4a0;\n    uint256 internal constant Q4_X_LOC = 0x4c0;\n    uint256 internal constant Q4_Y_LOC = 0x4e0;\n    uint256 internal constant QM_X_LOC = 0x500;\n    uint256 internal constant QM_Y_LOC = 0x520;\n    uint256 internal constant QC_X_LOC = 0x540;\n    uint256 internal constant QC_Y_LOC = 0x560;\n    uint256 internal constant QARITH_X_LOC = 0x580;\n    uint256 internal constant QARITH_Y_LOC = 0x5a0;\n    uint256 internal constant QSORT_X_LOC = 0x5c0;\n    uint256 internal constant QSORT_Y_LOC = 0x5e0;\n    uint256 internal constant QELLIPTIC_X_LOC = 0x600;\n    uint256 internal constant QELLIPTIC_Y_LOC = 0x620;\n    uint256 internal constant QAUX_X_LOC = 0x640;\n    uint256 internal constant QAUX_Y_LOC = 0x660;\n    uint256 internal constant SIGMA1_X_LOC = 0x680;\n    uint256 internal constant SIGMA1_Y_LOC = 0x6a0;\n    uint256 internal constant SIGMA2_X_LOC = 0x6c0;\n    uint256 internal constant SIGMA2_Y_LOC = 0x6e0;\n    uint256 internal constant SIGMA3_X_LOC = 0x700;\n    uint256 internal constant SIGMA3_Y_LOC = 0x720;\n    uint256 internal constant SIGMA4_X_LOC = 0x740;\n    uint256 internal constant SIGMA4_Y_LOC = 0x760;\n    uint256 internal constant TABLE1_X_LOC = 0x780;\n    uint256 internal constant TABLE1_Y_LOC = 0x7a0;\n    uint256 internal constant TABLE2_X_LOC = 0x7c0;\n    uint256 internal constant TABLE2_Y_LOC = 0x7e0;\n    uint256 internal constant TABLE3_X_LOC = 0x800;\n    uint256 internal constant TABLE3_Y_LOC = 0x820;\n    uint256 internal constant TABLE4_X_LOC = 0x840;\n    uint256 internal constant TABLE4_Y_LOC = 0x860;\n    uint256 internal constant TABLE_TYPE_X_LOC = 0x880;\n    uint256 internal constant TABLE_TYPE_Y_LOC = 0x8a0;\n    uint256 internal constant ID1_X_LOC = 0x8c0;\n    uint256 internal constant ID1_Y_LOC = 0x8e0;\n    uint256 internal constant ID2_X_LOC = 0x900;\n    uint256 internal constant ID2_Y_LOC = 0x920;\n    uint256 internal constant ID3_X_LOC = 0x940;\n    uint256 internal constant ID3_Y_LOC = 0x960;\n    uint256 internal constant ID4_X_LOC = 0x980;\n    uint256 internal constant ID4_Y_LOC = 0x9a0;\n    uint256 internal constant CONTAINS_RECURSIVE_PROOF_LOC = 0x9c0;\n    uint256 internal constant RECURSIVE_PROOF_PUBLIC_INPUT_INDICES_LOC = 0x9e0;\n    uint256 internal constant G2X_X0_LOC = 0xa00;\n    uint256 internal constant G2X_X1_LOC = 0xa20;\n    uint256 internal constant G2X_Y0_LOC = 0xa40;\n    uint256 internal constant G2X_Y1_LOC = 0xa60;\n\n    // ### PROOF DATA MEMORY LOCATIONS\n    uint256 internal constant W1_X_LOC = 0x1200;\n    uint256 internal constant W1_Y_LOC = 0x1220;\n    uint256 internal constant W2_X_LOC = 0x1240;\n    uint256 internal constant W2_Y_LOC = 0x1260;\n    uint256 internal constant W3_X_LOC = 0x1280;\n    uint256 internal constant W3_Y_LOC = 0x12a0;\n    uint256 internal constant W4_X_LOC = 0x12c0;\n    uint256 internal constant W4_Y_LOC = 0x12e0;\n    uint256 internal constant S_X_LOC = 0x1300;\n    uint256 internal constant S_Y_LOC = 0x1320;\n    uint256 internal constant Z_X_LOC = 0x1340;\n    uint256 internal constant Z_Y_LOC = 0x1360;\n    uint256 internal constant Z_LOOKUP_X_LOC = 0x1380;\n    uint256 internal constant Z_LOOKUP_Y_LOC = 0x13a0;\n    uint256 internal constant T1_X_LOC = 0x13c0;\n    uint256 internal constant T1_Y_LOC = 0x13e0;\n    uint256 internal constant T2_X_LOC = 0x1400;\n    uint256 internal constant T2_Y_LOC = 0x1420;\n    uint256 internal constant T3_X_LOC = 0x1440;\n    uint256 internal constant T3_Y_LOC = 0x1460;\n    uint256 internal constant T4_X_LOC = 0x1480;\n    uint256 internal constant T4_Y_LOC = 0x14a0;\n\n    uint256 internal constant W1_EVAL_LOC = 0x1600;\n    uint256 internal constant W2_EVAL_LOC = 0x1620;\n    uint256 internal constant W3_EVAL_LOC = 0x1640;\n    uint256 internal constant W4_EVAL_LOC = 0x1660;\n    uint256 internal constant S_EVAL_LOC = 0x1680;\n    uint256 internal constant Z_EVAL_LOC = 0x16a0;\n    uint256 internal constant Z_LOOKUP_EVAL_LOC = 0x16c0;\n    uint256 internal constant Q1_EVAL_LOC = 0x16e0;\n    uint256 internal constant Q2_EVAL_LOC = 0x1700;\n    uint256 internal constant Q3_EVAL_LOC = 0x1720;\n    uint256 internal constant Q4_EVAL_LOC = 0x1740;\n    uint256 internal constant QM_EVAL_LOC = 0x1760;\n    uint256 internal constant QC_EVAL_LOC = 0x1780;\n    uint256 internal constant QARITH_EVAL_LOC = 0x17a0;\n    uint256 internal constant QSORT_EVAL_LOC = 0x17c0;\n    uint256 internal constant QELLIPTIC_EVAL_LOC = 0x17e0;\n    uint256 internal constant QAUX_EVAL_LOC = 0x1800;\n    uint256 internal constant TABLE1_EVAL_LOC = 0x1840;\n    uint256 internal constant TABLE2_EVAL_LOC = 0x1860;\n    uint256 internal constant TABLE3_EVAL_LOC = 0x1880;\n    uint256 internal constant TABLE4_EVAL_LOC = 0x18a0;\n    uint256 internal constant TABLE_TYPE_EVAL_LOC = 0x18c0;\n    uint256 internal constant ID1_EVAL_LOC = 0x18e0;\n    uint256 internal constant ID2_EVAL_LOC = 0x1900;\n    uint256 internal constant ID3_EVAL_LOC = 0x1920;\n    uint256 internal constant ID4_EVAL_LOC = 0x1940;\n    uint256 internal constant SIGMA1_EVAL_LOC = 0x1960;\n    uint256 internal constant SIGMA2_EVAL_LOC = 0x1980;\n    uint256 internal constant SIGMA3_EVAL_LOC = 0x19a0;\n    uint256 internal constant SIGMA4_EVAL_LOC = 0x19c0;\n    uint256 internal constant W1_OMEGA_EVAL_LOC = 0x19e0;\n    uint256 internal constant W2_OMEGA_EVAL_LOC = 0x2000;\n    uint256 internal constant W3_OMEGA_EVAL_LOC = 0x2020;\n    uint256 internal constant W4_OMEGA_EVAL_LOC = 0x2040;\n    uint256 internal constant S_OMEGA_EVAL_LOC = 0x2060;\n    uint256 internal constant Z_OMEGA_EVAL_LOC = 0x2080;\n    uint256 internal constant Z_LOOKUP_OMEGA_EVAL_LOC = 0x20a0;\n    uint256 internal constant TABLE1_OMEGA_EVAL_LOC = 0x20c0;\n    uint256 internal constant TABLE2_OMEGA_EVAL_LOC = 0x20e0;\n    uint256 internal constant TABLE3_OMEGA_EVAL_LOC = 0x2100;\n    uint256 internal constant TABLE4_OMEGA_EVAL_LOC = 0x2120;\n\n    uint256 internal constant PI_Z_X_LOC = 0x2300;\n    uint256 internal constant PI_Z_Y_LOC = 0x2320;\n    uint256 internal constant PI_Z_OMEGA_X_LOC = 0x2340;\n    uint256 internal constant PI_Z_OMEGA_Y_LOC = 0x2360;\n\n    // Used for elliptic widget. These are alias names for wire + shifted wire evaluations\n    uint256 internal constant X1_EVAL_LOC = W2_EVAL_LOC;\n    uint256 internal constant X2_EVAL_LOC = W1_OMEGA_EVAL_LOC;\n    uint256 internal constant X3_EVAL_LOC = W2_OMEGA_EVAL_LOC;\n    uint256 internal constant Y1_EVAL_LOC = W3_EVAL_LOC;\n    uint256 internal constant Y2_EVAL_LOC = W4_OMEGA_EVAL_LOC;\n    uint256 internal constant Y3_EVAL_LOC = W3_OMEGA_EVAL_LOC;\n    uint256 internal constant QBETA_LOC = Q3_EVAL_LOC;\n    uint256 internal constant QBETA_SQR_LOC = Q4_EVAL_LOC;\n    uint256 internal constant QSIGN_LOC = Q1_EVAL_LOC;\n\n    // ### CHALLENGES MEMORY OFFSETS\n\n    uint256 internal constant C_BETA_LOC = 0x2600;\n    uint256 internal constant C_GAMMA_LOC = 0x2620;\n    uint256 internal constant C_ALPHA_LOC = 0x2640;\n    uint256 internal constant C_ETA_LOC = 0x2660;\n    uint256 internal constant C_ETA_SQR_LOC = 0x2680;\n    uint256 internal constant C_ETA_CUBE_LOC = 0x26a0;\n\n    uint256 internal constant C_ZETA_LOC = 0x26c0;\n    uint256 internal constant C_CURRENT_LOC = 0x26e0;\n    uint256 internal constant C_V0_LOC = 0x2700;\n    uint256 internal constant C_V1_LOC = 0x2720;\n    uint256 internal constant C_V2_LOC = 0x2740;\n    uint256 internal constant C_V3_LOC = 0x2760;\n    uint256 internal constant C_V4_LOC = 0x2780;\n    uint256 internal constant C_V5_LOC = 0x27a0;\n    uint256 internal constant C_V6_LOC = 0x27c0;\n    uint256 internal constant C_V7_LOC = 0x27e0;\n    uint256 internal constant C_V8_LOC = 0x2800;\n    uint256 internal constant C_V9_LOC = 0x2820;\n    uint256 internal constant C_V10_LOC = 0x2840;\n    uint256 internal constant C_V11_LOC = 0x2860;\n    uint256 internal constant C_V12_LOC = 0x2880;\n    uint256 internal constant C_V13_LOC = 0x28a0;\n    uint256 internal constant C_V14_LOC = 0x28c0;\n    uint256 internal constant C_V15_LOC = 0x28e0;\n    uint256 internal constant C_V16_LOC = 0x2900;\n    uint256 internal constant C_V17_LOC = 0x2920;\n    uint256 internal constant C_V18_LOC = 0x2940;\n    uint256 internal constant C_V19_LOC = 0x2960;\n    uint256 internal constant C_V20_LOC = 0x2980;\n    uint256 internal constant C_V21_LOC = 0x29a0;\n    uint256 internal constant C_V22_LOC = 0x29c0;\n    uint256 internal constant C_V23_LOC = 0x29e0;\n    uint256 internal constant C_V24_LOC = 0x2a00;\n    uint256 internal constant C_V25_LOC = 0x2a20;\n    uint256 internal constant C_V26_LOC = 0x2a40;\n    uint256 internal constant C_V27_LOC = 0x2a60;\n    uint256 internal constant C_V28_LOC = 0x2a80;\n    uint256 internal constant C_V29_LOC = 0x2aa0;\n    uint256 internal constant C_V30_LOC = 0x2ac0;\n\n    uint256 internal constant C_U_LOC = 0x2b00;\n\n    // ### LOCAL VARIABLES MEMORY OFFSETS\n    uint256 internal constant DELTA_NUMERATOR_LOC = 0x3000;\n    uint256 internal constant DELTA_DENOMINATOR_LOC = 0x3020;\n    uint256 internal constant ZETA_POW_N_LOC = 0x3040;\n    uint256 internal constant PUBLIC_INPUT_DELTA_LOC = 0x3060;\n    uint256 internal constant ZERO_POLY_LOC = 0x3080;\n    uint256 internal constant L_START_LOC = 0x30a0;\n    uint256 internal constant L_END_LOC = 0x30c0;\n    uint256 internal constant R_ZERO_EVAL_LOC = 0x30e0;\n\n    uint256 internal constant PLOOKUP_DELTA_NUMERATOR_LOC = 0x3100;\n    uint256 internal constant PLOOKUP_DELTA_DENOMINATOR_LOC = 0x3120;\n    uint256 internal constant PLOOKUP_DELTA_LOC = 0x3140;\n\n    uint256 internal constant ACCUMULATOR_X_LOC = 0x3160;\n    uint256 internal constant ACCUMULATOR_Y_LOC = 0x3180;\n    uint256 internal constant ACCUMULATOR2_X_LOC = 0x31a0;\n    uint256 internal constant ACCUMULATOR2_Y_LOC = 0x31c0;\n    uint256 internal constant PAIRING_LHS_X_LOC = 0x31e0;\n    uint256 internal constant PAIRING_LHS_Y_LOC = 0x3200;\n    uint256 internal constant PAIRING_RHS_X_LOC = 0x3220;\n    uint256 internal constant PAIRING_RHS_Y_LOC = 0x3240;\n\n    // misc stuff\n    uint256 internal constant OMEGA_INVERSE_LOC = 0x3300;\n    uint256 internal constant C_ALPHA_SQR_LOC = 0x3320;\n    uint256 internal constant C_ALPHA_CUBE_LOC = 0x3340;\n    uint256 internal constant C_ALPHA_QUAD_LOC = 0x3360;\n    uint256 internal constant C_ALPHA_BASE_LOC = 0x3380;\n\n    // ### RECURSION VARIABLE MEMORY LOCATIONS\n    uint256 internal constant RECURSIVE_P1_X_LOC = 0x3400;\n    uint256 internal constant RECURSIVE_P1_Y_LOC = 0x3420;\n    uint256 internal constant RECURSIVE_P2_X_LOC = 0x3440;\n    uint256 internal constant RECURSIVE_P2_Y_LOC = 0x3460;\n    uint256 internal constant PUBLIC_INPUTS_HASH_LOCATION = 0x3480;\n\n    // sub-identity storage\n    uint256 internal constant PERMUTATION_IDENTITY = 0x3500;\n    uint256 internal constant PLOOKUP_IDENTITY = 0x3520;\n    uint256 internal constant ARITHMETIC_IDENTITY = 0x3540;\n    uint256 internal constant SORT_IDENTITY = 0x3560;\n    uint256 internal constant ELLIPTIC_IDENTITY = 0x3580;\n    uint256 internal constant AUX_IDENTITY = 0x35a0;\n    uint256 internal constant AUX_NON_NATIVE_FIELD_EVALUATION = 0x35c0;\n    uint256 internal constant AUX_LIMB_ACCUMULATOR_EVALUATION = 0x35e0;\n    uint256 internal constant AUX_RAM_CONSISTENCY_EVALUATION = 0x3600;\n    uint256 internal constant AUX_ROM_CONSISTENCY_EVALUATION = 0x3620;\n    uint256 internal constant AUX_MEMORY_EVALUATION = 0x3640;\n\n    uint256 internal constant QUOTIENT_EVAL_LOC = 0x3660;\n    uint256 internal constant ZERO_POLY_INVERSE_LOC = 0x3680;\n\n    // when hashing public inputs we use memory at NU_CHALLENGE_INPUT_LOC_A, as the hash input size is unknown at compile time\n    uint256 internal constant NU_CHALLENGE_INPUT_LOC_A = 0x36a0;\n    uint256 internal constant NU_CHALLENGE_INPUT_LOC_B = 0x36c0;\n    uint256 internal constant NU_CHALLENGE_INPUT_LOC_C = 0x36e0;\n\n    bytes4 internal constant INVALID_VERIFICATION_KEY_SELECTOR = 0x7e5769bf;\n    bytes4 internal constant POINT_NOT_ON_CURVE_SELECTOR = 0xa3dad654;\n    bytes4 internal constant PUBLIC_INPUT_INVALID_BN128_G1_POINT_SELECTOR = 0xeba9f4a6;\n    bytes4 internal constant PUBLIC_INPUT_GE_P_SELECTOR = 0x374a972f;\n    bytes4 internal constant MOD_EXP_FAILURE_SELECTOR = 0xf894a7bc;\n    bytes4 internal constant PAIRING_PREAMBLE_FAILED_SELECTOR = 0x01882d81;\n    bytes4 internal constant OPENING_COMMITMENT_FAILED_SELECTOR = 0x4e719763;\n    bytes4 internal constant PAIRING_FAILED_SELECTOR = 0xd71fd263;\n\n    uint256 internal constant ETA_INPUT_LENGTH = 0xc0; // W1, W2, W3 = 6 * 0x20 bytes\n\n    // We need to hash 41 field elements when generating the NU challenge\n    // w1, w2, w3, w4, s, z, z_lookup, q1, q2, q3, q4, qm, qc, qarith (14)\n    // qsort, qelliptic, qaux, sigma1, sigma2, sigma, sigma4, (7)\n    // table1, table2, table3, table4, tabletype, id1, id2, id3, id4, (9)\n    // w1_omega, w2_omega, w3_omega, w4_omega, s_omega, z_omega, z_lookup_omega, (7)\n    // table1_omega, table2_omega, table3_omega, table4_omega (4)\n    uint256 internal constant NU_INPUT_LENGTH = 0x520; // 0x520 = 41 * 0x20\n\n    // There are ELEVEN G1 group elements added into the transcript in the `beta` round, that we need to skip over\n    // W1, W2, W3, W4, S, Z, Z_LOOKUP, T1, T2, T3, T4\n    uint256 internal constant NU_CALLDATA_SKIP_LENGTH = 0x2c0; // 11 * 0x40 = 0x2c0\n\n    uint256 internal constant NEGATIVE_INVERSE_OF_2_MODULO_P =\n        0x183227397098d014dc2822db40c0ac2e9419f4243cdcb848a1f0fac9f8000000;\n    uint256 internal constant LIMB_SIZE = 0x100000000000000000; // 2<<68\n    uint256 internal constant SUBLIMB_SHIFT = 0x4000; // 2<<14\n\n    // y^2 = x^3 + ax + b\n    // for Grumpkin, a = 0 and b = -17. We use b in a custom gate relation that evaluates elliptic curve arithmetic\n    uint256 internal constant GRUMPKIN_CURVE_B_PARAMETER_NEGATED = 17;\n\n    error INVALID_VERIFICATION_KEY();\n    error POINT_NOT_ON_CURVE();\n    error PUBLIC_INPUT_COUNT_INVALID(uint256 expected, uint256 actual);\n    error PUBLIC_INPUT_INVALID_BN128_G1_POINT();\n    error PUBLIC_INPUT_GE_P();\n    error MOD_EXP_FAILURE();\n    error PAIRING_PREAMBLE_FAILED();\n    error OPENING_COMMITMENT_FAILED();\n    error PAIRING_FAILED();\n\n    function getVerificationKeyHash() public pure virtual returns (bytes32);\n\n    /**\n     * @dev We assume that the verification key loaded by this function is constant as we only verify it on deployment\n     */\n    function loadVerificationKey(uint256 _vk, uint256 _omegaInverseLoc) internal pure virtual;\n\n    constructor() { \n        loadVerificationKey(N_LOC, OMEGA_INVERSE_LOC);\n\n        // We verify that all of the EC points in the verification key lie on the bn128 curve. \n        assembly {\n            let q := 21888242871839275222246405745257275088696311157297823662689037894645226208583 // EC group order\n\n            let success := 1\n\n            // VALIDATE Q1\n            {\n                let x := mload(Q1_X_LOC)\n                let y := mload(Q1_Y_LOC)\n                let xx := mulmod(x, x, q)\n                // validate on curve\n                success := and(success, eq(mulmod(y, y, q), addmod(mulmod(x, xx, q), 3, q)))\n            }\n            // VALIDATE Q2\n            {\n                let x := mload(Q2_X_LOC)\n                let y := mload(Q2_Y_LOC)\n                let xx := mulmod(x, x, q)\n                // validate on curve\n                success := and(success, eq(mulmod(y, y, q), addmod(mulmod(x, xx, q), 3, q)))\n            }\n            // VALIDATE Q3\n            {\n                let x := mload(Q3_X_LOC)\n                let y := mload(Q3_Y_LOC)\n                let xx := mulmod(x, x, q)\n                // validate on curve\n                success := and(success, eq(mulmod(y, y, q), addmod(mulmod(x, xx, q), 3, q)))\n            }\n            // VALIDATE Q4\n            {\n                let x := mload(Q4_X_LOC)\n                let y := mload(Q4_Y_LOC)\n                let xx := mulmod(x, x, q)\n                // validate on curve\n                success := and(success, eq(mulmod(y, y, q), addmod(mulmod(x, xx, q), 3, q)))\n                mstore(0x00, x)\n                mstore(0x20, y)\n            }\n            // VALIDATE QM\n            {\n                let x := mload(QM_X_LOC)\n                let y := mload(QM_Y_LOC)\n                let xx := mulmod(x, x, q)\n                // validate on curve\n                success := and(success, eq(mulmod(y, y, q), addmod(mulmod(x, xx, q), 3, q)))\n            }\n            // VALIDATE QC\n            {\n                let x := mload(QC_X_LOC)\n                let y := mload(QC_Y_LOC)\n                let xx := mulmod(x, x, q)\n                // validate on curve\n                success := and(success, eq(mulmod(y, y, q), addmod(mulmod(x, xx, q), 3, q)))\n            }\n            // VALIDATE QARITH\n            {\n                let x := mload(QARITH_X_LOC)\n                let y := mload(QARITH_Y_LOC)\n                let xx := mulmod(x, x, q)\n                // validate on curve\n                success := and(success, eq(mulmod(y, y, q), addmod(mulmod(x, xx, q), 3, q)))\n            }\n            // VALIDATE QSORT\n            {\n                let x := mload(QSORT_X_LOC)\n                let y := mload(QSORT_Y_LOC)\n                let xx := mulmod(x, x, q)\n                // validate on curve\n                success := and(success, eq(mulmod(y, y, q), addmod(mulmod(x, xx, q), 3, q)))\n            }\n            // VALIDATE QELLIPTIC\n            {\n                let x := mload(QELLIPTIC_X_LOC)\n                let y := mload(QELLIPTIC_Y_LOC)\n                let xx := mulmod(x, x, q)\n                // validate on curve\n                success := and(success, eq(mulmod(y, y, q), addmod(mulmod(x, xx, q), 3, q)))\n            }\n            // VALIDATE QAUX\n            {\n                let x := mload(QAUX_X_LOC)\n                let y := mload(QAUX_Y_LOC)\n                let xx := mulmod(x, x, q)\n                // validate on curve\n                success := and(success, eq(mulmod(y, y, q), addmod(mulmod(x, xx, q), 3, q)))\n            }\n            // VALIDATE SIGMA1\n            {\n                let x := mload(SIGMA1_X_LOC)\n                let y := mload(SIGMA1_Y_LOC)\n                let xx := mulmod(x, x, q)\n                // validate on curve\n                success := and(success, eq(mulmod(y, y, q), addmod(mulmod(x, xx, q), 3, q)))\n            }\n            // VALIDATE SIGMA2\n            {\n                let x := mload(SIGMA2_X_LOC)\n                let y := mload(SIGMA2_Y_LOC)\n                let xx := mulmod(x, x, q)\n                // validate on curve\n                success := and(success, eq(mulmod(y, y, q), addmod(mulmod(x, xx, q), 3, q)))\n            }\n            // VALIDATE SIGMA3\n            {\n                let x := mload(SIGMA3_X_LOC)\n                let y := mload(SIGMA3_Y_LOC)\n                let xx := mulmod(x, x, q)\n                // validate on curve\n                success := and(success, eq(mulmod(y, y, q), addmod(mulmod(x, xx, q), 3, q)))\n            }\n            // VALIDATE SIGMA4\n            {\n                let x := mload(SIGMA4_X_LOC)\n                let y := mload(SIGMA4_Y_LOC)\n                let xx := mulmod(x, x, q)\n                // validate on curve\n                success := and(success, eq(mulmod(y, y, q), addmod(mulmod(x, xx, q), 3, q)))\n            }\n            // VALIDATE TABLE1\n            {\n                let x := mload(TABLE1_X_LOC)\n                let y := mload(TABLE1_Y_LOC)\n                let xx := mulmod(x, x, q)\n                // validate on curve\n                success := and(success, eq(mulmod(y, y, q), addmod(mulmod(x, xx, q), 3, q)))\n            } \n            // VALIDATE TABLE2\n            {\n                let x := mload(TABLE2_X_LOC)\n                let y := mload(TABLE2_Y_LOC)\n                let xx := mulmod(x, x, q)\n                // validate on curve\n                success := and(success, eq(mulmod(y, y, q), addmod(mulmod(x, xx, q), 3, q)))\n            } \n            // VALIDATE TABLE3\n            {\n                let x := mload(TABLE3_X_LOC)\n                let y := mload(TABLE3_Y_LOC)\n                let xx := mulmod(x, x, q)\n                // validate on curve\n                success := and(success, eq(mulmod(y, y, q), addmod(mulmod(x, xx, q), 3, q)))\n            } \n            // VALIDATE TABLE4\n            {\n                let x := mload(TABLE4_X_LOC)\n                let y := mload(TABLE4_Y_LOC)\n                let xx := mulmod(x, x, q)\n                // validate on curve\n                success := and(success, eq(mulmod(y, y, q), addmod(mulmod(x, xx, q), 3, q)))\n            } \n            // VALIDATE TABLE_TYPE\n            {\n                let x := mload(TABLE_TYPE_X_LOC)\n                let y := mload(TABLE_TYPE_Y_LOC)\n                let xx := mulmod(x, x, q)\n                // validate on curve\n                success := and(success, eq(mulmod(y, y, q), addmod(mulmod(x, xx, q), 3, q)))\n            }\n            // VALIDATE ID1\n            {\n                let x := mload(ID1_X_LOC)\n                let y := mload(ID1_Y_LOC)\n                let xx := mulmod(x, x, q)\n                // validate on curve\n                success := and(success, eq(mulmod(y, y, q), addmod(mulmod(x, xx, q), 3, q)))\n            }\n            // VALIDATE ID2\n            {\n                let x := mload(ID2_X_LOC)\n                let y := mload(ID2_Y_LOC)\n                let xx := mulmod(x, x, q)\n                // validate on curve\n                success := and(success, eq(mulmod(y, y, q), addmod(mulmod(x, xx, q), 3, q)))\n            }\n            // VALIDATE ID3\n            {\n                let x := mload(ID3_X_LOC)\n                let y := mload(ID3_Y_LOC)\n                let xx := mulmod(x, x, q)\n                // validate on curve\n                success := and(success, eq(mulmod(y, y, q), addmod(mulmod(x, xx, q), 3, q)))\n            }\n            // VALIDATE ID4\n            {\n                let x := mload(ID4_X_LOC)\n                let y := mload(ID4_Y_LOC)\n                let xx := mulmod(x, x, q)\n                // validate on curve\n                success := and(success, eq(mulmod(y, y, q), addmod(mulmod(x, xx, q), 3, q)))\n            }\n\n            if iszero(success) {\n                mstore(0x0, INVALID_VERIFICATION_KEY_SELECTOR)\n                revert(0x00, 0x04)\n            }\n        }\n    }\n\n    /**\n     * @notice Verify a Ultra Plonk proof\n     * @param _proof - The serialized proof\n     * @param _publicInputs - An array of the public inputs\n     * @return True if proof is valid, reverts otherwise\n     */\n    function verify(bytes calldata _proof, bytes32[] calldata _publicInputs) external view returns (bool) {\n        loadVerificationKey(N_LOC, OMEGA_INVERSE_LOC);\n\n        uint256 requiredPublicInputCount;\n        assembly {\n            requiredPublicInputCount := mload(NUM_INPUTS_LOC)\n        }\n        if (requiredPublicInputCount != _publicInputs.length) {\n            revert PUBLIC_INPUT_COUNT_INVALID(requiredPublicInputCount, _publicInputs.length);\n        }\n\n        assembly {\n            let q := 21888242871839275222246405745257275088696311157297823662689037894645226208583 // EC group order\n            let p := 21888242871839275222246405745257275088548364400416034343698204186575808495617 // Prime field order\n\n            /**\n             * LOAD PROOF FROM CALLDATA\n             */\n            {\n                let data_ptr := add(calldataload(0x04), 0x24)\n\n                mstore(W1_Y_LOC, mod(calldataload(data_ptr), q))\n                mstore(W1_X_LOC, mod(calldataload(add(data_ptr, 0x20)), q))\n\n                mstore(W2_Y_LOC, mod(calldataload(add(data_ptr, 0x40)), q))\n                mstore(W2_X_LOC, mod(calldataload(add(data_ptr, 0x60)), q))\n\n                mstore(W3_Y_LOC, mod(calldataload(add(data_ptr, 0x80)), q))\n                mstore(W3_X_LOC, mod(calldataload(add(data_ptr, 0xa0)), q))\n\n                mstore(W4_Y_LOC, mod(calldataload(add(data_ptr, 0xc0)), q))\n                mstore(W4_X_LOC, mod(calldataload(add(data_ptr, 0xe0)), q))\n\n                mstore(S_Y_LOC, mod(calldataload(add(data_ptr, 0x100)), q))\n                mstore(S_X_LOC, mod(calldataload(add(data_ptr, 0x120)), q))\n                mstore(Z_Y_LOC, mod(calldataload(add(data_ptr, 0x140)), q))\n                mstore(Z_X_LOC, mod(calldataload(add(data_ptr, 0x160)), q))\n                mstore(Z_LOOKUP_Y_LOC, mod(calldataload(add(data_ptr, 0x180)), q))\n                mstore(Z_LOOKUP_X_LOC, mod(calldataload(add(data_ptr, 0x1a0)), q))\n                mstore(T1_Y_LOC, mod(calldataload(add(data_ptr, 0x1c0)), q))\n                mstore(T1_X_LOC, mod(calldataload(add(data_ptr, 0x1e0)), q))\n\n                mstore(T2_Y_LOC, mod(calldataload(add(data_ptr, 0x200)), q))\n                mstore(T2_X_LOC, mod(calldataload(add(data_ptr, 0x220)), q))\n\n                mstore(T3_Y_LOC, mod(calldataload(add(data_ptr, 0x240)), q))\n                mstore(T3_X_LOC, mod(calldataload(add(data_ptr, 0x260)), q))\n\n                mstore(T4_Y_LOC, mod(calldataload(add(data_ptr, 0x280)), q))\n                mstore(T4_X_LOC, mod(calldataload(add(data_ptr, 0x2a0)), q))\n\n                mstore(W1_EVAL_LOC, mod(calldataload(add(data_ptr, 0x2c0)), p))\n                mstore(W2_EVAL_LOC, mod(calldataload(add(data_ptr, 0x2e0)), p))\n                mstore(W3_EVAL_LOC, mod(calldataload(add(data_ptr, 0x300)), p))\n                mstore(W4_EVAL_LOC, mod(calldataload(add(data_ptr, 0x320)), p))\n                mstore(S_EVAL_LOC, mod(calldataload(add(data_ptr, 0x340)), p))\n                mstore(Z_EVAL_LOC, mod(calldataload(add(data_ptr, 0x360)), p))\n                mstore(Z_LOOKUP_EVAL_LOC, mod(calldataload(add(data_ptr, 0x380)), p))\n                mstore(Q1_EVAL_LOC, mod(calldataload(add(data_ptr, 0x3a0)), p))\n                mstore(Q2_EVAL_LOC, mod(calldataload(add(data_ptr, 0x3c0)), p))\n                mstore(Q3_EVAL_LOC, mod(calldataload(add(data_ptr, 0x3e0)), p))\n                mstore(Q4_EVAL_LOC, mod(calldataload(add(data_ptr, 0x400)), p))\n                mstore(QM_EVAL_LOC, mod(calldataload(add(data_ptr, 0x420)), p))\n                mstore(QC_EVAL_LOC, mod(calldataload(add(data_ptr, 0x440)), p))\n                mstore(QARITH_EVAL_LOC, mod(calldataload(add(data_ptr, 0x460)), p))\n                mstore(QSORT_EVAL_LOC, mod(calldataload(add(data_ptr, 0x480)), p))\n                mstore(QELLIPTIC_EVAL_LOC, mod(calldataload(add(data_ptr, 0x4a0)), p))\n                mstore(QAUX_EVAL_LOC, mod(calldataload(add(data_ptr, 0x4c0)), p))\n\n                mstore(SIGMA1_EVAL_LOC, mod(calldataload(add(data_ptr, 0x4e0)), p))\n                mstore(SIGMA2_EVAL_LOC, mod(calldataload(add(data_ptr, 0x500)), p))\n\n                mstore(SIGMA3_EVAL_LOC, mod(calldataload(add(data_ptr, 0x520)), p))\n                mstore(SIGMA4_EVAL_LOC, mod(calldataload(add(data_ptr, 0x540)), p))\n\n                mstore(TABLE1_EVAL_LOC, mod(calldataload(add(data_ptr, 0x560)), p))\n                mstore(TABLE2_EVAL_LOC, mod(calldataload(add(data_ptr, 0x580)), p))\n                mstore(TABLE3_EVAL_LOC, mod(calldataload(add(data_ptr, 0x5a0)), p))\n                mstore(TABLE4_EVAL_LOC, mod(calldataload(add(data_ptr, 0x5c0)), p))\n                mstore(TABLE_TYPE_EVAL_LOC, mod(calldataload(add(data_ptr, 0x5e0)), p))\n\n                mstore(ID1_EVAL_LOC, mod(calldataload(add(data_ptr, 0x600)), p))\n                mstore(ID2_EVAL_LOC, mod(calldataload(add(data_ptr, 0x620)), p))\n                mstore(ID3_EVAL_LOC, mod(calldataload(add(data_ptr, 0x640)), p))\n                mstore(ID4_EVAL_LOC, mod(calldataload(add(data_ptr, 0x660)), p))\n\n                mstore(W1_OMEGA_EVAL_LOC, mod(calldataload(add(data_ptr, 0x680)), p))\n                mstore(W2_OMEGA_EVAL_LOC, mod(calldataload(add(data_ptr, 0x6a0)), p))\n                mstore(W3_OMEGA_EVAL_LOC, mod(calldataload(add(data_ptr, 0x6c0)), p))\n                mstore(W4_OMEGA_EVAL_LOC, mod(calldataload(add(data_ptr, 0x6e0)), p))\n                mstore(S_OMEGA_EVAL_LOC, mod(calldataload(add(data_ptr, 0x700)), p))\n\n                mstore(Z_OMEGA_EVAL_LOC, mod(calldataload(add(data_ptr, 0x720)), p))\n\n                mstore(Z_LOOKUP_OMEGA_EVAL_LOC, mod(calldataload(add(data_ptr, 0x740)), p))\n                mstore(TABLE1_OMEGA_EVAL_LOC, mod(calldataload(add(data_ptr, 0x760)), p))\n                mstore(TABLE2_OMEGA_EVAL_LOC, mod(calldataload(add(data_ptr, 0x780)), p))\n                mstore(TABLE3_OMEGA_EVAL_LOC, mod(calldataload(add(data_ptr, 0x7a0)), p))\n                mstore(TABLE4_OMEGA_EVAL_LOC, mod(calldataload(add(data_ptr, 0x7c0)), p))\n\n                mstore(PI_Z_Y_LOC, mod(calldataload(add(data_ptr, 0x7e0)), q))\n                mstore(PI_Z_X_LOC, mod(calldataload(add(data_ptr, 0x800)), q))\n\n                mstore(PI_Z_OMEGA_Y_LOC, mod(calldataload(add(data_ptr, 0x820)), q))\n                mstore(PI_Z_OMEGA_X_LOC, mod(calldataload(add(data_ptr, 0x840)), q))\n            }\n\n            /**\n             * LOAD RECURSIVE PROOF INTO MEMORY\n             */\n            {\n                if mload(CONTAINS_RECURSIVE_PROOF_LOC) {\n                    let public_inputs_ptr := add(calldataload(0x24), 0x24)\n                    let index_counter := add(shl(5, mload(RECURSIVE_PROOF_PUBLIC_INPUT_INDICES_LOC)), public_inputs_ptr)\n\n                    let x0 := calldataload(index_counter)\n                    x0 := add(x0, shl(68, calldataload(add(index_counter, 0x20))))\n                    x0 := add(x0, shl(136, calldataload(add(index_counter, 0x40))))\n                    x0 := add(x0, shl(204, calldataload(add(index_counter, 0x60))))\n                    let y0 := calldataload(add(index_counter, 0x80))\n                    y0 := add(y0, shl(68, calldataload(add(index_counter, 0xa0))))\n                    y0 := add(y0, shl(136, calldataload(add(index_counter, 0xc0))))\n                    y0 := add(y0, shl(204, calldataload(add(index_counter, 0xe0))))\n                    let x1 := calldataload(add(index_counter, 0x100))\n                    x1 := add(x1, shl(68, calldataload(add(index_counter, 0x120))))\n                    x1 := add(x1, shl(136, calldataload(add(index_counter, 0x140))))\n                    x1 := add(x1, shl(204, calldataload(add(index_counter, 0x160))))\n                    let y1 := calldataload(add(index_counter, 0x180))\n                    y1 := add(y1, shl(68, calldataload(add(index_counter, 0x1a0))))\n                    y1 := add(y1, shl(136, calldataload(add(index_counter, 0x1c0))))\n                    y1 := add(y1, shl(204, calldataload(add(index_counter, 0x1e0))))\n                    mstore(RECURSIVE_P1_X_LOC, x0)\n                    mstore(RECURSIVE_P1_Y_LOC, y0)\n                    mstore(RECURSIVE_P2_X_LOC, x1)\n                    mstore(RECURSIVE_P2_Y_LOC, y1)\n\n                    // validate these are valid bn128 G1 points\n                    if iszero(and(and(lt(x0, q), lt(x1, q)), and(lt(y0, q), lt(y1, q)))) {\n                        mstore(0x00, PUBLIC_INPUT_INVALID_BN128_G1_POINT_SELECTOR)\n                        revert(0x00, 0x04)\n                    }\n                }\n            }\n\n            {\n                /**\n                 * Generate initial challenge\n                 */\n                mstore(0x00, shl(224, mload(N_LOC)))\n                mstore(0x04, shl(224, mload(NUM_INPUTS_LOC)))\n                let challenge := keccak256(0x00, 0x08)\n\n                /**\n                 * Generate eta challenge\n                 */\n                mstore(PUBLIC_INPUTS_HASH_LOCATION, challenge)\n                // The public input location is stored at 0x24, we then add 0x24 to skip selector and the length of public inputs\n                let public_inputs_start := add(calldataload(0x24), 0x24)\n                // copy the public inputs over\n                let public_input_size := mul(mload(NUM_INPUTS_LOC), 0x20)\n                calldatacopy(add(PUBLIC_INPUTS_HASH_LOCATION, 0x20), public_inputs_start, public_input_size)\n\n                // copy W1, W2, W3 into challenge. Each point is 0x40 bytes, so load 0xc0 = 3 * 0x40 bytes (ETA input length)\n                let w_start := add(calldataload(0x04), 0x24)\n                calldatacopy(add(add(PUBLIC_INPUTS_HASH_LOCATION, 0x20), public_input_size), w_start, ETA_INPUT_LENGTH)\n\n                // Challenge is the old challenge + public inputs + W1, W2, W3 (0x20 + public_input_size + 0xc0)\n                let challenge_bytes_size := add(0x20, add(public_input_size, ETA_INPUT_LENGTH))\n\n                challenge := keccak256(PUBLIC_INPUTS_HASH_LOCATION, challenge_bytes_size)\n                {\n                    let eta := mod(challenge, p)\n                    mstore(C_ETA_LOC, eta)\n                    mstore(C_ETA_SQR_LOC, mulmod(eta, eta, p))\n                    mstore(C_ETA_CUBE_LOC, mulmod(mload(C_ETA_SQR_LOC), eta, p))\n                }\n\n                /**\n                 * Generate beta challenge\n                 */\n                mstore(0x00, challenge)\n                mstore(0x20, mload(W4_Y_LOC))\n                mstore(0x40, mload(W4_X_LOC))\n                mstore(0x60, mload(S_Y_LOC))\n                mstore(0x80, mload(S_X_LOC))\n                challenge := keccak256(0x00, 0xa0)\n                mstore(C_BETA_LOC, mod(challenge, p))\n\n                /**\n                 * Generate gamma challenge\n                 */\n                mstore(0x00, challenge)\n                mstore8(0x20, 0x01)\n                challenge := keccak256(0x00, 0x21)\n                mstore(C_GAMMA_LOC, mod(challenge, p))\n\n                /**\n                 * Generate alpha challenge\n                 */\n                mstore(0x00, challenge)\n                mstore(0x20, mload(Z_Y_LOC))\n                mstore(0x40, mload(Z_X_LOC))\n                mstore(0x60, mload(Z_LOOKUP_Y_LOC))\n                mstore(0x80, mload(Z_LOOKUP_X_LOC))\n                challenge := keccak256(0x00, 0xa0)\n                mstore(C_ALPHA_LOC, mod(challenge, p))\n\n                /**\n                 * Compute and store some powers of alpha for future computations\n                 */\n                let alpha := mload(C_ALPHA_LOC)\n                mstore(C_ALPHA_SQR_LOC, mulmod(alpha, alpha, p))\n                mstore(C_ALPHA_CUBE_LOC, mulmod(mload(C_ALPHA_SQR_LOC), alpha, p))\n                mstore(C_ALPHA_QUAD_LOC, mulmod(mload(C_ALPHA_CUBE_LOC), alpha, p))\n                mstore(C_ALPHA_BASE_LOC, alpha)\n\n                /**\n                 * Generate zeta challenge\n                 */\n                mstore(0x00, challenge)\n                mstore(0x20, mload(T1_Y_LOC))\n                mstore(0x40, mload(T1_X_LOC))\n                mstore(0x60, mload(T2_Y_LOC))\n                mstore(0x80, mload(T2_X_LOC))\n                mstore(0xa0, mload(T3_Y_LOC))\n                mstore(0xc0, mload(T3_X_LOC))\n                mstore(0xe0, mload(T4_Y_LOC))\n                mstore(0x100, mload(T4_X_LOC))\n\n                challenge := keccak256(0x00, 0x120)\n\n                mstore(C_ZETA_LOC, mod(challenge, p))\n                mstore(C_CURRENT_LOC, challenge)\n            }\n\n            /**\n             * EVALUATE FIELD OPERATIONS\n             */\n\n            /**\n             * COMPUTE PUBLIC INPUT DELTA\n             * ΔPI = ∏ᵢ∈ℓ(wᵢ + β σ(i) + γ) / ∏ᵢ∈ℓ(wᵢ + β σ'(i) + γ)\n             */\n            {\n                let beta := mload(C_BETA_LOC) // β\n                let gamma := mload(C_GAMMA_LOC) // γ\n                let work_root := mload(OMEGA_LOC) // ω\n                let numerator_value := 1\n                let denominator_value := 1\n\n                let p_clone := p // move p to the front of the stack\n                let valid_inputs := true\n\n                // Load the starting point of the public inputs (jump over the selector and the length of public inputs [0x24])\n                let public_inputs_ptr := add(calldataload(0x24), 0x24)\n\n                // endpoint_ptr = public_inputs_ptr + num_inputs * 0x20. // every public input is 0x20 bytes\n                let endpoint_ptr := add(public_inputs_ptr, mul(mload(NUM_INPUTS_LOC), 0x20))\n\n                // root_1 = β * 0x05\n                let root_1 := mulmod(beta, 0x05, p_clone) // k1.β\n                // root_2 = β * 0x0c\n                let root_2 := mulmod(beta, 0x0c, p_clone)\n                // @note 0x05 + 0x07 == 0x0c == external coset generator\n\n                for {} lt(public_inputs_ptr, endpoint_ptr) { public_inputs_ptr := add(public_inputs_ptr, 0x20) } {\n                    /**\n                     * input = public_input[i]\n                     * valid_inputs &= input < p\n                     * temp = input + gamma\n                     * numerator_value *= (β.σ(i) + wᵢ + γ)  // σ(i) = 0x05.ωⁱ\n                     * denominator_value *= (β.σ'(i) + wᵢ + γ) // σ'(i) = 0x0c.ωⁱ\n                     * root_1 *= ω\n                     * root_2 *= ω\n                     */\n\n                    let input := calldataload(public_inputs_ptr)\n                    valid_inputs := and(valid_inputs, lt(input, p_clone))\n                    let temp := addmod(input, gamma, p_clone)\n\n                    numerator_value := mulmod(numerator_value, add(root_1, temp), p_clone)\n                    denominator_value := mulmod(denominator_value, add(root_2, temp), p_clone)\n\n                    root_1 := mulmod(root_1, work_root, p_clone)\n                    root_2 := mulmod(root_2, work_root, p_clone)\n                }\n\n                // Revert if not all public inputs are field elements (i.e. < p)\n                if iszero(valid_inputs) {\n                    mstore(0x00, PUBLIC_INPUT_GE_P_SELECTOR)\n                    revert(0x00, 0x04)\n                }\n\n                mstore(DELTA_NUMERATOR_LOC, numerator_value)\n                mstore(DELTA_DENOMINATOR_LOC, denominator_value)\n            }\n\n            /**\n             * Compute Plookup delta factor [γ(1 + β)]^{n-k}\n             * k = num roots cut out of Z_H = 4\n             */\n            {\n                let delta_base := mulmod(mload(C_GAMMA_LOC), addmod(mload(C_BETA_LOC), 1, p), p)\n                let delta_numerator := delta_base\n                {\n                    let exponent := mload(N_LOC)\n                    let count := 1\n                    for {} lt(count, exponent) { count := add(count, count) } {\n                        delta_numerator := mulmod(delta_numerator, delta_numerator, p)\n                    }\n                }\n                mstore(PLOOKUP_DELTA_NUMERATOR_LOC, delta_numerator)\n\n                let delta_denominator := mulmod(delta_base, delta_base, p)\n                delta_denominator := mulmod(delta_denominator, delta_denominator, p)\n                mstore(PLOOKUP_DELTA_DENOMINATOR_LOC, delta_denominator)\n            }\n            /**\n             * Compute lagrange poly and vanishing poly fractions\n             */\n            {\n                /**\n                 * vanishing_numerator = zeta\n                 * ZETA_POW_N = zeta^n\n                 * vanishing_numerator -= 1\n                 * accumulating_root = omega_inverse\n                 * work_root = p - accumulating_root\n                 * domain_inverse = domain_inverse\n                 * vanishing_denominator = zeta + work_root\n                 * work_root *= accumulating_root\n                 * vanishing_denominator *= (zeta + work_root)\n                 * work_root *= accumulating_root\n                 * vanishing_denominator *= (zeta + work_root)\n                 * vanishing_denominator *= (zeta + (zeta + accumulating_root))\n                 * work_root = omega\n                 * lagrange_numerator = vanishing_numerator * domain_inverse\n                 * l_start_denominator = zeta - 1\n                 * accumulating_root = work_root^2\n                 * l_end_denominator = accumulating_root^2 * work_root * zeta - 1\n                 * Note: l_end_denominator term contains a term \\omega^5 to cut out 5 roots of unity from vanishing poly\n                 */\n\n                let zeta := mload(C_ZETA_LOC)\n\n                // compute zeta^n, where n is a power of 2\n                let vanishing_numerator := zeta\n                {\n                    // pow_small\n                    let exponent := mload(N_LOC)\n                    let count := 1\n                    for {} lt(count, exponent) { count := add(count, count) } {\n                        vanishing_numerator := mulmod(vanishing_numerator, vanishing_numerator, p)\n                    }\n                }\n                mstore(ZETA_POW_N_LOC, vanishing_numerator)\n                vanishing_numerator := addmod(vanishing_numerator, sub(p, 1), p)\n\n                let accumulating_root := mload(OMEGA_INVERSE_LOC)\n                let work_root := sub(p, accumulating_root)\n                let domain_inverse := mload(DOMAIN_INVERSE_LOC)\n\n                let vanishing_denominator := addmod(zeta, work_root, p)\n                work_root := mulmod(work_root, accumulating_root, p)\n                vanishing_denominator := mulmod(vanishing_denominator, addmod(zeta, work_root, p), p)\n                work_root := mulmod(work_root, accumulating_root, p)\n                vanishing_denominator := mulmod(vanishing_denominator, addmod(zeta, work_root, p), p)\n                vanishing_denominator :=\n                    mulmod(vanishing_denominator, addmod(zeta, mulmod(work_root, accumulating_root, p), p), p)\n\n                work_root := mload(OMEGA_LOC)\n\n                let lagrange_numerator := mulmod(vanishing_numerator, domain_inverse, p)\n                let l_start_denominator := addmod(zeta, sub(p, 1), p)\n\n                accumulating_root := mulmod(work_root, work_root, p)\n\n                let l_end_denominator :=\n                    addmod(\n                        mulmod(mulmod(mulmod(accumulating_root, accumulating_root, p), work_root, p), zeta, p), sub(p, 1), p\n                    )\n\n                /**\n                 * Compute inversions using Montgomery's batch inversion trick\n                 */\n                let accumulator := mload(DELTA_DENOMINATOR_LOC)\n                let t0 := accumulator\n                accumulator := mulmod(accumulator, vanishing_denominator, p)\n                let t1 := accumulator\n                accumulator := mulmod(accumulator, vanishing_numerator, p)\n                let t2 := accumulator\n                accumulator := mulmod(accumulator, l_start_denominator, p)\n                let t3 := accumulator\n                accumulator := mulmod(accumulator, mload(PLOOKUP_DELTA_DENOMINATOR_LOC), p)\n                let t4 := accumulator\n                {\n                    mstore(0, 0x20)\n                    mstore(0x20, 0x20)\n                    mstore(0x40, 0x20)\n                    mstore(0x60, mulmod(accumulator, l_end_denominator, p))\n                    mstore(0x80, sub(p, 2))\n                    mstore(0xa0, p)\n                    if iszero(staticcall(gas(), 0x05, 0x00, 0xc0, 0x00, 0x20)) {\n                        mstore(0x0, MOD_EXP_FAILURE_SELECTOR)\n                        revert(0x00, 0x04)\n                    }\n                    accumulator := mload(0x00)\n                }\n\n                t4 := mulmod(accumulator, t4, p)\n                accumulator := mulmod(accumulator, l_end_denominator, p)\n\n                t3 := mulmod(accumulator, t3, p)\n                accumulator := mulmod(accumulator, mload(PLOOKUP_DELTA_DENOMINATOR_LOC), p)\n\n                t2 := mulmod(accumulator, t2, p)\n                accumulator := mulmod(accumulator, l_start_denominator, p)\n\n                t1 := mulmod(accumulator, t1, p)\n                accumulator := mulmod(accumulator, vanishing_numerator, p)\n\n                t0 := mulmod(accumulator, t0, p)\n                accumulator := mulmod(accumulator, vanishing_denominator, p)\n\n                accumulator := mulmod(mulmod(accumulator, accumulator, p), mload(DELTA_DENOMINATOR_LOC), p)\n\n                mstore(PUBLIC_INPUT_DELTA_LOC, mulmod(mload(DELTA_NUMERATOR_LOC), accumulator, p))\n                mstore(ZERO_POLY_LOC, mulmod(vanishing_numerator, t0, p))\n                mstore(ZERO_POLY_INVERSE_LOC, mulmod(vanishing_denominator, t1, p))\n                mstore(L_START_LOC, mulmod(lagrange_numerator, t2, p))\n                mstore(PLOOKUP_DELTA_LOC, mulmod(mload(PLOOKUP_DELTA_NUMERATOR_LOC), t3, p))\n                mstore(L_END_LOC, mulmod(lagrange_numerator, t4, p))\n            }\n\n            /**\n             * UltraPlonk Widget Ordering:\n             *\n             * 1. Permutation widget\n             * 2. Plookup widget\n             * 3. Arithmetic widget\n             * 4. Fixed base widget (?)\n             * 5. GenPermSort widget\n             * 6. Elliptic widget\n             * 7. Auxiliary widget\n             */\n\n            /**\n             * COMPUTE PERMUTATION WIDGET EVALUATION\n             */\n            {\n                let alpha := mload(C_ALPHA_LOC)\n                let beta := mload(C_BETA_LOC)\n                let gamma := mload(C_GAMMA_LOC)\n\n                /**\n                 * t1 = (W1 + gamma + beta * ID1) * (W2 + gamma + beta * ID2)\n                 * t2 = (W3 + gamma + beta * ID3) * (W4 + gamma + beta * ID4)\n                 * result = alpha_base * z_eval * t1 * t2\n                 * t1 = (W1 + gamma + beta * sigma_1_eval) * (W2 + gamma + beta * sigma_2_eval)\n                 * t2 = (W2 + gamma + beta * sigma_3_eval) * (W3 + gamma + beta * sigma_4_eval)\n                 * result -= (alpha_base * z_omega_eval * t1 * t2)\n                 */\n                let t1 :=\n                    mulmod(\n                        add(add(mload(W1_EVAL_LOC), gamma), mulmod(beta, mload(ID1_EVAL_LOC), p)),\n                        add(add(mload(W2_EVAL_LOC), gamma), mulmod(beta, mload(ID2_EVAL_LOC), p)),\n                        p\n                    )\n                let t2 :=\n                    mulmod(\n                        add(add(mload(W3_EVAL_LOC), gamma), mulmod(beta, mload(ID3_EVAL_LOC), p)),\n                        add(add(mload(W4_EVAL_LOC), gamma), mulmod(beta, mload(ID4_EVAL_LOC), p)),\n                        p\n                    )\n                let result := mulmod(mload(C_ALPHA_BASE_LOC), mulmod(mload(Z_EVAL_LOC), mulmod(t1, t2, p), p), p)\n                t1 :=\n                    mulmod(\n                        add(add(mload(W1_EVAL_LOC), gamma), mulmod(beta, mload(SIGMA1_EVAL_LOC), p)),\n                        add(add(mload(W2_EVAL_LOC), gamma), mulmod(beta, mload(SIGMA2_EVAL_LOC), p)),\n                        p\n                    )\n                t2 :=\n                    mulmod(\n                        add(add(mload(W3_EVAL_LOC), gamma), mulmod(beta, mload(SIGMA3_EVAL_LOC), p)),\n                        add(add(mload(W4_EVAL_LOC), gamma), mulmod(beta, mload(SIGMA4_EVAL_LOC), p)),\n                        p\n                    )\n                result :=\n                    addmod(\n                        result,\n                        sub(p, mulmod(mload(C_ALPHA_BASE_LOC), mulmod(mload(Z_OMEGA_EVAL_LOC), mulmod(t1, t2, p), p), p)),\n                        p\n                    )\n\n                /**\n                 * alpha_base *= alpha\n                 * result += alpha_base . (L_{n-k}(ʓ) . (z(ʓ.ω) - ∆_{PI}))\n                 * alpha_base *= alpha\n                 * result += alpha_base . (L_1(ʓ)(Z(ʓ) - 1))\n                 * alpha_Base *= alpha\n                 */\n                mstore(C_ALPHA_BASE_LOC, mulmod(mload(C_ALPHA_BASE_LOC), mload(C_ALPHA_LOC), p))\n                result :=\n                    addmod(\n                        result,\n                        mulmod(\n                            mload(C_ALPHA_BASE_LOC),\n                            mulmod(\n                                mload(L_END_LOC),\n                                addmod(mload(Z_OMEGA_EVAL_LOC), sub(p, mload(PUBLIC_INPUT_DELTA_LOC)), p),\n                                p\n                            ),\n                            p\n                        ),\n                        p\n                    )\n                mstore(C_ALPHA_BASE_LOC, mulmod(mload(C_ALPHA_BASE_LOC), mload(C_ALPHA_LOC), p))\n                mstore(\n                    PERMUTATION_IDENTITY,\n                    addmod(\n                        result,\n                        mulmod(\n                            mload(C_ALPHA_BASE_LOC),\n                            mulmod(mload(L_START_LOC), addmod(mload(Z_EVAL_LOC), sub(p, 1), p), p),\n                            p\n                        ),\n                        p\n                    )\n                )\n                mstore(C_ALPHA_BASE_LOC, mulmod(mload(C_ALPHA_BASE_LOC), mload(C_ALPHA_LOC), p))\n            }\n\n            /**\n             * COMPUTE PLOOKUP WIDGET EVALUATION\n             */\n            {\n                /**\n                 * Goal: f = (w1(z) + q2.w1(zω)) + η(w2(z) + qm.w2(zω)) + η²(w3(z) + qc.w_3(zω)) + q3(z).η³\n                 * f = η.q3(z)\n                 * f += (w3(z) + qc.w_3(zω))\n                 * f *= η\n                 * f += (w2(z) + qm.w2(zω))\n                 * f *= η\n                 * f += (w1(z) + q2.w1(zω))\n                 */\n                let f := mulmod(mload(C_ETA_LOC), mload(Q3_EVAL_LOC), p)\n                f :=\n                    addmod(f, addmod(mload(W3_EVAL_LOC), mulmod(mload(QC_EVAL_LOC), mload(W3_OMEGA_EVAL_LOC), p), p), p)\n                f := mulmod(f, mload(C_ETA_LOC), p)\n                f :=\n                    addmod(f, addmod(mload(W2_EVAL_LOC), mulmod(mload(QM_EVAL_LOC), mload(W2_OMEGA_EVAL_LOC), p), p), p)\n                f := mulmod(f, mload(C_ETA_LOC), p)\n                f :=\n                    addmod(f, addmod(mload(W1_EVAL_LOC), mulmod(mload(Q2_EVAL_LOC), mload(W1_OMEGA_EVAL_LOC), p), p), p)\n\n                // t(z) = table4(z).η³ + table3(z).η² + table2(z).η + table1(z)\n                let t :=\n                    addmod(\n                        addmod(\n                            addmod(\n                                mulmod(mload(TABLE4_EVAL_LOC), mload(C_ETA_CUBE_LOC), p),\n                                mulmod(mload(TABLE3_EVAL_LOC), mload(C_ETA_SQR_LOC), p),\n                                p\n                            ),\n                            mulmod(mload(TABLE2_EVAL_LOC), mload(C_ETA_LOC), p),\n                            p\n                        ),\n                        mload(TABLE1_EVAL_LOC),\n                        p\n                    )\n\n                // t(zw) = table4(zw).η³ + table3(zw).η² + table2(zw).η + table1(zw)\n                let t_omega :=\n                    addmod(\n                        addmod(\n                            addmod(\n                                mulmod(mload(TABLE4_OMEGA_EVAL_LOC), mload(C_ETA_CUBE_LOC), p),\n                                mulmod(mload(TABLE3_OMEGA_EVAL_LOC), mload(C_ETA_SQR_LOC), p),\n                                p\n                            ),\n                            mulmod(mload(TABLE2_OMEGA_EVAL_LOC), mload(C_ETA_LOC), p),\n                            p\n                        ),\n                        mload(TABLE1_OMEGA_EVAL_LOC),\n                        p\n                    )\n\n                /**\n                 * Goal: numerator = (TABLE_TYPE_EVAL * f(z) + γ) * (t(z) + βt(zω) + γ(β + 1)) * (β + 1)\n                 * gamma_beta_constant = γ(β + 1)\n                 * numerator = f * TABLE_TYPE_EVAL + gamma\n                 * temp0 = t(z) + t(zω) * β + gamma_beta_constant\n                 * numerator *= temp0\n                 * numerator *= (β + 1)\n                 * temp0 = alpha * l_1\n                 * numerator += temp0\n                 * numerator *= z_lookup(z)\n                 * numerator -= temp0\n                 */\n                let gamma_beta_constant := mulmod(mload(C_GAMMA_LOC), addmod(mload(C_BETA_LOC), 1, p), p)\n                let numerator := addmod(mulmod(f, mload(TABLE_TYPE_EVAL_LOC), p), mload(C_GAMMA_LOC), p)\n                let temp0 := addmod(addmod(t, mulmod(t_omega, mload(C_BETA_LOC), p), p), gamma_beta_constant, p)\n                numerator := mulmod(numerator, temp0, p)\n                numerator := mulmod(numerator, addmod(mload(C_BETA_LOC), 1, p), p)\n                temp0 := mulmod(mload(C_ALPHA_LOC), mload(L_START_LOC), p)\n                numerator := addmod(numerator, temp0, p)\n                numerator := mulmod(numerator, mload(Z_LOOKUP_EVAL_LOC), p)\n                numerator := addmod(numerator, sub(p, temp0), p)\n\n                /**\n                 * Goal: denominator = z_lookup(zω)*[s(z) + βs(zω) + γ(1 + β)] - [z_lookup(zω) - [γ(1 + β)]^{n-k}]*α²L_end(z)\n                 * note: delta_factor = [γ(1 + β)]^{n-k}\n                 * denominator = s(z) + βs(zω) + γ(β + 1)\n                 * temp1 = α²L_end(z)\n                 * denominator -= temp1\n                 * denominator *= z_lookup(zω)\n                 * denominator += temp1 * delta_factor\n                 * PLOOKUP_IDENTITY = (numerator - denominator).alpha_base\n                 * alpha_base *= alpha^3\n                 */\n                let denominator :=\n                    addmod(\n                        addmod(mload(S_EVAL_LOC), mulmod(mload(S_OMEGA_EVAL_LOC), mload(C_BETA_LOC), p), p),\n                        gamma_beta_constant,\n                        p\n                    )\n                let temp1 := mulmod(mload(C_ALPHA_SQR_LOC), mload(L_END_LOC), p)\n                denominator := addmod(denominator, sub(p, temp1), p)\n                denominator := mulmod(denominator, mload(Z_LOOKUP_OMEGA_EVAL_LOC), p)\n                denominator := addmod(denominator, mulmod(temp1, mload(PLOOKUP_DELTA_LOC), p), p)\n\n                mstore(PLOOKUP_IDENTITY, mulmod(addmod(numerator, sub(p, denominator), p), mload(C_ALPHA_BASE_LOC), p))\n\n                // update alpha\n                mstore(C_ALPHA_BASE_LOC, mulmod(mload(C_ALPHA_BASE_LOC), mload(C_ALPHA_CUBE_LOC), p))\n            }\n\n            /**\n             * COMPUTE ARITHMETIC WIDGET EVALUATION\n             */\n            {\n                /**\n                 * The basic arithmetic gate identity in standard plonk is as follows.\n                 * (w_1 . w_2 . q_m) + (w_1 . q_1) + (w_2 . q_2) + (w_3 . q_3) + (w_4 . q_4) + q_c = 0\n                 * However, for Ultraplonk, we extend this to support \"passing\" wires between rows (shown without alpha scaling below):\n                 * q_arith * ( ( (-1/2) * (q_arith - 3) * q_m * w_1 * w_2 + q_1 * w_1 + q_2 * w_2 + q_3 * w_3 + q_4 * w_4 + q_c ) +\n                 * (q_arith - 1)*( α * (q_arith - 2) * (w_1 + w_4 - w_1_omega + q_m) + w_4_omega) ) = 0\n                 *\n                 * This formula results in several cases depending on q_arith:\n                 * 1. q_arith == 0: Arithmetic gate is completely disabled\n                 *\n                 * 2. q_arith == 1: Everything in the minigate on the right is disabled. The equation is just a standard plonk equation\n                 * with extra wires: q_m * w_1 * w_2 + q_1 * w_1 + q_2 * w_2 + q_3 * w_3 + q_4 * w_4 + q_c = 0\n                 *\n                 * 3. q_arith == 2: The (w_1 + w_4 - ...) term is disabled. THe equation is:\n                 * (1/2) * q_m * w_1 * w_2 + q_1 * w_1 + q_2 * w_2 + q_3 * w_3 + q_4 * w_4 + q_c + w_4_omega = 0\n                 * It allows defining w_4 at next index (w_4_omega) in terms of current wire values\n                 *\n                 * 4. q_arith == 3: The product of w_1 and w_2 is disabled, but a mini addition gate is enabled. α allows us to split\n                 * the equation into two:\n                 *\n                 * q_1 * w_1 + q_2 * w_2 + q_3 * w_3 + q_4 * w_4 + q_c + 2 * w_4_omega = 0\n                 * and\n                 * w_1 + w_4 - w_1_omega + q_m = 0  (we are reusing q_m here)\n                 *\n                 * 5. q_arith > 3: The product of w_1 and w_2 is scaled by (q_arith - 3), while the w_4_omega term is scaled by (q_arith - 1).\n                 * The equation can be split into two:\n                 *\n                 * (q_arith - 3)* q_m * w_1 * w_ 2 + q_1 * w_1 + q_2 * w_2 + q_3 * w_3 + q_4 * w_4 + q_c + (q_arith - 1) * w_4_omega = 0\n                 * and\n                 * w_1 + w_4 - w_1_omega + q_m = 0\n                 *\n                 * The problem that q_m is used both in both equations can be dealt with by appropriately changing selector values at\n                 * the next gate. Then we can treat (q_arith - 1) as a simulated q_6 selector and scale q_m to handle (q_arith - 3) at\n                 * product.\n                 */\n\n                let w1q1 := mulmod(mload(W1_EVAL_LOC), mload(Q1_EVAL_LOC), p)\n                let w2q2 := mulmod(mload(W2_EVAL_LOC), mload(Q2_EVAL_LOC), p)\n                let w3q3 := mulmod(mload(W3_EVAL_LOC), mload(Q3_EVAL_LOC), p)\n                let w4q3 := mulmod(mload(W4_EVAL_LOC), mload(Q4_EVAL_LOC), p)\n\n                // @todo - Add a explicit test that hits QARITH == 3\n                // w1w2qm := (w_1 . w_2 . q_m . (QARITH_EVAL_LOC - 3)) / 2\n                let w1w2qm :=\n                    mulmod(\n                        mulmod(\n                            mulmod(mulmod(mload(W1_EVAL_LOC), mload(W2_EVAL_LOC), p), mload(QM_EVAL_LOC), p),\n                            addmod(mload(QARITH_EVAL_LOC), sub(p, 3), p),\n                            p\n                        ),\n                        NEGATIVE_INVERSE_OF_2_MODULO_P,\n                        p\n                    )\n\n                // (w_1 . w_2 . q_m . (q_arith - 3)) / -2) + (w_1 . q_1) + (w_2 . q_2) + (w_3 . q_3) + (w_4 . q_4) + q_c\n                let identity :=\n                    addmod(\n                        mload(QC_EVAL_LOC), addmod(w4q3, addmod(w3q3, addmod(w2q2, addmod(w1q1, w1w2qm, p), p), p), p), p\n                    )\n\n                // if q_arith == 3 we evaluate an additional mini addition gate (on top of the regular one), where:\n                // w_1 + w_4 - w_1_omega + q_m = 0\n                // we use this gate to save an addition gate when adding or subtracting non-native field elements\n                // α * (q_arith - 2) * (w_1 + w_4 - w_1_omega + q_m)\n                let extra_small_addition_gate_identity :=\n                    mulmod(\n                        mload(C_ALPHA_LOC),\n                        mulmod(\n                            addmod(mload(QARITH_EVAL_LOC), sub(p, 2), p),\n                            addmod(\n                                mload(QM_EVAL_LOC),\n                                addmod(\n                                    sub(p, mload(W1_OMEGA_EVAL_LOC)), addmod(mload(W1_EVAL_LOC), mload(W4_EVAL_LOC), p), p\n                                ),\n                                p\n                            ),\n                            p\n                        ),\n                        p\n                    )\n\n                // if q_arith == 2 OR q_arith == 3 we add the 4th wire of the NEXT gate into the arithmetic identity\n                // N.B. if q_arith > 2, this wire value will be scaled by (q_arith - 1) relative to the other gate wires!\n                // alpha_base * q_arith * (identity + (q_arith - 1) * (w_4_omega + extra_small_addition_gate_identity))\n                mstore(\n                    ARITHMETIC_IDENTITY,\n                    mulmod(\n                        mload(C_ALPHA_BASE_LOC),\n                        mulmod(\n                            mload(QARITH_EVAL_LOC),\n                            addmod(\n                                identity,\n                                mulmod(\n                                    addmod(mload(QARITH_EVAL_LOC), sub(p, 1), p),\n                                    addmod(mload(W4_OMEGA_EVAL_LOC), extra_small_addition_gate_identity, p),\n                                    p\n                                ),\n                                p\n                            ),\n                            p\n                        ),\n                        p\n                    )\n                )\n\n                // update alpha\n                mstore(C_ALPHA_BASE_LOC, mulmod(mload(C_ALPHA_BASE_LOC), mload(C_ALPHA_SQR_LOC), p))\n            }\n\n            /**\n             * COMPUTE GENPERMSORT WIDGET EVALUATION\n             */\n            {\n                /**\n                 * D1 = (w2 - w1)\n                 * D2 = (w3 - w2)\n                 * D3 = (w4 - w3)\n                 * D4 = (w1_omega - w4)\n                 *\n                 * α_a = alpha_base\n                 * α_b = alpha_base * α\n                 * α_c = alpha_base * α^2\n                 * α_d = alpha_base * α^3\n                 *\n                 * range_accumulator = (\n                 *   D1(D1 - 1)(D1 - 2)(D1 - 3).α_a +\n                 *   D2(D2 - 1)(D2 - 2)(D2 - 3).α_b +\n                 *   D3(D3 - 1)(D3 - 2)(D3 - 3).α_c +\n                 *   D4(D4 - 1)(D4 - 2)(D4 - 3).α_d +\n                 * ) . q_sort\n                 */\n                let minus_two := sub(p, 2)\n                let minus_three := sub(p, 3)\n                let d1 := addmod(mload(W2_EVAL_LOC), sub(p, mload(W1_EVAL_LOC)), p)\n                let d2 := addmod(mload(W3_EVAL_LOC), sub(p, mload(W2_EVAL_LOC)), p)\n                let d3 := addmod(mload(W4_EVAL_LOC), sub(p, mload(W3_EVAL_LOC)), p)\n                let d4 := addmod(mload(W1_OMEGA_EVAL_LOC), sub(p, mload(W4_EVAL_LOC)), p)\n\n                let range_accumulator :=\n                    mulmod(\n                        mulmod(\n                            mulmod(addmod(mulmod(d1, d1, p), sub(p, d1), p), addmod(d1, minus_two, p), p),\n                            addmod(d1, minus_three, p),\n                            p\n                        ),\n                        mload(C_ALPHA_BASE_LOC),\n                        p\n                    )\n                range_accumulator :=\n                    addmod(\n                        range_accumulator,\n                        mulmod(\n                            mulmod(\n                                mulmod(addmod(mulmod(d2, d2, p), sub(p, d2), p), addmod(d2, minus_two, p), p),\n                                addmod(d2, minus_three, p),\n                                p\n                            ),\n                            mulmod(mload(C_ALPHA_BASE_LOC), mload(C_ALPHA_LOC), p),\n                            p\n                        ),\n                        p\n                    )\n                range_accumulator :=\n                    addmod(\n                        range_accumulator,\n                        mulmod(\n                            mulmod(\n                                mulmod(addmod(mulmod(d3, d3, p), sub(p, d3), p), addmod(d3, minus_two, p), p),\n                                addmod(d3, minus_three, p),\n                                p\n                            ),\n                            mulmod(mload(C_ALPHA_BASE_LOC), mload(C_ALPHA_SQR_LOC), p),\n                            p\n                        ),\n                        p\n                    )\n                range_accumulator :=\n                    addmod(\n                        range_accumulator,\n                        mulmod(\n                            mulmod(\n                                mulmod(addmod(mulmod(d4, d4, p), sub(p, d4), p), addmod(d4, minus_two, p), p),\n                                addmod(d4, minus_three, p),\n                                p\n                            ),\n                            mulmod(mload(C_ALPHA_BASE_LOC), mload(C_ALPHA_CUBE_LOC), p),\n                            p\n                        ),\n                        p\n                    )\n                range_accumulator := mulmod(range_accumulator, mload(QSORT_EVAL_LOC), p)\n\n                mstore(SORT_IDENTITY, range_accumulator)\n\n                // update alpha\n                mstore(C_ALPHA_BASE_LOC, mulmod(mload(C_ALPHA_BASE_LOC), mload(C_ALPHA_QUAD_LOC), p))\n            }\n\n            /**\n             * COMPUTE ELLIPTIC WIDGET EVALUATION\n             */\n            {\n                /**\n                 * endo_term = (-x_2) * x_1 * (x_3 * 2 + x_1) * q_beta\n                 * endo_sqr_term = x_2^2\n                 * endo_sqr_term *= (x_3 - x_1)\n                 * endo_sqr_term *= q_beta^2\n                 * leftovers = x_2^2\n                 * leftovers *= x_2\n                 * leftovers += x_1^2 * (x_3 + x_1) @follow-up Invalid comment in BB widget\n                 * leftovers -= (y_2^2 + y_1^2)\n                 * sign_term = y_2 * y_1\n                 * sign_term += sign_term\n                 * sign_term *= q_sign\n                 */\n                // q_elliptic * (x3 + x2 + x1)(x2 - x1)(x2 - x1) - y2^2 - y1^2 + 2(y2y1)*q_sign = 0\n                let x_diff := addmod(mload(X2_EVAL_LOC), sub(p, mload(X1_EVAL_LOC)), p)\n                let y2_sqr := mulmod(mload(Y2_EVAL_LOC), mload(Y2_EVAL_LOC), p)\n                let y1_sqr := mulmod(mload(Y1_EVAL_LOC), mload(Y1_EVAL_LOC), p)\n                let y1y2 := mulmod(mulmod(mload(Y1_EVAL_LOC), mload(Y2_EVAL_LOC), p), mload(QSIGN_LOC), p)\n\n                let x_add_identity :=\n                    addmod(\n                        mulmod(\n                            addmod(mload(X3_EVAL_LOC), addmod(mload(X2_EVAL_LOC), mload(X1_EVAL_LOC), p), p),\n                            mulmod(x_diff, x_diff, p),\n                            p\n                        ),\n                        addmod(\n                            sub(\n                                p,\n                                addmod(y2_sqr, y1_sqr, p)\n                            ),\n                            addmod(y1y2, y1y2, p),\n                            p\n                        ),\n                        p\n                    )\n                x_add_identity :=\n                    mulmod(\n                        mulmod(\n                            x_add_identity,\n                            addmod(\n                                1,\n                                sub(p, mload(QM_EVAL_LOC)),\n                                p\n                            ),\n                            p\n                        ),\n                        mload(C_ALPHA_BASE_LOC),\n                        p\n                    )\n\n                // q_elliptic * (x3 + x2 + x1)(x2 - x1)(x2 - x1) - y2^2 - y1^2 + 2(y2y1)*q_sign = 0\n                let y1_plus_y3 := addmod(\n                    mload(Y1_EVAL_LOC),\n                    mload(Y3_EVAL_LOC),\n                    p\n                )\n                let y_diff := addmod(mulmod(mload(Y2_EVAL_LOC), mload(QSIGN_LOC), p), sub(p, mload(Y1_EVAL_LOC)), p)\n                let y_add_identity :=\n                    addmod(\n                        mulmod(y1_plus_y3, x_diff, p),\n                        mulmod(addmod(mload(X3_EVAL_LOC), sub(p, mload(X1_EVAL_LOC)), p), y_diff, p),\n                        p\n                    )\n                y_add_identity :=\n                    mulmod(\n                        mulmod(y_add_identity, addmod(1, sub(p, mload(QM_EVAL_LOC)), p), p),\n                        mulmod(mload(C_ALPHA_BASE_LOC), mload(C_ALPHA_LOC), p),\n                        p\n                    )\n\n                // ELLIPTIC_IDENTITY = (x_identity + y_identity) * Q_ELLIPTIC_EVAL\n                mstore(\n                    ELLIPTIC_IDENTITY, mulmod(addmod(x_add_identity, y_add_identity, p), mload(QELLIPTIC_EVAL_LOC), p)\n                )\n            }\n            {\n                /**\n                 * x_pow_4 = (y_1_sqr - curve_b) * x_1;\n                 * y_1_sqr_mul_4 = y_1_sqr + y_1_sqr;\n                 * y_1_sqr_mul_4 += y_1_sqr_mul_4;\n                 * x_1_pow_4_mul_9 = x_pow_4;\n                 * x_1_pow_4_mul_9 += x_1_pow_4_mul_9;\n                 * x_1_pow_4_mul_9 += x_1_pow_4_mul_9;\n                 * x_1_pow_4_mul_9 += x_1_pow_4_mul_9;\n                 * x_1_pow_4_mul_9 += x_pow_4;\n                 * x_1_sqr_mul_3 = x_1_sqr + x_1_sqr + x_1_sqr;\n                 * x_double_identity = (x_3 + x_1 + x_1) * y_1_sqr_mul_4 - x_1_pow_4_mul_9;\n                 * y_double_identity = x_1_sqr_mul_3 * (x_1 - x_3) - (y_1 + y_1) * (y_1 + y_3);\n                 */\n                // (x3 + x1 + x1) (4y1*y1) - 9 * x1 * x1 * x1 * x1 = 0\n                let x1_sqr := mulmod(mload(X1_EVAL_LOC), mload(X1_EVAL_LOC), p)\n                let y1_sqr := mulmod(mload(Y1_EVAL_LOC), mload(Y1_EVAL_LOC), p)\n                let x_pow_4 := mulmod(addmod(y1_sqr, GRUMPKIN_CURVE_B_PARAMETER_NEGATED, p), mload(X1_EVAL_LOC), p)\n                let y1_sqr_mul_4 := mulmod(y1_sqr, 4, p)\n                let x1_pow_4_mul_9 := mulmod(x_pow_4, 9, p)\n                let x1_sqr_mul_3 := mulmod(x1_sqr, 3, p)\n                let x_double_identity :=\n                    addmod(\n                        mulmod(\n                            addmod(mload(X3_EVAL_LOC), addmod(mload(X1_EVAL_LOC), mload(X1_EVAL_LOC), p), p),\n                            y1_sqr_mul_4,\n                            p\n                        ),\n                        sub(p, x1_pow_4_mul_9),\n                        p\n                    )\n                // (y1 + y1) (2y1) - (3 * x1 * x1)(x1 - x3) = 0\n                let y_double_identity :=\n                    addmod(\n                        mulmod(x1_sqr_mul_3, addmod(mload(X1_EVAL_LOC), sub(p, mload(X3_EVAL_LOC)), p), p),\n                        sub(\n                            p,\n                            mulmod(\n                                addmod(mload(Y1_EVAL_LOC), mload(Y1_EVAL_LOC), p),\n                                addmod(mload(Y1_EVAL_LOC), mload(Y3_EVAL_LOC), p),\n                                p\n                            )\n                        ),\n                        p\n                    )\n                x_double_identity := mulmod(x_double_identity, mload(C_ALPHA_BASE_LOC), p)\n                y_double_identity :=\n                    mulmod(y_double_identity, mulmod(mload(C_ALPHA_BASE_LOC), mload(C_ALPHA_LOC), p), p)\n                x_double_identity := mulmod(x_double_identity, mload(QM_EVAL_LOC), p)\n                y_double_identity := mulmod(y_double_identity, mload(QM_EVAL_LOC), p)\n                // ELLIPTIC_IDENTITY += (x_double_identity + y_double_identity) * Q_DOUBLE_EVAL\n                mstore(\n                    ELLIPTIC_IDENTITY,\n                    addmod(\n                        mload(ELLIPTIC_IDENTITY),\n                        mulmod(addmod(x_double_identity, y_double_identity, p), mload(QELLIPTIC_EVAL_LOC), p),\n                        p\n                    )\n                )\n\n                // update alpha\n                mstore(C_ALPHA_BASE_LOC, mulmod(mload(C_ALPHA_BASE_LOC), mload(C_ALPHA_QUAD_LOC), p))\n            }\n\n            /**\n             * COMPUTE AUXILIARY WIDGET EVALUATION\n             */\n            {\n                {\n                    /**\n                     * Non native field arithmetic gate 2\n                     *             _                                                                               _\n                     *            /   _                   _                               _       14                \\\n                     * q_2 . q_4 |   (w_1 . w_2) + (w_1 . w_2) + (w_1 . w_4 + w_2 . w_3 - w_3) . 2    - w_3 - w_4   |\n                     *            \\_                                                                               _/\n                     *\n                     * limb_subproduct = w_1 . w_2_omega + w_1_omega . w_2\n                     * non_native_field_gate_2 = w_1 * w_4 + w_4 * w_3 - w_3_omega\n                     * non_native_field_gate_2 = non_native_field_gate_2 * limb_size\n                     * non_native_field_gate_2 -= w_4_omega\n                     * non_native_field_gate_2 += limb_subproduct\n                     * non_native_field_gate_2 *= q_4\n                     * limb_subproduct *= limb_size\n                     * limb_subproduct += w_1_omega * w_2_omega\n                     * non_native_field_gate_1 = (limb_subproduct + w_3 + w_4) * q_3\n                     * non_native_field_gate_3 = (limb_subproduct + w_4 - (w_3_omega + w_4_omega)) * q_m\n                     * non_native_field_identity = (non_native_field_gate_1 + non_native_field_gate_2 + non_native_field_gate_3) * q_2\n                     */\n\n                    let limb_subproduct :=\n                        addmod(\n                            mulmod(mload(W1_EVAL_LOC), mload(W2_OMEGA_EVAL_LOC), p),\n                            mulmod(mload(W1_OMEGA_EVAL_LOC), mload(W2_EVAL_LOC), p),\n                            p\n                        )\n\n                    let non_native_field_gate_2 :=\n                        addmod(\n                            addmod(\n                                mulmod(mload(W1_EVAL_LOC), mload(W4_EVAL_LOC), p),\n                                mulmod(mload(W2_EVAL_LOC), mload(W3_EVAL_LOC), p),\n                                p\n                            ),\n                            sub(p, mload(W3_OMEGA_EVAL_LOC)),\n                            p\n                        )\n                    non_native_field_gate_2 := mulmod(non_native_field_gate_2, LIMB_SIZE, p)\n                    non_native_field_gate_2 := addmod(non_native_field_gate_2, sub(p, mload(W4_OMEGA_EVAL_LOC)), p)\n                    non_native_field_gate_2 := addmod(non_native_field_gate_2, limb_subproduct, p)\n                    non_native_field_gate_2 := mulmod(non_native_field_gate_2, mload(Q4_EVAL_LOC), p)\n                    limb_subproduct := mulmod(limb_subproduct, LIMB_SIZE, p)\n                    limb_subproduct :=\n                        addmod(limb_subproduct, mulmod(mload(W1_OMEGA_EVAL_LOC), mload(W2_OMEGA_EVAL_LOC), p), p)\n                    let non_native_field_gate_1 :=\n                        mulmod(\n                            addmod(limb_subproduct, sub(p, addmod(mload(W3_EVAL_LOC), mload(W4_EVAL_LOC), p)), p),\n                            mload(Q3_EVAL_LOC),\n                            p\n                        )\n                    let non_native_field_gate_3 :=\n                        mulmod(\n                            addmod(\n                                addmod(limb_subproduct, mload(W4_EVAL_LOC), p),\n                                sub(p, addmod(mload(W3_OMEGA_EVAL_LOC), mload(W4_OMEGA_EVAL_LOC), p)),\n                                p\n                            ),\n                            mload(QM_EVAL_LOC),\n                            p\n                        )\n                    let non_native_field_identity :=\n                        mulmod(\n                            addmod(addmod(non_native_field_gate_1, non_native_field_gate_2, p), non_native_field_gate_3, p),\n                            mload(Q2_EVAL_LOC),\n                            p\n                        )\n\n                    mstore(AUX_NON_NATIVE_FIELD_EVALUATION, non_native_field_identity)\n                }\n\n                {\n                    /**\n                     * limb_accumulator_1 = w_2_omega;\n                     * limb_accumulator_1 *= SUBLIMB_SHIFT;\n                     * limb_accumulator_1 += w_1_omega;\n                     * limb_accumulator_1 *= SUBLIMB_SHIFT;\n                     * limb_accumulator_1 += w_3;\n                     * limb_accumulator_1 *= SUBLIMB_SHIFT;\n                     * limb_accumulator_1 += w_2;\n                     * limb_accumulator_1 *= SUBLIMB_SHIFT;\n                     * limb_accumulator_1 += w_1;\n                     * limb_accumulator_1 -= w_4;\n                     * limb_accumulator_1 *= q_4;\n                     */\n                    let limb_accumulator_1 := mulmod(mload(W2_OMEGA_EVAL_LOC), SUBLIMB_SHIFT, p)\n                    limb_accumulator_1 := addmod(limb_accumulator_1, mload(W1_OMEGA_EVAL_LOC), p)\n                    limb_accumulator_1 := mulmod(limb_accumulator_1, SUBLIMB_SHIFT, p)\n                    limb_accumulator_1 := addmod(limb_accumulator_1, mload(W3_EVAL_LOC), p)\n                    limb_accumulator_1 := mulmod(limb_accumulator_1, SUBLIMB_SHIFT, p)\n                    limb_accumulator_1 := addmod(limb_accumulator_1, mload(W2_EVAL_LOC), p)\n                    limb_accumulator_1 := mulmod(limb_accumulator_1, SUBLIMB_SHIFT, p)\n                    limb_accumulator_1 := addmod(limb_accumulator_1, mload(W1_EVAL_LOC), p)\n                    limb_accumulator_1 := addmod(limb_accumulator_1, sub(p, mload(W4_EVAL_LOC)), p)\n                    limb_accumulator_1 := mulmod(limb_accumulator_1, mload(Q4_EVAL_LOC), p)\n\n                    /**\n                     * limb_accumulator_2 = w_3_omega;\n                     * limb_accumulator_2 *= SUBLIMB_SHIFT;\n                     * limb_accumulator_2 += w_2_omega;\n                     * limb_accumulator_2 *= SUBLIMB_SHIFT;\n                     * limb_accumulator_2 += w_1_omega;\n                     * limb_accumulator_2 *= SUBLIMB_SHIFT;\n                     * limb_accumulator_2 += w_4;\n                     * limb_accumulator_2 *= SUBLIMB_SHIFT;\n                     * limb_accumulator_2 += w_3;\n                     * limb_accumulator_2 -= w_4_omega;\n                     * limb_accumulator_2 *= q_m;\n                     */\n                    let limb_accumulator_2 := mulmod(mload(W3_OMEGA_EVAL_LOC), SUBLIMB_SHIFT, p)\n                    limb_accumulator_2 := addmod(limb_accumulator_2, mload(W2_OMEGA_EVAL_LOC), p)\n                    limb_accumulator_2 := mulmod(limb_accumulator_2, SUBLIMB_SHIFT, p)\n                    limb_accumulator_2 := addmod(limb_accumulator_2, mload(W1_OMEGA_EVAL_LOC), p)\n                    limb_accumulator_2 := mulmod(limb_accumulator_2, SUBLIMB_SHIFT, p)\n                    limb_accumulator_2 := addmod(limb_accumulator_2, mload(W4_EVAL_LOC), p)\n                    limb_accumulator_2 := mulmod(limb_accumulator_2, SUBLIMB_SHIFT, p)\n                    limb_accumulator_2 := addmod(limb_accumulator_2, mload(W3_EVAL_LOC), p)\n                    limb_accumulator_2 := addmod(limb_accumulator_2, sub(p, mload(W4_OMEGA_EVAL_LOC)), p)\n                    limb_accumulator_2 := mulmod(limb_accumulator_2, mload(QM_EVAL_LOC), p)\n\n                    mstore(\n                        AUX_LIMB_ACCUMULATOR_EVALUATION,\n                        mulmod(addmod(limb_accumulator_1, limb_accumulator_2, p), mload(Q3_EVAL_LOC), p)\n                    )\n                }\n\n                {\n                    /**\n                     * memory_record_check = w_3;\n                     * memory_record_check *= eta;\n                     * memory_record_check += w_2;\n                     * memory_record_check *= eta;\n                     * memory_record_check += w_1;\n                     * memory_record_check *= eta;\n                     * memory_record_check += q_c;\n                     *\n                     * partial_record_check = memory_record_check;\n                     *\n                     * memory_record_check -= w_4;\n                     */\n\n                    let memory_record_check := mulmod(mload(W3_EVAL_LOC), mload(C_ETA_LOC), p)\n                    memory_record_check := addmod(memory_record_check, mload(W2_EVAL_LOC), p)\n                    memory_record_check := mulmod(memory_record_check, mload(C_ETA_LOC), p)\n                    memory_record_check := addmod(memory_record_check, mload(W1_EVAL_LOC), p)\n                    memory_record_check := mulmod(memory_record_check, mload(C_ETA_LOC), p)\n                    memory_record_check := addmod(memory_record_check, mload(QC_EVAL_LOC), p)\n\n                    let partial_record_check := memory_record_check\n                    memory_record_check := addmod(memory_record_check, sub(p, mload(W4_EVAL_LOC)), p)\n\n                    mstore(AUX_MEMORY_EVALUATION, memory_record_check)\n\n                    // index_delta = w_1_omega - w_1\n                    let index_delta := addmod(mload(W1_OMEGA_EVAL_LOC), sub(p, mload(W1_EVAL_LOC)), p)\n                    // record_delta = w_4_omega - w_4\n                    let record_delta := addmod(mload(W4_OMEGA_EVAL_LOC), sub(p, mload(W4_EVAL_LOC)), p)\n                    // index_is_monotonically_increasing = index_delta * (index_delta - 1)\n                    let index_is_monotonically_increasing := mulmod(index_delta, addmod(index_delta, sub(p, 1), p), p)\n\n                    // adjacent_values_match_if_adjacent_indices_match = record_delta * (1 - index_delta)\n                    let adjacent_values_match_if_adjacent_indices_match :=\n                        mulmod(record_delta, addmod(1, sub(p, index_delta), p), p)\n\n                    // AUX_ROM_CONSISTENCY_EVALUATION = ((adjacent_values_match_if_adjacent_indices_match * alpha) + index_is_monotonically_increasing) * alpha + partial_record_check\n                    mstore(\n                        AUX_ROM_CONSISTENCY_EVALUATION,\n                        addmod(\n                            mulmod(\n                                addmod(\n                                    mulmod(adjacent_values_match_if_adjacent_indices_match, mload(C_ALPHA_LOC), p),\n                                    index_is_monotonically_increasing,\n                                    p\n                                ),\n                                mload(C_ALPHA_LOC),\n                                p\n                            ),\n                            memory_record_check,\n                            p\n                        )\n                    )\n\n                    {\n                        /**\n                         * next_gate_access_type = w_3_omega;\n                         * next_gate_access_type *= eta;\n                         * next_gate_access_type += w_2_omega;\n                         * next_gate_access_type *= eta;\n                         * next_gate_access_type += w_1_omega;\n                         * next_gate_access_type *= eta;\n                         * next_gate_access_type = w_4_omega - next_gate_access_type;\n                         */\n                        let next_gate_access_type := mulmod(mload(W3_OMEGA_EVAL_LOC), mload(C_ETA_LOC), p)\n                        next_gate_access_type := addmod(next_gate_access_type, mload(W2_OMEGA_EVAL_LOC), p)\n                        next_gate_access_type := mulmod(next_gate_access_type, mload(C_ETA_LOC), p)\n                        next_gate_access_type := addmod(next_gate_access_type, mload(W1_OMEGA_EVAL_LOC), p)\n                        next_gate_access_type := mulmod(next_gate_access_type, mload(C_ETA_LOC), p)\n                        next_gate_access_type := addmod(mload(W4_OMEGA_EVAL_LOC), sub(p, next_gate_access_type), p)\n\n                        // value_delta = w_3_omega - w_3\n                        let value_delta := addmod(mload(W3_OMEGA_EVAL_LOC), sub(p, mload(W3_EVAL_LOC)), p)\n                        //  adjacent_values_match_if_adjacent_indices_match_and_next_access_is_a_read_operation = (1 - index_delta) * value_delta * (1 - next_gate_access_type);\n\n                        let adjacent_values_match_if_adjacent_indices_match_and_next_access_is_a_read_operation :=\n                            mulmod(\n                                addmod(1, sub(p, index_delta), p),\n                                mulmod(value_delta, addmod(1, sub(p, next_gate_access_type), p), p),\n                                p\n                            )\n\n                        // AUX_RAM_CONSISTENCY_EVALUATION\n\n                        /**\n                         * access_type = w_4 - partial_record_check\n                         * access_check = access_type^2 - access_type\n                         * next_gate_access_type_is_boolean = next_gate_access_type^2 - next_gate_access_type\n                         * RAM_consistency_check_identity = adjacent_values_match_if_adjacent_indices_match_and_next_access_is_a_read_operation;\n                         * RAM_consistency_check_identity *= alpha;\n                         * RAM_consistency_check_identity += index_is_monotonically_increasing;\n                         * RAM_consistency_check_identity *= alpha;\n                         * RAM_consistency_check_identity += next_gate_access_type_is_boolean;\n                         * RAM_consistency_check_identity *= alpha;\n                         * RAM_consistency_check_identity += access_check;\n                         */\n\n                        let access_type := addmod(mload(W4_EVAL_LOC), sub(p, partial_record_check), p)\n                        let access_check := mulmod(access_type, addmod(access_type, sub(p, 1), p), p)\n                        let next_gate_access_type_is_boolean :=\n                            mulmod(next_gate_access_type, addmod(next_gate_access_type, sub(p, 1), p), p)\n                        let RAM_cci :=\n                            mulmod(\n                                adjacent_values_match_if_adjacent_indices_match_and_next_access_is_a_read_operation,\n                                mload(C_ALPHA_LOC),\n                                p\n                            )\n                        RAM_cci := addmod(RAM_cci, index_is_monotonically_increasing, p)\n                        RAM_cci := mulmod(RAM_cci, mload(C_ALPHA_LOC), p)\n                        RAM_cci := addmod(RAM_cci, next_gate_access_type_is_boolean, p)\n                        RAM_cci := mulmod(RAM_cci, mload(C_ALPHA_LOC), p)\n                        RAM_cci := addmod(RAM_cci, access_check, p)\n\n                        mstore(AUX_RAM_CONSISTENCY_EVALUATION, RAM_cci)\n                    }\n\n                    {\n                        // timestamp_delta = w_2_omega - w_2\n                        let timestamp_delta := addmod(mload(W2_OMEGA_EVAL_LOC), sub(p, mload(W2_EVAL_LOC)), p)\n\n                        // RAM_timestamp_check_identity = (1 - index_delta) * timestamp_delta - w_3\n                        let RAM_timestamp_check_identity :=\n                            addmod(\n                                mulmod(timestamp_delta, addmod(1, sub(p, index_delta), p), p), sub(p, mload(W3_EVAL_LOC)), p\n                            )\n\n                        /**\n                         * memory_identity = ROM_consistency_check_identity * q_2;\n                         * memory_identity += RAM_timestamp_check_identity * q_4;\n                         * memory_identity += memory_record_check * q_m;\n                         * memory_identity *= q_1;\n                         * memory_identity += (RAM_consistency_check_identity * q_arith);\n                         *\n                         * auxiliary_identity = memory_identity + non_native_field_identity + limb_accumulator_identity;\n                         * auxiliary_identity *= q_aux;\n                         * auxiliary_identity *= alpha_base;\n                         */\n                        let memory_identity := mulmod(mload(AUX_ROM_CONSISTENCY_EVALUATION), mload(Q2_EVAL_LOC), p)\n                        memory_identity :=\n                            addmod(memory_identity, mulmod(RAM_timestamp_check_identity, mload(Q4_EVAL_LOC), p), p)\n                        memory_identity :=\n                            addmod(memory_identity, mulmod(mload(AUX_MEMORY_EVALUATION), mload(QM_EVAL_LOC), p), p)\n                        memory_identity := mulmod(memory_identity, mload(Q1_EVAL_LOC), p)\n                        memory_identity :=\n                            addmod(\n                                memory_identity, mulmod(mload(AUX_RAM_CONSISTENCY_EVALUATION), mload(QARITH_EVAL_LOC), p), p\n                            )\n\n                        let auxiliary_identity := addmod(memory_identity, mload(AUX_NON_NATIVE_FIELD_EVALUATION), p)\n                        auxiliary_identity := addmod(auxiliary_identity, mload(AUX_LIMB_ACCUMULATOR_EVALUATION), p)\n                        auxiliary_identity := mulmod(auxiliary_identity, mload(QAUX_EVAL_LOC), p)\n                        auxiliary_identity := mulmod(auxiliary_identity, mload(C_ALPHA_BASE_LOC), p)\n\n                        mstore(AUX_IDENTITY, auxiliary_identity)\n\n                        // update alpha\n                        mstore(C_ALPHA_BASE_LOC, mulmod(mload(C_ALPHA_BASE_LOC), mload(C_ALPHA_CUBE_LOC), p))\n                    }\n                }\n            }\n\n            {\n                /**\n                 * quotient = ARITHMETIC_IDENTITY\n                 * quotient += PERMUTATION_IDENTITY\n                 * quotient += PLOOKUP_IDENTITY\n                 * quotient += SORT_IDENTITY\n                 * quotient += ELLIPTIC_IDENTITY\n                 * quotient += AUX_IDENTITY\n                 * quotient *= ZERO_POLY_INVERSE\n                 */\n                mstore(\n                    QUOTIENT_EVAL_LOC,\n                    mulmod(\n                        addmod(\n                            addmod(\n                                addmod(\n                                    addmod(\n                                        addmod(mload(PERMUTATION_IDENTITY), mload(PLOOKUP_IDENTITY), p),\n                                        mload(ARITHMETIC_IDENTITY),\n                                        p\n                                    ),\n                                    mload(SORT_IDENTITY),\n                                    p\n                                ),\n                                mload(ELLIPTIC_IDENTITY),\n                                p\n                            ),\n                            mload(AUX_IDENTITY),\n                            p\n                        ),\n                        mload(ZERO_POLY_INVERSE_LOC),\n                        p\n                    )\n                )\n            }\n\n            /**\n             * GENERATE NU AND SEPARATOR CHALLENGES\n             */\n            {\n                let current_challenge := mload(C_CURRENT_LOC)\n                // get a calldata pointer that points to the start of the data we want to copy\n                let calldata_ptr := add(calldataload(0x04), 0x24)\n\n                calldata_ptr := add(calldata_ptr, NU_CALLDATA_SKIP_LENGTH)\n\n                mstore(NU_CHALLENGE_INPUT_LOC_A, current_challenge)\n                mstore(NU_CHALLENGE_INPUT_LOC_B, mload(QUOTIENT_EVAL_LOC))\n                calldatacopy(NU_CHALLENGE_INPUT_LOC_C, calldata_ptr, NU_INPUT_LENGTH)\n\n                // hash length = (0x20 + num field elements), we include the previous challenge in the hash\n                let challenge := keccak256(NU_CHALLENGE_INPUT_LOC_A, add(NU_INPUT_LENGTH, 0x40))\n\n                mstore(C_V0_LOC, mod(challenge, p))\n                // We need THIRTY-ONE independent nu challenges!\n                mstore(0x00, challenge)\n                mstore8(0x20, 0x01)\n                mstore(C_V1_LOC, mod(keccak256(0x00, 0x21), p))\n                mstore8(0x20, 0x02)\n                mstore(C_V2_LOC, mod(keccak256(0x00, 0x21), p))\n                mstore8(0x20, 0x03)\n                mstore(C_V3_LOC, mod(keccak256(0x00, 0x21), p))\n                mstore8(0x20, 0x04)\n                mstore(C_V4_LOC, mod(keccak256(0x00, 0x21), p))\n                mstore8(0x20, 0x05)\n                mstore(C_V5_LOC, mod(keccak256(0x00, 0x21), p))\n                mstore8(0x20, 0x06)\n                mstore(C_V6_LOC, mod(keccak256(0x00, 0x21), p))\n                mstore8(0x20, 0x07)\n                mstore(C_V7_LOC, mod(keccak256(0x00, 0x21), p))\n                mstore8(0x20, 0x08)\n                mstore(C_V8_LOC, mod(keccak256(0x00, 0x21), p))\n                mstore8(0x20, 0x09)\n                mstore(C_V9_LOC, mod(keccak256(0x00, 0x21), p))\n                mstore8(0x20, 0x0a)\n                mstore(C_V10_LOC, mod(keccak256(0x00, 0x21), p))\n                mstore8(0x20, 0x0b)\n                mstore(C_V11_LOC, mod(keccak256(0x00, 0x21), p))\n                mstore8(0x20, 0x0c)\n                mstore(C_V12_LOC, mod(keccak256(0x00, 0x21), p))\n                mstore8(0x20, 0x0d)\n                mstore(C_V13_LOC, mod(keccak256(0x00, 0x21), p))\n                mstore8(0x20, 0x0e)\n                mstore(C_V14_LOC, mod(keccak256(0x00, 0x21), p))\n                mstore8(0x20, 0x0f)\n                mstore(C_V15_LOC, mod(keccak256(0x00, 0x21), p))\n                mstore8(0x20, 0x10)\n                mstore(C_V16_LOC, mod(keccak256(0x00, 0x21), p))\n                mstore8(0x20, 0x11)\n                mstore(C_V17_LOC, mod(keccak256(0x00, 0x21), p))\n                mstore8(0x20, 0x12)\n                mstore(C_V18_LOC, mod(keccak256(0x00, 0x21), p))\n                mstore8(0x20, 0x13)\n                mstore(C_V19_LOC, mod(keccak256(0x00, 0x21), p))\n                mstore8(0x20, 0x14)\n                mstore(C_V20_LOC, mod(keccak256(0x00, 0x21), p))\n                mstore8(0x20, 0x15)\n                mstore(C_V21_LOC, mod(keccak256(0x00, 0x21), p))\n                mstore8(0x20, 0x16)\n                mstore(C_V22_LOC, mod(keccak256(0x00, 0x21), p))\n                mstore8(0x20, 0x17)\n                mstore(C_V23_LOC, mod(keccak256(0x00, 0x21), p))\n                mstore8(0x20, 0x18)\n                mstore(C_V24_LOC, mod(keccak256(0x00, 0x21), p))\n                mstore8(0x20, 0x19)\n                mstore(C_V25_LOC, mod(keccak256(0x00, 0x21), p))\n                mstore8(0x20, 0x1a)\n                mstore(C_V26_LOC, mod(keccak256(0x00, 0x21), p))\n                mstore8(0x20, 0x1b)\n                mstore(C_V27_LOC, mod(keccak256(0x00, 0x21), p))\n                mstore8(0x20, 0x1c)\n                mstore(C_V28_LOC, mod(keccak256(0x00, 0x21), p))\n                mstore8(0x20, 0x1d)\n                mstore(C_V29_LOC, mod(keccak256(0x00, 0x21), p))\n\n                // @follow-up - Why are both v29 and v30 using appending 0x1d to the prior challenge and hashing, should it not change?\n                mstore8(0x20, 0x1d)\n                challenge := keccak256(0x00, 0x21)\n                mstore(C_V30_LOC, mod(challenge, p))\n\n                // separator\n                mstore(0x00, challenge)\n                mstore(0x20, mload(PI_Z_Y_LOC))\n                mstore(0x40, mload(PI_Z_X_LOC))\n                mstore(0x60, mload(PI_Z_OMEGA_Y_LOC))\n                mstore(0x80, mload(PI_Z_OMEGA_X_LOC))\n\n                mstore(C_U_LOC, mod(keccak256(0x00, 0xa0), p))\n            }\n\n            let success := 0\n            // VALIDATE T1\n            {\n                let x := mload(T1_X_LOC)\n                let y := mload(T1_Y_LOC)\n                let xx := mulmod(x, x, q)\n                // validate on curve\n                if iszero(eq(mulmod(y, y, q), addmod(mulmod(x, xx, q), 3, q))) {\n                    mstore(0x0, POINT_NOT_ON_CURVE_SELECTOR)\n                    revert(0x00, 0x04)\n                }\n                mstore(ACCUMULATOR_X_LOC, x)\n                mstore(add(ACCUMULATOR_X_LOC, 0x20), y)\n            }\n            // VALIDATE T2\n            {\n                let x := mload(T2_X_LOC) // 0x1400\n                let y := mload(T2_Y_LOC) // 0x1420\n                let xx := mulmod(x, x, q)\n                // validate on curve\n                if iszero(eq(mulmod(y, y, q), addmod(mulmod(x, xx, q), 3, q))) {\n                    mstore(0x0, POINT_NOT_ON_CURVE_SELECTOR)\n                    revert(0x00, 0x04)\n                }\n                mstore(0x00, x)\n                mstore(0x20, y)\n            }\n            mstore(0x40, mload(ZETA_POW_N_LOC))\n            // accumulator_2 = [T2].zeta^n\n            success := staticcall(gas(), 7, 0x00, 0x60, ACCUMULATOR2_X_LOC, 0x40)\n            // accumulator = [T1] + accumulator_2\n            success := and(success, staticcall(gas(), 6, ACCUMULATOR_X_LOC, 0x80, ACCUMULATOR_X_LOC, 0x40))\n\n            // VALIDATE T3\n            {\n                let x := mload(T3_X_LOC)\n                let y := mload(T3_Y_LOC)\n                let xx := mulmod(x, x, q)\n                // validate on curve\n                if iszero(eq(mulmod(y, y, q), addmod(mulmod(x, xx, q), 3, q))) {\n                    mstore(0x0, POINT_NOT_ON_CURVE_SELECTOR)\n                    revert(0x00, 0x04)\n                }\n                mstore(0x00, x)\n                mstore(0x20, y)\n            }\n            mstore(0x40, mulmod(mload(ZETA_POW_N_LOC), mload(ZETA_POW_N_LOC), p))\n            // accumulator_2 = [T3].zeta^{2n}\n            success := and(success, staticcall(gas(), 7, 0x00, 0x60, ACCUMULATOR2_X_LOC, 0x40))\n            // accumulator = accumulator + accumulator_2\n            success := and(success, staticcall(gas(), 6, ACCUMULATOR_X_LOC, 0x80, ACCUMULATOR_X_LOC, 0x40))\n\n            // VALIDATE T4\n            {\n                let x := mload(T4_X_LOC)\n                let y := mload(T4_Y_LOC)\n                let xx := mulmod(x, x, q)\n                // validate on curve\n                if iszero(eq(mulmod(y, y, q), addmod(mulmod(x, xx, q), 3, q))) {\n                    mstore(0x0, POINT_NOT_ON_CURVE_SELECTOR)\n                    revert(0x00, 0x04)\n                }\n                mstore(0x00, x)\n                mstore(0x20, y)\n            }\n            mstore(0x40, mulmod(mulmod(mload(ZETA_POW_N_LOC), mload(ZETA_POW_N_LOC), p), mload(ZETA_POW_N_LOC), p))\n            // accumulator_2 = [T4].zeta^{3n}\n            success := and(success, staticcall(gas(), 7, 0x00, 0x60, ACCUMULATOR2_X_LOC, 0x40))\n            // accumulator = accumulator + accumulator_2\n            success := and(success, staticcall(gas(), 6, ACCUMULATOR_X_LOC, 0x80, ACCUMULATOR_X_LOC, 0x40))\n\n            // VALIDATE W1\n            {\n                let x := mload(W1_X_LOC)\n                let y := mload(W1_Y_LOC)\n                let xx := mulmod(x, x, q)\n                // validate on curve\n                if iszero(eq(mulmod(y, y, q), addmod(mulmod(x, xx, q), 3, q))) {\n                    mstore(0x0, POINT_NOT_ON_CURVE_SELECTOR)\n                    revert(0x00, 0x04)\n                }\n                mstore(0x00, x)\n                mstore(0x20, y)\n            }\n            mstore(0x40, mulmod(addmod(mload(C_U_LOC), 0x1, p), mload(C_V0_LOC), p))\n            // accumulator_2 = v0.(u + 1).[W1]\n            success := and(success, staticcall(gas(), 7, 0x00, 0x60, ACCUMULATOR2_X_LOC, 0x40))\n            // accumulator = accumulator + accumulator_2\n            success := and(success, staticcall(gas(), 6, ACCUMULATOR_X_LOC, 0x80, ACCUMULATOR_X_LOC, 0x40))\n\n            // VALIDATE W2\n            {\n                let x := mload(W2_X_LOC)\n                let y := mload(W2_Y_LOC)\n                let xx := mulmod(x, x, q)\n                // validate on curve\n                if iszero(eq(mulmod(y, y, q), addmod(mulmod(x, xx, q), 3, q))) {\n                    mstore(0x0, POINT_NOT_ON_CURVE_SELECTOR)\n                    revert(0x00, 0x04)\n                }\n                mstore(0x00, x)\n                mstore(0x20, y)\n            }\n            mstore(0x40, mulmod(addmod(mload(C_U_LOC), 0x1, p), mload(C_V1_LOC), p))\n            // accumulator_2 = v1.(u + 1).[W2]\n            success := and(success, staticcall(gas(), 7, 0x00, 0x60, ACCUMULATOR2_X_LOC, 0x40))\n            // accumulator = accumulator + accumulator_2\n            success := and(success, staticcall(gas(), 6, ACCUMULATOR_X_LOC, 0x80, ACCUMULATOR_X_LOC, 0x40))\n\n            // VALIDATE W3\n            {\n                let x := mload(W3_X_LOC)\n                let y := mload(W3_Y_LOC)\n                let xx := mulmod(x, x, q)\n                // validate on curve\n                if iszero(eq(mulmod(y, y, q), addmod(mulmod(x, xx, q), 3, q))) {\n                    mstore(0x0, POINT_NOT_ON_CURVE_SELECTOR)\n                    revert(0x00, 0x04)\n                }\n                mstore(0x00, x)\n                mstore(0x20, y)\n            }\n            mstore(0x40, mulmod(addmod(mload(C_U_LOC), 0x1, p), mload(C_V2_LOC), p))\n            // accumulator_2 = v2.(u + 1).[W3]\n            success := and(success, staticcall(gas(), 7, 0x00, 0x60, ACCUMULATOR2_X_LOC, 0x40))\n            // accumulator = accumulator + accumulator_2\n            success := and(success, staticcall(gas(), 6, ACCUMULATOR_X_LOC, 0x80, ACCUMULATOR_X_LOC, 0x40))\n\n            // VALIDATE W4\n            {\n                let x := mload(W4_X_LOC)\n                let y := mload(W4_Y_LOC)\n                let xx := mulmod(x, x, q)\n                // validate on curve\n                if iszero(eq(mulmod(y, y, q), addmod(mulmod(x, xx, q), 3, q))) {\n                    mstore(0x0, POINT_NOT_ON_CURVE_SELECTOR)\n                    revert(0x00, 0x04)\n                }\n                mstore(0x00, x)\n                mstore(0x20, y)\n            }\n            mstore(0x40, mulmod(addmod(mload(C_U_LOC), 0x1, p), mload(C_V3_LOC), p))\n            // accumulator_2 = v3.(u + 1).[W4]\n            success := and(success, staticcall(gas(), 7, 0x00, 0x60, ACCUMULATOR2_X_LOC, 0x40))\n            // accumulator = accumulator + accumulator_2\n            success := and(success, staticcall(gas(), 6, ACCUMULATOR_X_LOC, 0x80, ACCUMULATOR_X_LOC, 0x40))\n\n            // VALIDATE S\n            {\n                let x := mload(S_X_LOC)\n                let y := mload(S_Y_LOC)\n                let xx := mulmod(x, x, q)\n                // validate on curve\n                if iszero(eq(mulmod(y, y, q), addmod(mulmod(x, xx, q), 3, q))) {\n                    mstore(0x0, POINT_NOT_ON_CURVE_SELECTOR)\n                    revert(0x00, 0x04)\n                }\n                mstore(0x00, x)\n                mstore(0x20, y)\n            }\n            mstore(0x40, mulmod(addmod(mload(C_U_LOC), 0x1, p), mload(C_V4_LOC), p))\n            // accumulator_2 = v4.(u + 1).[S]\n            success := and(success, staticcall(gas(), 7, 0x00, 0x60, ACCUMULATOR2_X_LOC, 0x40))\n            // accumulator = accumulator + accumulator_2\n            success := and(success, staticcall(gas(), 6, ACCUMULATOR_X_LOC, 0x80, ACCUMULATOR_X_LOC, 0x40))\n\n            // VALIDATE Z\n            {\n                let x := mload(Z_X_LOC)\n                let y := mload(Z_Y_LOC)\n                let xx := mulmod(x, x, q)\n                // validate on curve\n                if iszero(eq(mulmod(y, y, q), addmod(mulmod(x, xx, q), 3, q))) {\n                    mstore(0x0, POINT_NOT_ON_CURVE_SELECTOR)\n                    revert(0x00, 0x04)\n                }\n                mstore(0x00, x)\n                mstore(0x20, y)\n            }\n            mstore(0x40, mulmod(addmod(mload(C_U_LOC), 0x1, p), mload(C_V5_LOC), p))\n            // accumulator_2 = v5.(u + 1).[Z]\n            success := and(success, staticcall(gas(), 7, 0x00, 0x60, ACCUMULATOR2_X_LOC, 0x40))\n            // accumulator = accumulator + accumulator_2\n            success := and(success, staticcall(gas(), 6, ACCUMULATOR_X_LOC, 0x80, ACCUMULATOR_X_LOC, 0x40))\n\n            // VALIDATE Z_LOOKUP\n            {\n                let x := mload(Z_LOOKUP_X_LOC)\n                let y := mload(Z_LOOKUP_Y_LOC)\n                let xx := mulmod(x, x, q)\n                // validate on curve\n                if iszero(eq(mulmod(y, y, q), addmod(mulmod(x, xx, q), 3, q))) {\n                    mstore(0x0, POINT_NOT_ON_CURVE_SELECTOR)\n                    revert(0x00, 0x04)\n                }\n                mstore(0x00, x)\n                mstore(0x20, y)\n            }\n            mstore(0x40, mulmod(addmod(mload(C_U_LOC), 0x1, p), mload(C_V6_LOC), p))\n            // accumulator_2 = v6.(u + 1).[Z_LOOKUP]\n            success := and(success, staticcall(gas(), 7, 0x00, 0x60, ACCUMULATOR2_X_LOC, 0x40))\n            // accumulator = accumulator + accumulator_2\n            success := and(success, staticcall(gas(), 6, ACCUMULATOR_X_LOC, 0x80, ACCUMULATOR_X_LOC, 0x40))\n\n            // ACCUMULATE Q1\n\n            // Verification key fields verified to be on curve at contract deployment\n            mstore(0x00, mload(Q1_X_LOC))\n            mstore(0x20, mload(Q1_Y_LOC))\n            mstore(0x40, mload(C_V7_LOC))\n            // accumulator_2 = v7.[Q1]\n            success := and(success, staticcall(gas(), 7, 0x00, 0x60, ACCUMULATOR2_X_LOC, 0x40))\n            // accumulator = accumulator + accumulator_2\n            success := and(success, staticcall(gas(), 6, ACCUMULATOR_X_LOC, 0x80, ACCUMULATOR_X_LOC, 0x40))\n\n            // ACCUMULATE Q2\n\n            // Verification key fields verified to be on curve at contract deployment\n            mstore(0x00, mload(Q2_X_LOC))\n            mstore(0x20, mload(Q2_Y_LOC))\n            mstore(0x40, mload(C_V8_LOC))\n            // accumulator_2 = v8.[Q2]\n            success := and(success, staticcall(gas(), 7, 0x00, 0x60, ACCUMULATOR2_X_LOC, 0x40))\n            // accumulator = accumulator + accumulator_2\n            success := and(success, staticcall(gas(), 6, ACCUMULATOR_X_LOC, 0x80, ACCUMULATOR_X_LOC, 0x40))\n\n            // ACCUMULATE Q3\n            \n            // Verification key fields verified to be on curve at contract deployment\n            mstore(0x00, mload(Q3_X_LOC))\n            mstore(0x20, mload(Q3_Y_LOC))\n            mstore(0x40, mload(C_V9_LOC))\n            // accumulator_2 = v9.[Q3]\n            success := and(success, staticcall(gas(), 7, 0x00, 0x60, ACCUMULATOR2_X_LOC, 0x40))\n            // accumulator = accumulator + accumulator_2\n            success := and(success, staticcall(gas(), 6, ACCUMULATOR_X_LOC, 0x80, ACCUMULATOR_X_LOC, 0x40))\n\n            // ACCUMULATE Q4\n            \n            // Verification key fields verified to be on curve at contract deployment\n            mstore(0x00, mload(Q4_X_LOC))\n            mstore(0x20, mload(Q4_Y_LOC))\n            mstore(0x40, mload(C_V10_LOC))\n            // accumulator_2 = v10.[Q4]\n            success := and(success, staticcall(gas(), 7, 0x00, 0x60, ACCUMULATOR2_X_LOC, 0x40))\n            // accumulator = accumulator + accumulator_2\n            success := and(success, staticcall(gas(), 6, ACCUMULATOR_X_LOC, 0x80, ACCUMULATOR_X_LOC, 0x40))\n\n            // ACCUMULATE QM\n            \n            // Verification key fields verified to be on curve at contract deployment\n            mstore(0x00, mload(QM_X_LOC))\n            mstore(0x20, mload(QM_Y_LOC))\n            mstore(0x40, mload(C_V11_LOC))\n            // accumulator_2 = v11.[Q;]\n            success := and(success, staticcall(gas(), 7, 0x00, 0x60, ACCUMULATOR2_X_LOC, 0x40))\n            // accumulator = accumulator + accumulator_2\n            success := and(success, staticcall(gas(), 6, ACCUMULATOR_X_LOC, 0x80, ACCUMULATOR_X_LOC, 0x40))\n\n            // ACCUMULATE QC\n\n            // Verification key fields verified to be on curve at contract deployment\n            mstore(0x00, mload(QC_X_LOC))\n            mstore(0x20, mload(QC_Y_LOC))\n            mstore(0x40, mload(C_V12_LOC))\n            // accumulator_2 = v12.[QC]\n            success := and(success, staticcall(gas(), 7, 0x00, 0x60, ACCUMULATOR2_X_LOC, 0x40))\n            // accumulator = accumulator + accumulator_2\n            success := and(success, staticcall(gas(), 6, ACCUMULATOR_X_LOC, 0x80, ACCUMULATOR_X_LOC, 0x40))\n\n            // ACCUMULATE QARITH\n\n            // Verification key fields verified to be on curve at contract deployment\n            mstore(0x00, mload(QARITH_X_LOC))\n            mstore(0x20, mload(QARITH_Y_LOC))\n            mstore(0x40, mload(C_V13_LOC))\n            // accumulator_2 = v13.[QARITH]\n            success := and(success, staticcall(gas(), 7, 0x00, 0x60, ACCUMULATOR2_X_LOC, 0x40))\n            // accumulator = accumulator + accumulator_2\n            success := and(success, staticcall(gas(), 6, ACCUMULATOR_X_LOC, 0x80, ACCUMULATOR_X_LOC, 0x40))\n\n            // ACCUMULATE QSORT\n\n            // Verification key fields verified to be on curve at contract deployment\n            mstore(0x00, mload(QSORT_X_LOC))\n            mstore(0x20, mload(QSORT_Y_LOC))\n            mstore(0x40, mload(C_V14_LOC))\n            // accumulator_2 = v14.[QSORT]\n            success := and(success, staticcall(gas(), 7, 0x00, 0x60, ACCUMULATOR2_X_LOC, 0x40))\n            // accumulator = accumulator + accumulator_2\n            success := and(success, staticcall(gas(), 6, ACCUMULATOR_X_LOC, 0x80, ACCUMULATOR_X_LOC, 0x40))\n\n            // ACCUMULATE QELLIPTIC\n\n            // Verification key fields verified to be on curve at contract deployment\n            mstore(0x00, mload(QELLIPTIC_X_LOC))\n            mstore(0x20, mload(QELLIPTIC_Y_LOC))\n            mstore(0x40, mload(C_V15_LOC))\n            // accumulator_2 = v15.[QELLIPTIC]\n            success := and(success, staticcall(gas(), 7, 0x00, 0x60, ACCUMULATOR2_X_LOC, 0x40))\n            // accumulator = accumulator + accumulator_2\n            success := and(success, staticcall(gas(), 6, ACCUMULATOR_X_LOC, 0x80, ACCUMULATOR_X_LOC, 0x40))\n\n            // ACCUMULATE QAUX\n\n            // Verification key fields verified to be on curve at contract deployment\n            mstore(0x00, mload(QAUX_X_LOC))\n            mstore(0x20, mload(QAUX_Y_LOC))\n            mstore(0x40, mload(C_V16_LOC))\n            // accumulator_2 = v15.[Q_AUX]\n            success := and(success, staticcall(gas(), 7, 0x00, 0x60, ACCUMULATOR2_X_LOC, 0x40))\n            // accumulator = accumulator + accumulator_2\n            success := and(success, staticcall(gas(), 6, ACCUMULATOR_X_LOC, 0x80, ACCUMULATOR_X_LOC, 0x40))\n\n            // ACCUMULATE SIGMA1\n\n            // Verification key fields verified to be on curve at contract deployment\n            mstore(0x00, mload(SIGMA1_X_LOC))\n            mstore(0x20, mload(SIGMA1_Y_LOC))\n            mstore(0x40, mload(C_V17_LOC))\n            // accumulator_2 = v17.[sigma1]\n            success := and(success, staticcall(gas(), 7, 0x00, 0x60, ACCUMULATOR2_X_LOC, 0x40))\n            // accumulator = accumulator + accumulator_2\n            success := and(success, staticcall(gas(), 6, ACCUMULATOR_X_LOC, 0x80, ACCUMULATOR_X_LOC, 0x40))\n\n            // ACCUMULATE SIGMA2\n\n            // Verification key fields verified to be on curve at contract deployment\n            mstore(0x00, mload(SIGMA2_X_LOC))\n            mstore(0x20, mload(SIGMA2_Y_LOC))\n            mstore(0x40, mload(C_V18_LOC))\n            // accumulator_2 = v18.[sigma2]\n            success := and(success, staticcall(gas(), 7, 0x00, 0x60, ACCUMULATOR2_X_LOC, 0x40))\n            // accumulator = accumulator + accumulator_2\n            success := and(success, staticcall(gas(), 6, ACCUMULATOR_X_LOC, 0x80, ACCUMULATOR_X_LOC, 0x40))\n\n            // ACCUMULATE SIGMA3\n\n            // Verification key fields verified to be on curve at contract deployment\n            mstore(0x00, mload(SIGMA3_X_LOC))\n            mstore(0x20, mload(SIGMA3_Y_LOC))\n            mstore(0x40, mload(C_V19_LOC))\n            // accumulator_2 = v19.[sigma3]\n            success := and(success, staticcall(gas(), 7, 0x00, 0x60, ACCUMULATOR2_X_LOC, 0x40))\n            // accumulator = accumulator + accumulator_2\n            success := and(success, staticcall(gas(), 6, ACCUMULATOR_X_LOC, 0x80, ACCUMULATOR_X_LOC, 0x40))\n\n            // ACCUMULATE SIGMA4\n\n            // Verification key fields verified to be on curve at contract deployment\n            mstore(0x00, mload(SIGMA4_X_LOC))\n            mstore(0x20, mload(SIGMA4_Y_LOC))\n            mstore(0x40, mload(C_V20_LOC))\n            // accumulator_2 = v20.[sigma4]\n            success := and(success, staticcall(gas(), 7, 0x00, 0x60, ACCUMULATOR2_X_LOC, 0x40))\n            // accumulator = accumulator + accumulator_2\n            success := and(success, staticcall(gas(), 6, ACCUMULATOR_X_LOC, 0x80, ACCUMULATOR_X_LOC, 0x40))\n\n            // ACCUMULATE TABLE1\n\n            // Verification key fields verified to be on curve at contract deployment\n            mstore(0x00, mload(TABLE1_X_LOC))\n            mstore(0x20, mload(TABLE1_Y_LOC))\n            mstore(0x40, mulmod(addmod(mload(C_U_LOC), 0x1, p), mload(C_V21_LOC), p))\n            // accumulator_2 = u.[table1]\n            success := and(success, staticcall(gas(), 7, 0x00, 0x60, ACCUMULATOR2_X_LOC, 0x40))\n            // accumulator = accumulator + accumulator_2\n            success := and(success, staticcall(gas(), 6, ACCUMULATOR_X_LOC, 0x80, ACCUMULATOR_X_LOC, 0x40))\n\n            // ACCUMULATE TABLE2\n\n            // Verification key fields verified to be on curve at contract deployment\n            mstore(0x00, mload(TABLE2_X_LOC))\n            mstore(0x20, mload(TABLE2_Y_LOC))\n            mstore(0x40, mulmod(addmod(mload(C_U_LOC), 0x1, p), mload(C_V22_LOC), p))\n            // accumulator_2 = u.[table2]\n            success := and(success, staticcall(gas(), 7, 0x00, 0x60, ACCUMULATOR2_X_LOC, 0x40))\n            // accumulator = accumulator + accumulator_2\n            success := and(success, staticcall(gas(), 6, ACCUMULATOR_X_LOC, 0x80, ACCUMULATOR_X_LOC, 0x40))\n\n            // ACCUMULATE TABLE3\n\n            // Verification key fields verified to be on curve at contract deployment\n            mstore(0x00, mload(TABLE3_X_LOC))\n            mstore(0x20, mload(TABLE3_Y_LOC))\n            mstore(0x40, mulmod(addmod(mload(C_U_LOC), 0x1, p), mload(C_V23_LOC), p))\n            // accumulator_2 = u.[table3]\n            success := and(success, staticcall(gas(), 7, 0x00, 0x60, ACCUMULATOR2_X_LOC, 0x40))\n            // accumulator = accumulator + accumulator_2\n            success := and(success, staticcall(gas(), 6, ACCUMULATOR_X_LOC, 0x80, ACCUMULATOR_X_LOC, 0x40))\n\n            // ACCUMULATE TABLE4\n\n            // Verification key fields verified to be on curve at contract deployment\n            mstore(0x00, mload(TABLE4_X_LOC))\n            mstore(0x20, mload(TABLE4_Y_LOC))\n            mstore(0x40, mulmod(addmod(mload(C_U_LOC), 0x1, p), mload(C_V24_LOC), p))\n            // accumulator_2 = u.[table4]\n            success := and(success, staticcall(gas(), 7, 0x00, 0x60, ACCUMULATOR2_X_LOC, 0x40))\n            // accumulator = accumulator + accumulator_2\n            success := and(success, staticcall(gas(), 6, ACCUMULATOR_X_LOC, 0x80, ACCUMULATOR_X_LOC, 0x40))\n\n            // ACCUMULATE TABLE_TYPE\n\n            // Verification key fields verified to be on curve at contract deployment\n            mstore(0x00, mload(TABLE_TYPE_X_LOC))\n            mstore(0x20, mload(TABLE_TYPE_Y_LOC))\n            mstore(0x40, mload(C_V25_LOC))\n            // accumulator_2 = v25.[TableType]\n            success := and(success, staticcall(gas(), 7, 0x00, 0x60, ACCUMULATOR2_X_LOC, 0x40))\n            // accumulator = accumulator + accumulator_2\n            success := and(success, staticcall(gas(), 6, ACCUMULATOR_X_LOC, 0x80, ACCUMULATOR_X_LOC, 0x40))\n\n            // ACCUMULATE ID1\n\n            // Verification key fields verified to be on curve at contract deployment\n            mstore(0x00, mload(ID1_X_LOC))\n            mstore(0x20, mload(ID1_Y_LOC))\n            mstore(0x40, mload(C_V26_LOC))\n            // accumulator_2 = v26.[ID1]\n            success := and(success, staticcall(gas(), 7, 0x00, 0x60, ACCUMULATOR2_X_LOC, 0x40))\n            // accumulator = accumulator + accumulator_2\n            success := and(success, staticcall(gas(), 6, ACCUMULATOR_X_LOC, 0x80, ACCUMULATOR_X_LOC, 0x40))\n\n            // ACCUMULATE ID2\n\n            // Verification key fields verified to be on curve at contract deployment\n            mstore(0x00, mload(ID2_X_LOC))\n            mstore(0x20, mload(ID2_Y_LOC))\n            mstore(0x40, mload(C_V27_LOC))\n            // accumulator_2 = v27.[ID2]\n            success := and(success, staticcall(gas(), 7, 0x00, 0x60, ACCUMULATOR2_X_LOC, 0x40))\n            // accumulator = accumulator + accumulator_2\n            success := and(success, staticcall(gas(), 6, ACCUMULATOR_X_LOC, 0x80, ACCUMULATOR_X_LOC, 0x40))\n\n            // ACCUMULATE ID3\n\n            // Verification key fields verified to be on curve at contract deployment\n            mstore(0x00, mload(ID3_X_LOC))\n            mstore(0x20, mload(ID3_Y_LOC))\n            mstore(0x40, mload(C_V28_LOC))\n            // accumulator_2 = v28.[ID3]\n            success := and(success, staticcall(gas(), 7, 0x00, 0x60, ACCUMULATOR2_X_LOC, 0x40))\n            // accumulator = accumulator + accumulator_2\n            success := and(success, staticcall(gas(), 6, ACCUMULATOR_X_LOC, 0x80, ACCUMULATOR_X_LOC, 0x40))\n\n            // ACCUMULATE ID4\n\n            // Verification key fields verified to be on curve at contract deployment\n            mstore(0x00, mload(ID4_X_LOC))\n            mstore(0x20, mload(ID4_Y_LOC))\n            mstore(0x40, mload(C_V29_LOC))\n            // accumulator_2 = v29.[ID4]\n            success := and(success, staticcall(gas(), 7, 0x00, 0x60, ACCUMULATOR2_X_LOC, 0x40))\n            // accumulator = accumulator + accumulator_2\n            success := and(success, staticcall(gas(), 6, ACCUMULATOR_X_LOC, 0x80, ACCUMULATOR_X_LOC, 0x40))\n\n            /**\n             * COMPUTE BATCH EVALUATION SCALAR MULTIPLIER\n             */\n            {\n                /**\n                 * batch_evaluation = v0 * (w_1_omega * u + w_1_eval)\n                 * batch_evaluation += v1 * (w_2_omega * u + w_2_eval)\n                 * batch_evaluation += v2 * (w_3_omega * u + w_3_eval)\n                 * batch_evaluation += v3 * (w_4_omega * u + w_4_eval)\n                 * batch_evaluation += v4 * (s_omega_eval * u + s_eval)\n                 * batch_evaluation += v5 * (z_omega_eval * u + z_eval)\n                 * batch_evaluation += v6 * (z_lookup_omega_eval * u + z_lookup_eval)\n                 */\n                let batch_evaluation :=\n                    mulmod(\n                        mload(C_V0_LOC),\n                        addmod(mulmod(mload(W1_OMEGA_EVAL_LOC), mload(C_U_LOC), p), mload(W1_EVAL_LOC), p),\n                        p\n                    )\n                batch_evaluation :=\n                    addmod(\n                        batch_evaluation,\n                        mulmod(\n                            mload(C_V1_LOC),\n                            addmod(mulmod(mload(W2_OMEGA_EVAL_LOC), mload(C_U_LOC), p), mload(W2_EVAL_LOC), p),\n                            p\n                        ),\n                        p\n                    )\n                batch_evaluation :=\n                    addmod(\n                        batch_evaluation,\n                        mulmod(\n                            mload(C_V2_LOC),\n                            addmod(mulmod(mload(W3_OMEGA_EVAL_LOC), mload(C_U_LOC), p), mload(W3_EVAL_LOC), p),\n                            p\n                        ),\n                        p\n                    )\n                batch_evaluation :=\n                    addmod(\n                        batch_evaluation,\n                        mulmod(\n                            mload(C_V3_LOC),\n                            addmod(mulmod(mload(W4_OMEGA_EVAL_LOC), mload(C_U_LOC), p), mload(W4_EVAL_LOC), p),\n                            p\n                        ),\n                        p\n                    )\n                batch_evaluation :=\n                    addmod(\n                        batch_evaluation,\n                        mulmod(\n                            mload(C_V4_LOC),\n                            addmod(mulmod(mload(S_OMEGA_EVAL_LOC), mload(C_U_LOC), p), mload(S_EVAL_LOC), p),\n                            p\n                        ),\n                        p\n                    )\n                batch_evaluation :=\n                    addmod(\n                        batch_evaluation,\n                        mulmod(\n                            mload(C_V5_LOC),\n                            addmod(mulmod(mload(Z_OMEGA_EVAL_LOC), mload(C_U_LOC), p), mload(Z_EVAL_LOC), p),\n                            p\n                        ),\n                        p\n                    )\n                batch_evaluation :=\n                    addmod(\n                        batch_evaluation,\n                        mulmod(\n                            mload(C_V6_LOC),\n                            addmod(mulmod(mload(Z_LOOKUP_OMEGA_EVAL_LOC), mload(C_U_LOC), p), mload(Z_LOOKUP_EVAL_LOC), p),\n                            p\n                        ),\n                        p\n                    )\n\n                /**\n                 * batch_evaluation += v7 * Q1_EVAL\n                 * batch_evaluation += v8 * Q2_EVAL\n                 * batch_evaluation += v9 * Q3_EVAL\n                 * batch_evaluation += v10 * Q4_EVAL\n                 * batch_evaluation += v11 * QM_EVAL\n                 * batch_evaluation += v12 * QC_EVAL\n                 * batch_evaluation += v13 * QARITH_EVAL\n                 * batch_evaluation += v14 * QSORT_EVAL_LOC\n                 * batch_evaluation += v15 * QELLIPTIC_EVAL_LOC\n                 * batch_evaluation += v16 * QAUX_EVAL_LOC\n                 * batch_evaluation += v17 * SIGMA1_EVAL_LOC\n                 * batch_evaluation += v18 * SIGMA2_EVAL_LOC\n                 * batch_evaluation += v19 * SIGMA3_EVAL_LOC\n                 * batch_evaluation += v20 * SIGMA4_EVAL_LOC\n                 */\n                batch_evaluation := addmod(batch_evaluation, mulmod(mload(C_V7_LOC), mload(Q1_EVAL_LOC), p), p)\n                batch_evaluation := addmod(batch_evaluation, mulmod(mload(C_V8_LOC), mload(Q2_EVAL_LOC), p), p)\n                batch_evaluation := addmod(batch_evaluation, mulmod(mload(C_V9_LOC), mload(Q3_EVAL_LOC), p), p)\n                batch_evaluation := addmod(batch_evaluation, mulmod(mload(C_V10_LOC), mload(Q4_EVAL_LOC), p), p)\n                batch_evaluation := addmod(batch_evaluation, mulmod(mload(C_V11_LOC), mload(QM_EVAL_LOC), p), p)\n                batch_evaluation := addmod(batch_evaluation, mulmod(mload(C_V12_LOC), mload(QC_EVAL_LOC), p), p)\n                batch_evaluation := addmod(batch_evaluation, mulmod(mload(C_V13_LOC), mload(QARITH_EVAL_LOC), p), p)\n                batch_evaluation := addmod(batch_evaluation, mulmod(mload(C_V14_LOC), mload(QSORT_EVAL_LOC), p), p)\n                batch_evaluation := addmod(batch_evaluation, mulmod(mload(C_V15_LOC), mload(QELLIPTIC_EVAL_LOC), p), p)\n                batch_evaluation := addmod(batch_evaluation, mulmod(mload(C_V16_LOC), mload(QAUX_EVAL_LOC), p), p)\n                batch_evaluation := addmod(batch_evaluation, mulmod(mload(C_V17_LOC), mload(SIGMA1_EVAL_LOC), p), p)\n                batch_evaluation := addmod(batch_evaluation, mulmod(mload(C_V18_LOC), mload(SIGMA2_EVAL_LOC), p), p)\n                batch_evaluation := addmod(batch_evaluation, mulmod(mload(C_V19_LOC), mload(SIGMA3_EVAL_LOC), p), p)\n                batch_evaluation := addmod(batch_evaluation, mulmod(mload(C_V20_LOC), mload(SIGMA4_EVAL_LOC), p), p)\n\n                /**\n                 * batch_evaluation += v21 * (table1(zw) * u + table1(z))\n                 * batch_evaluation += v22 * (table2(zw) * u + table2(z))\n                 * batch_evaluation += v23 * (table3(zw) * u + table3(z))\n                 * batch_evaluation += v24 * (table4(zw) * u + table4(z))\n                 * batch_evaluation += v25 * table_type_eval\n                 * batch_evaluation += v26 * id1_eval\n                 * batch_evaluation += v27 * id2_eval\n                 * batch_evaluation += v28 * id3_eval\n                 * batch_evaluation += v29 * id4_eval\n                 * batch_evaluation += quotient_eval\n                 */\n                batch_evaluation :=\n                    addmod(\n                        batch_evaluation,\n                        mulmod(\n                            mload(C_V21_LOC),\n                            addmod(mulmod(mload(TABLE1_OMEGA_EVAL_LOC), mload(C_U_LOC), p), mload(TABLE1_EVAL_LOC), p),\n                            p\n                        ),\n                        p\n                    )\n                batch_evaluation :=\n                    addmod(\n                        batch_evaluation,\n                        mulmod(\n                            mload(C_V22_LOC),\n                            addmod(mulmod(mload(TABLE2_OMEGA_EVAL_LOC), mload(C_U_LOC), p), mload(TABLE2_EVAL_LOC), p),\n                            p\n                        ),\n                        p\n                    )\n                batch_evaluation :=\n                    addmod(\n                        batch_evaluation,\n                        mulmod(\n                            mload(C_V23_LOC),\n                            addmod(mulmod(mload(TABLE3_OMEGA_EVAL_LOC), mload(C_U_LOC), p), mload(TABLE3_EVAL_LOC), p),\n                            p\n                        ),\n                        p\n                    )\n                batch_evaluation :=\n                    addmod(\n                        batch_evaluation,\n                        mulmod(\n                            mload(C_V24_LOC),\n                            addmod(mulmod(mload(TABLE4_OMEGA_EVAL_LOC), mload(C_U_LOC), p), mload(TABLE4_EVAL_LOC), p),\n                            p\n                        ),\n                        p\n                    )\n                batch_evaluation := addmod(batch_evaluation, mulmod(mload(C_V25_LOC), mload(TABLE_TYPE_EVAL_LOC), p), p)\n                batch_evaluation := addmod(batch_evaluation, mulmod(mload(C_V26_LOC), mload(ID1_EVAL_LOC), p), p)\n                batch_evaluation := addmod(batch_evaluation, mulmod(mload(C_V27_LOC), mload(ID2_EVAL_LOC), p), p)\n                batch_evaluation := addmod(batch_evaluation, mulmod(mload(C_V28_LOC), mload(ID3_EVAL_LOC), p), p)\n                batch_evaluation := addmod(batch_evaluation, mulmod(mload(C_V29_LOC), mload(ID4_EVAL_LOC), p), p)\n                batch_evaluation := addmod(batch_evaluation, mload(QUOTIENT_EVAL_LOC), p)\n\n                mstore(0x00, 0x01) // [1].x\n                mstore(0x20, 0x02) // [1].y\n                mstore(0x40, sub(p, batch_evaluation))\n                // accumulator_2 = -[1].(batch_evaluation)\n                success := and(success, staticcall(gas(), 7, 0x00, 0x60, ACCUMULATOR2_X_LOC, 0x40))\n                // accumulator = accumulator + accumulator_2\n                success := and(success, staticcall(gas(), 6, ACCUMULATOR_X_LOC, 0x80, ACCUMULATOR_X_LOC, 0x40))\n\n                if iszero(success) {\n                    mstore(0x0, OPENING_COMMITMENT_FAILED_SELECTOR)\n                    revert(0x00, 0x04)\n                }\n            }\n\n            /**\n             * PERFORM PAIRING PREAMBLE\n             */\n            {\n                let u := mload(C_U_LOC)\n                let zeta := mload(C_ZETA_LOC)\n                // VALIDATE PI_Z\n                {\n                    let x := mload(PI_Z_X_LOC)\n                    let y := mload(PI_Z_Y_LOC)\n                    let xx := mulmod(x, x, q)\n                    // validate on curve\n                    if iszero(eq(mulmod(y, y, q), addmod(mulmod(x, xx, q), 3, q))) {\n                        mstore(0x0, POINT_NOT_ON_CURVE_SELECTOR)\n                        revert(0x00, 0x04)\n                    }\n                    mstore(0x00, x)\n                    mstore(0x20, y)\n                }\n                // compute zeta.[PI_Z] and add into accumulator\n                mstore(0x40, zeta)\n                success := staticcall(gas(), 7, 0x00, 0x60, ACCUMULATOR2_X_LOC, 0x40)\n                // accumulator = accumulator + accumulator_2\n                success := and(success, staticcall(gas(), 6, ACCUMULATOR_X_LOC, 0x80, ACCUMULATOR_X_LOC, 0x40))\n\n                // VALIDATE PI_Z_OMEGA\n                {\n                    let x := mload(PI_Z_OMEGA_X_LOC)\n                    let y := mload(PI_Z_OMEGA_Y_LOC)\n                    let xx := mulmod(x, x, q)\n                    // validate on curve\n                    if iszero(eq(mulmod(y, y, q), addmod(mulmod(x, xx, q), 3, q))) {\n                        mstore(0x0, POINT_NOT_ON_CURVE_SELECTOR)\n                        revert(0x00, 0x04)\n                    }\n                    mstore(0x00, x)\n                    mstore(0x20, y)\n                }\n                mstore(0x40, mulmod(mulmod(u, zeta, p), mload(OMEGA_LOC), p))\n                // accumulator_2 = u.zeta.omega.[PI_Z_OMEGA]\n                success := and(success, staticcall(gas(), 7, 0x00, 0x60, ACCUMULATOR2_X_LOC, 0x40))\n                // PAIRING_RHS = accumulator + accumulator_2\n                success := and(success, staticcall(gas(), 6, ACCUMULATOR_X_LOC, 0x80, PAIRING_RHS_X_LOC, 0x40))\n\n                mstore(0x00, mload(PI_Z_X_LOC))\n                mstore(0x20, mload(PI_Z_Y_LOC))\n                mstore(0x40, mload(PI_Z_OMEGA_X_LOC))\n                mstore(0x60, mload(PI_Z_OMEGA_Y_LOC))\n                mstore(0x80, u)\n                success := and(success, staticcall(gas(), 7, 0x40, 0x60, 0x40, 0x40))\n                // PAIRING_LHS = [PI_Z] + [PI_Z_OMEGA] * u\n                success := and(success, staticcall(gas(), 6, 0x00, 0x80, PAIRING_LHS_X_LOC, 0x40))\n                // negate lhs y-coordinate\n                mstore(PAIRING_LHS_Y_LOC, sub(q, mload(PAIRING_LHS_Y_LOC)))\n\n                if mload(CONTAINS_RECURSIVE_PROOF_LOC) {\n                    // VALIDATE RECURSIVE P1\n                    {\n                        let x := mload(RECURSIVE_P1_X_LOC)\n                        let y := mload(RECURSIVE_P1_Y_LOC)\n                        let xx := mulmod(x, x, q)\n                        // validate on curve\n                        if iszero(eq(mulmod(y, y, q), addmod(mulmod(x, xx, q), 3, q))) {\n                            mstore(0x0, POINT_NOT_ON_CURVE_SELECTOR)\n                            revert(0x00, 0x04)\n                        }\n                        mstore(0x00, x)\n                        mstore(0x20, y)\n                    }\n\n                    // compute u.u.[recursive_p1] and write into 0x60\n                    mstore(0x40, mulmod(u, u, p))\n                    success := and(success, staticcall(gas(), 7, 0x00, 0x60, 0x60, 0x40))\n                    // VALIDATE RECURSIVE P2\n                    {\n                        let x := mload(RECURSIVE_P2_X_LOC)\n                        let y := mload(RECURSIVE_P2_Y_LOC)\n                        let xx := mulmod(x, x, q)\n                        // validate on curve\n                        if iszero(eq(mulmod(y, y, q), addmod(mulmod(x, xx, q), 3, q))) {\n                            mstore(0x0, POINT_NOT_ON_CURVE_SELECTOR)\n                            revert(0x00, 0x04)\n                        }\n                        mstore(0x00, x)\n                        mstore(0x20, y)\n                    }\n                    // compute u.u.[recursive_p2] and write into 0x00\n                    // 0x40 still contains u*u\n                    success := and(success, staticcall(gas(), 7, 0x00, 0x60, 0x00, 0x40))\n\n                    // compute u.u.[recursiveP1] + rhs and write into rhs\n                    mstore(0xa0, mload(PAIRING_RHS_X_LOC))\n                    mstore(0xc0, mload(PAIRING_RHS_Y_LOC))\n                    success := and(success, staticcall(gas(), 6, 0x60, 0x80, PAIRING_RHS_X_LOC, 0x40))\n\n                    // compute u.u.[recursiveP2] + lhs and write into lhs\n                    mstore(0x40, mload(PAIRING_LHS_X_LOC))\n                    mstore(0x60, mload(PAIRING_LHS_Y_LOC))\n                    success := and(success, staticcall(gas(), 6, 0x00, 0x80, PAIRING_LHS_X_LOC, 0x40))\n                }\n\n                if iszero(success) {\n                    mstore(0x0, PAIRING_PREAMBLE_FAILED_SELECTOR)\n                    revert(0x00, 0x04)\n                }\n            }\n\n            /**\n             * PERFORM PAIRING\n             */\n            {\n                // rhs paired with [1]_2\n                // lhs paired with [x]_2\n\n                mstore(0x00, mload(PAIRING_RHS_X_LOC))\n                mstore(0x20, mload(PAIRING_RHS_Y_LOC))\n                mstore(0x40, 0x198e9393920d483a7260bfb731fb5d25f1aa493335a9e71297e485b7aef312c2) // this is [1]_2\n                mstore(0x60, 0x1800deef121f1e76426a00665e5c4479674322d4f75edadd46debd5cd992f6ed)\n                mstore(0x80, 0x090689d0585ff075ec9e99ad690c3395bc4b313370b38ef355acdadcd122975b)\n                mstore(0xa0, 0x12c85ea5db8c6deb4aab71808dcb408fe3d1e7690c43d37b4ce6cc0166fa7daa)\n\n                mstore(0xc0, mload(PAIRING_LHS_X_LOC))\n                mstore(0xe0, mload(PAIRING_LHS_Y_LOC))\n                mstore(0x100, mload(G2X_X0_LOC))\n                mstore(0x120, mload(G2X_X1_LOC))\n                mstore(0x140, mload(G2X_Y0_LOC))\n                mstore(0x160, mload(G2X_Y1_LOC))\n\n                success := staticcall(gas(), 8, 0x00, 0x180, 0x00, 0x20)\n                if iszero(and(success, mload(0x00))) {\n                    mstore(0x0, PAIRING_FAILED_SELECTOR)\n                    revert(0x00, 0x04)\n                }\n            }\n\n            {\n                mstore(0x00, 0x01)\n                return(0x00, 0x20) // Proof succeeded!\n            }\n        }\n    }\n}\n\ncontract WithdrawVerifier is BaseUltraVerifier {\n    function getVerificationKeyHash() public pure override(BaseUltraVerifier) returns (bytes32) {\n        return UltraVerificationKey.verificationKeyHash();\n    }\n\n    function loadVerificationKey(uint256 vk, uint256 _omegaInverseLoc) internal pure virtual override(BaseUltraVerifier) {\n        UltraVerificationKey.loadVerificationKey(vk, _omegaInverseLoc);\n    }\n}\n"
      },
      "project/contracts/LazyIMT.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport {InternalLazyIMT, LazyIMTData} from \"@zk-kit/lazy-imt.sol/InternalLazyIMT.sol\";\n\n// copy pasta of node_modules/@zk-kit/lazy-imt.sol/LazyIMT.sol\n// since hardhat3 wont listen and just deploy lazy-imt\nlibrary LazyIMT {\n    using InternalLazyIMT for *;\n\n    function init(LazyIMTData storage self, uint8 depth) public {\n        InternalLazyIMT._init(self, depth);\n    }\n\n    function defaultZero(uint8 index) public pure returns (uint256) {\n        return InternalLazyIMT._defaultZero(index);\n    }\n\n    function reset(LazyIMTData storage self) public {\n        InternalLazyIMT._reset(self);\n    }\n\n    function indexForElement(uint8 level, uint40 index) public pure returns (uint40) {\n        return InternalLazyIMT._indexForElement(level, index);\n    }\n\n    function insert(LazyIMTData storage self, uint256 leaf) public {\n        InternalLazyIMT._insert(self, leaf);\n    }\n\n    function update(LazyIMTData storage self, uint256 leaf, uint40 index) public {\n        InternalLazyIMT._update(self, leaf, index);\n    }\n\n    function root(LazyIMTData storage self) public view returns (uint256) {\n        return InternalLazyIMT._root(self);\n    }\n\n    function root(LazyIMTData storage self, uint8 depth) public view returns (uint256) {\n        return InternalLazyIMT._root(self, depth);\n    }\n\n    function merkleProofElements(\n        LazyIMTData storage self,\n        uint40 index,\n        uint8 depth\n    ) public view returns (uint256[] memory) {\n        return InternalLazyIMT._merkleProofElements(self, index, depth);\n    }\n\n    function _root(LazyIMTData storage self, uint40 numberOfLeaves, uint8 depth) internal view returns (uint256) {\n        return InternalLazyIMT._root(self, numberOfLeaves, depth);\n    }\n}\n"
      }
    }
  }
}